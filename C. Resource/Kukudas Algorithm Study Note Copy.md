default : 
inline : recursive에서는 안 쓰는 편이 좋다.
static :
	변수명 앞에 붙음 - stack이 아니라 data위치로 간다, 즉 프로그램이 컴파일 되는 시점에 생성된다.
	함수명 앞에 붙음/ 전역 변수 앞에 붙음 - 그 함수가 다른 c파일에서 사용할 수 없다. object파일에 함수 이름이 남지 않는다. 변수 앞에 붙이는 경우가 많다. static을 잘 써주면 code가 훨씬 더 좋아보인다. 면접에서도 좋은 인상을 남길 수 있다.
const : 수정하지 못하게 하는 것
register : 컴파일러가 무시한다. 이 변수를 메모리에서 만들기 말고 레지스터에서 만든다, 하지만 컴파일러가 무시하는 경우가 많다.


funtional programming : ex) 스칼라(Scala), 하스켈(Haskell)

tail recursive : 재귀함수의 최적화를 위해 사용하는 것

int recur(int a, int b) {
	if(a == 0 && b == 0)
		return 0;
	CODES;
	return recur(a - 1, b - 1);
}

-> while(!(a == 0 && b == 0)) {
	CODES;
	a = a - 1, b = b - 1;
}

pure function : input이 정해지면 output이 정해져야 한다. 변수들을 변경 불가 하다.
	단순한 몇개 선언 하나로 복수로 처리할 수 있다.
	전혀 문제 없이 멀티 스레드에서 돌 수 있다는 것이 보장이 된다.

pattern matching : 어떠한 값이 들어왔을 때 이 모양이면 무엇을 하고 이 모양이면 무엇을 하는지 정해지는 것
	모든 input에 대해서 커버 하는지 언어 차원에서 확인할 수 있다.

문제 : 잘 쓰면 좋은데 잘 쓰기가 어렵다...

spark scala : spark란 빅테이터를 처리하는 툴 같은 것

leetCode : 미국의 백준 같은 것

----------------------------------------------------------------------

ios_base::sync_with_stdio(false);
cin.tie(NULL);

printf와 cout이 서로 싸움

----------------------------------------------------------------------

Binary Search

전제 사항 :기본적으로 원소가 정렬이 되어있어야 한다. worstCase에서도 O(logn)이 나와야 한다

가장 많이 하는 실수 : List가 있고 Binary Search로 어디서 부터 Search할지 찾는 것은 매우 어리석은 짓이다.

Hash..? : 면접 볼 때

코테 에서는 어떻게 나오냐? 단순히 찾는 문제들도 많이 나온다.
Binary Search가 내부적으로 구현되어 있기 때문제 굳이 구현할 필요 없다 (Hash 같은)

----------------------------------------------------------------------

sort는 nlog(n)이라고 생각하면 된다.

시간 복잡도를 구할 때, O(VE^2 + V^2E)일 때 V^2가 더 크기도 하고 E^2가 더 크기도 하면 둘 다 쓴다.

----------------------------------------------------------------------

석사까지는 코딩테스트
목적: 코딩테스트

부르트포스
Tree DP 게임이론, recursion

파라미터로 넘기기

Indent 줄이기

-----------------------------------------------------------------------

- 변수명 유의, 직관성 부여
- 프로그램이 버퍼와 관련해 더 빠르게 돌아가게 하려면 cout에 "\n"를 쓰는 것이 좋음
- 인덱스 번호 부여 시 "%"도 적극 활용할 것
- 

- LIS?? : 문제를 읽었을 때 LIS라는 걸 바로 캐치 못 할수도 있음 ( https://www.acmicpc.net/problem/2565 )

- 내리막길 https://www.acmicpc.net/problem/1520
- https://www.acmicpc.net/problem/2438

- recursive : 기능을 생각하고 일단 확실한 목적을 가진 함수로 선언하고 나중에 짜기
- 별 찍기 문제 9개 풀기

-----------------------------------------------------------------------

Binary Search : 경계가 어디인지를 찾아나가는 것이라고 생각할 것
이진 탐색 시, 같은 경우 mid를 어떻게 다룰지를 잘 생각해봐야 한다.


rope[100001];
int *ptr = rope + 1;
rope[0] = 0;
ptr_rope[-1] == 0;

-----------------------------------------------------------------------

자주사용하는 STL이, vector, map, set, pair, priority_queue, queue 정도
if( condition ) { operation; } 같이 한 줄로 표현할 수 있어도 개행 하기
for문 안에서만 선언되는 변수는 되도록 for문 안에서만 선언하기
변수명을 카멜케이스로 할지 스네이크케이스로 할지 잘 결정하기 (MAX_INPUT 같은 상수 제외)

-----------------------------------------------------------------------

Trie(트라이)

구현하기 상대적으로 쉽기 때문에 코테에 자주 나온다.
트라이 : 문자열을 효율적으로 탐색하기 위한 자료구조
https://twpower.github.io/186-trie-concept-and-basic-problem-en
https://www.acmicpc.net/problem/5052 (전화번호 목록)
https://www.acmicpc.net/problem/14725 (개미굴)

Spanning Tree(신장 트리)

모든 vertex들이 이어지는 트리
cycle이 없어야 한다. (한붓 그리기는 아님)
그냥 구현을 할 수 있냐 없냐 정도의 차이이다. 자료구조를 확실하게 아는 것이 관건일듯.
Kruskals, Prim 알고리즘
https://www.acmicpc.net/problem/6497 (전력난)

--------------------------------------------------------------------------------

큰 흐름 : 대략적인 알고리즘 즉, 토대
작은 흐름 : 큰 흐름이 정해지면 전체적인 플로우를 생각하는 것

알고리즘 >> 자료구조 >> 최종 시간복잡도 >> 문제를 풀 수 있는지 확인

--------------------------------------------------------------------------------

# 전화번호부 목록
- input을 []안에도 넣을 수 있고, 함수() 안에도 넣을 수 있다. 
- phone number를 싸그리 input으로 받아서 함
- 하나를 받고 update trie하면서 판단하는 것
- "_end"를 차라리 전역 변수로 선언해서 하면 나중에 오류 판단할 때 도움된다.

trie를 map으로 구현할 때
void printTree(map<string, void*> *node, int depth)

C로 한 번 짜보기!!
문제 보고 생각나는 자료구조 여러개 보내서 어떤게 장점이 있는지 같이 토의해주신다고 함

# 개미굴
- "_end" 필요없음
- range에 0붙일 필요 없음
- food_list.append(list(input().split())[1:]) ; 인덱스 1에서부터만 읽어내림

# 파일 합치기
- bottom of??
- 코테 때 배열의 크기를 타이트하게 줄 필요 없이 느슨하게 주기

# 택배 배달
- struct부분이 재사용성과 코데 사이에서 참 애매하다
- 코테 용이면 struct를 안쓰고 재사용성 위해서면 class를 쓸 것 같다
- 객체 지향이 필요한데 못 보여줄거면 c++로 시작하지 않는게 좋다(면접에서 할 말이 없어짐)
- pair나 tuple을 쓰는게 났다. pair 여러개 묶는 걸로 구현 해도 된다.
- pair<int, pair<pair<int, double>, int>>
- make_pair(a, -b);하면 a는 오름차순, b는 내림차순을 하나의 operend를 가지고 만들 수 있다.
```cpp
make_pair(a, -b);
sort(......);
alpha.first, -alpha.second
```
- define_in_order 코드 좀 간략하게 짜자 서임아... return에 비교 연산자를 넣어버려
- 변수를 보고 어? 얘 무슨 값이지 하고 찾았을 떄 편하게 찾을 수 있게 변수 배치

# 친구 네트워크
- 복잡하게 생각했음
- 이름이 고유한 값이기 때문에 `friend_set[]`, number을 `map<string>`으로 바꿔도 된다.
```cpp
 # include map
...
map<string, pair<string, int>> friends_rep;
```


------------------------------------------------------------------------------

# 전기가 부족해
for문을 다 도나 if문 해서 빠져나오나 시간 복잡도는 차이가 없다.
set 보다는 다른 이름으로	// c++에 있는 이름임 (위험함!)
class를 하면 초기화 되는 시간이 조금 늘어남, 근데 코테에서 class 쓰지 말아야 하나? 라는 건 신경 안 써도 됨
한 줄 짜리가 너무 길다 싶으면 enter 써서 걍 줄바꿈을 해라.
69줄이 비효율적임 
union set의 성질 : parent 밑에 있는 애들을 고려하지 않아도 된다는게 특징임. 내가 밑에 애들을 고려하고 있으면 어? 내가 잘못 짜고 있나를 의심해 봐야함.

if문을 줄일 때의 접근
- 어떻게 하면 공통적으로 가져갈 수 있지 or 일반화?
- continue를 쓸 생각

------------------------------------------------------------------------------

# 14621 나만 안되는 연애
남남, 여여끼리의 동선끼리는 edge로 만들지 않고 mst로 푼다는 아이디어
size_t를 쓴다는 선택은 정석적으로 굉장히 좋은 선택

```cpp
union_element() {
...
return union_set[element] = find_parent(union_set, union_set[element]);	// union_set을 업데이트 해줘야한다.
}
```

return 0 을 중간에 써도 된다.


# 1377 버블 소트
사실 함정으로 냄
버블 소트 알고리즘은 비효율적이다.
직접 때려서 출력하기에는 시간 복잡도가 N^2이기 때문에 엄청 오래 걸린다.
한 번도 안 바뀌었을 때 바로 break된다. 그때의 i값을 출력하면 된다.
i가 돌 때마다 maximum value를 밖으로 끌고 오는 구조이다.

-----------------------------------------------------------------------------

Brute force 알고리즘
어? 이게 뭐지? 내가 풀고 있는게 맞나? 엥? 이라는 생각을 하게 돼서 못 푸는 경우가 많다.
무식하게 다 짜야되는 알고리즘이기 때문에 내가 어떻게 구현하느냐에 따라 코드의 길이가 달라질 뿐.
삼성전자에서 많이 내는 알고리즘이다.
이런 걸 풀면 어떻게 프로그램 구조를 가져갈지 파악할 수 있다.

# 테트로미노
simulation과 겹치는 문제
구현을 어떻게느냐에 따라 코드량이 달라진다.

# N-Queen
진짜 무식하게 보드판을 안에서 만들어서 하나씩 퀸을 놓아가면서 파악한다...
숫자를 진짜 하나하나 다 센다.

# 감시

-----------------------------------------------------------------------------

Recursion (재귀)
나도 최선 vs 상대방도 최선일때, 누가 이기느냐 같은 문제가 게임회사에서 많이 나온다.

# 돌 게임
어떠한 방식으로도 이기는 방법이 없으면 나는 진다 하고 넘어가는 방식

-----------------------------------------------------------------------------

# 테트로미노

--------------------------

MST 알고리즘

- Kruskal 알고리즘
전체 cost중에서 최소인 애만 계속 뽑는데, cycle이 생길때 선택하지 않는다.
sort 한 번 하고 뽑으면 된다. Cycle 확인은 disjoint set으로 하는 것이 좋다. (DPS로 하면 시간 터진다...)

- Prim 알고리즘
다익스트라랑 유사하다.
시작점에서 인점 노드 중에 최소인 것을 선택
다익스트라는 priority에 합한 것을 넣지만
다익스트라는 출발지라는 개념이 있지만
프림은 전체 경로의 최솟값을 찾는다. 즉, 출발지라는 개념이 없다.

- reference
https://gmlwjd9405.github.io/2018/08/30/algorithm-prim-mst.html

----------------------------------------------------------------------------

# 5430 AC

- 풀이는 딱히 없고 실행을 하면 된다.
- 뒤집는 것이 시간복잡도가 크기 때문에 마지막에 뒤집는 것이 좋다.
- cin과 cout 최적화 해보기(구글링)

# 11054 가장 긴 바이토닉 부분 수열

- 가장 긴 증가하는 부분 수열을 대칭화하면 된다.
- 같은 기능을 하는 부분이 있는데 그 부분을 함수화해서 따로 빼줘서 가독성 높이기
- array[cin_size]도 가능 함. 코테에서 신경써야 할 부분은 아님.

# 7511 소셜 네트워킹 어플리케이션

- 명백한 disjoint set
- 별달리 특별한 부분은 없다..
- void 마지막에 return은 빼줘도 된다.
- 앞에 함수 언급에서 int*, int이렇게가 아니라 변수명도 언급해주면 가독성이 올라간다.

# 12904 A와 B