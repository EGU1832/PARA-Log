# Lab 0: Pintos

> Pintos 설치

cspro9.sogang.ac.kr 사용

tar 압축 해제
.bashrc에 PATH추가
/pintos/src/thread에서 make
util에 들어가지말고 make 해놨던 디렉토리에서
-q 옵션: ctrl c같은거
실습할때마다 실습할 디렉토리가 달라진다. 따라서 Phase에 맞춰서 디렉토리를 잘 들어가자.

제출
-v -- -q 명령어를 돌려서 정상동작하는 걸 캡처. `이게 다.`

# PintOS Project Phase #1

```cpp
pintos --filesys-size=2 -p ../examples/echo -a echo -- -f -q run 'echo x'
```
명령을 실행하면 명령이 실행 완료 되었다고는 뜨는데 실제로 수행된 결과가 안 보인다.
그 이유는 현재 Pintos에선 다음과 같은 과정이 아직 적용되지 않았기 때문이다.
- system call
- system call handler
- argument passing
- user stack
이외에도 많은 OS 기능들이 구현되어있찌 않다.

이 프로젝트에서는 Pintos가 User Program을 정상적으로 작동할 수 있도록 하는 것이 목표이다.
이를 위해선 다음과 같은 파일들을 수정해야한다.
![600](../../../../z.%20Docs/img/Pasted%20image%2020240918180938.png)

#### Reference
[서강대학교 핀토스 - project 1 (witch.work)](https://witch.work/posts/pintos-2)

# PinOS Project Phase #2

#### Reference
[서강대학교 핀토스 - project 2 (witch.work)](https://witch.work/posts/pintos-3)

File System
0과 1로 이루어진 것을 우리가 이해하기 쉬운 형태로 보여주는 것

Metadata
File과 관련된 정보들 (수정 날짜, 위치 등)

나머지 System Call 작성
기본적인 File System api는 구현이 되어있기에 대충 이게 뭐하는지만 이해하고 가져다 쓰면 된다.

Pintos는 우리가 알고있는 File System에 비해서 기능이 몇 개 빠져있다. `허접..`
- Internal Synch가 없다.
- File Size가 생성 시점에 고정된다. `Prj #5`
- File `Prj #5`
- 루트 폴터 하위에 폴더가 없다. 즉, `/`에서만 작업한다고 가정
- 이름 14글자 제한

File 구조체
```c
struct file {
	struct inode *inode;   //
	off_t pos;   // 어떤 위치에 쓰기나 읽기를 하는지
	bool deny_write;  // Internal Synch -r, -w 같은거
}
```

시스템 call -> Exception -> File System API -File Struct-> File IO

11p.의 두 번째 처럼 syscall handler를 작성하면 된다.
file system 번호 할당 받기
filesystem api로 file 구조체를 가져와서
구조체..?

STDIN = 0
STDOUT = 1
STDERR = ? (Pintos에선 없음, 원래는 2)

read(0) := scanf() := input_setc(void)
write(1) := printf() := gets..

/ Internal Synch
a.out 같은 걸 실행 중인데 쓰기를 해버리면 예상치 못한 문제 발생 가능
API와 lock semaphore를 이용하여 이러한 문제 방지
- syn-read
- syn-write 같은 testcase 있음

# Pintos Project Phase #3

Alarm Clock
Priority Array
Multilevel Fdedback Queue

멀티 스레스에서 어떠헥 스케줄링을 할 것인지 구현해야된다.
현재는 Round Robin으로 구현되어있다.

/ RR of Pintos
thread_yeild()
ready_list: Block 상태의 Thread가 들어가있음
scedule(): read_list의 head에 있는 thread를 가져오고 switch_threads로 Context Switch 해준다.

/ Thread
Code Data는 공유
나머지는 별개

/ Synchronization
Semaphore도 thread Context Switch를 이용하는 것
Lock도 Semaphore의 refer함수 (value가 1인 semaphore)

(1) Alarm Clock
1 tick: 10 ms
ready_list말고 별도의 list 추가 timer_list
timer_interrupt안에서 관리하는 list
목적: Context Switch할 때 register를 바꿔끼는 비효울적인 동작을 개선하기

(2) Priority Scheduling
우리가 CSE4070에서 배운 것 처럼 우선순위를 고려하는 스케줄러를 만들어야된다.
추천: Queue를 64개를 만들어서 가장 높이 있는 Queue를 RR
Aging: 오래된 thread일수록 priority를 높여야 한다.
`31p.`의 코드를 작성
새 tar 파일이 제공됨

(3) Advanced Scheduler
load_avg: 있는대로 공식을 써서 구현하면 된다.
`41p.`에 정리되어있는 그림을 잘 참조하여 구현

Fixed-Point Real Arigh
헤더 파일 하나를 만들어서 메크로로 만드는 것을 추천

#### Alarm Clock 개선

thread.h에 timer_list 생성: timer_interrupt가 관리하는 list로, blocked된 thread들을 관리한다.
- thread가 timer_sleep 호출 시: 그 thread 저장, wakeup_tick 저장
- wakeup_tick으로 설정한 시점이 되면 해당 thread timer_list에서 제거 후 ready_list에 넣어줌: timer_interrupt 사용

# Pintos Project Phase #4

현 시점의 PintOS는,
`palloc_get_page()`: 그냥 간단하게 User Memory를 frame 단위로 나눠주는 기능 밖에 없다.

이 Phase에선 Virtual Memory Paging을 할 것이다.
- Supplemental Page Table
- Demand Paging
- Disk Swapping

결국 Page Fault Handler를 수정해줘야 한다.

/ Supplemental Page Table
PTE: Hash 사용

/ Page Fault Handler
변환 정보가 없다면 -> MMU에서 Exception을 일으키게 되고 Page Fault Handler가 돌아가게 된다.
이를 `9p.`에 나와있는 것처럼 설계 해야한다.
- PTE가 없다면: Stack Growth의 상황

/ Disk Swapping
1. Disk의 Swap Space로의 Frame 단위 Tracking을 위해 자료구조가 따로 또 있어야 한다.
2. Frame이 다 찼을 때 어떤 녀석을 희생자로 고를지 Second Chance Clock Algorithm을 이용하여 죽임

/ Stack Growth `Heap은 안함`
Stack은 유동적이기 때문에 단순히 Unmmaped된 Data, Code를 Mapping 해주는 것과 달리 다른 매커니즘이 필요하다.
1. Faulting Address가 Valid 한지 확인

page-merge-mm 같은 게 아마 안돌아 갈거임. 추가 구현 필요
