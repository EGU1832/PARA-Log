# 난수 생성 방식

LCG(Linear Congruential Generator)와 MT(Mersenne Twister)와 같은 PRNG(의사 난수 생성기) 이외의 난수 생성 방식에 대해서 설명

#### 1. Xorshift
> XOR 연산과 비트 Shift 연산을 결합하여 난수를 생성하는 방법

간단하고 빠른 구현이 가능하여 고속으로 난수를 생성할 수 있고, LCG 보다 품질도 좋다. 하지만 몇몇 난수 품질 테스트를 통과하지 못하는 경우가 있다고 한다.
XorShift 알고리즘의 난수 생성 코드는 다음과 같다.
```c
uint32_t x, y, z, w;  // 4개의 상태 변수
// x, y, z의 값이 순환적으로 이동하여 각 변수들이 난수 생성 과정에 기여한다.

uint32_t xorshift128(void) {
    uint32_t t = x;  // 난수 생성의 기초가 되는 가장 오래된 상태
    t ^= t << 11;
    t ^= t >> 8;
    x = y; y = z; z = w;  // 순환
    w ^= w >> 19;
    w ^= t;  // 최종 난수
    return w;
}
```

#### 2. ChaCha20
> $4\times 4$ 행렬을 사용하는 Block 문자열 암호 알고리즘으로 개발되었으나 암호학적으로 안전한 난수 Sequence를 생성하는 데에도 이용되는 방법

**(1) 512-bit Block Initialize**
각 행렬의 16개의 요소는 32-bit(`0x????????`)이고, 각 요소마다 역할이 부여되어있다. 이를 시각화 하면 다음과 같다.
```
0xcccccccc  0xcccccccc  0xcccccccc  0xcccccccc  // c: Constant (상수)
0xkkkkkkkk  0xkkkkkkkk  0xkkkkkkkk  0xkkkkkkkk  // k: Key (생성될 난수에 해당하는 부분)
0xkkkkkkkk  0xkkkkkkkk  0xkkkkkkkk  0xkkkkkkkk  // b: Blockcount (블록 식별자)
0xbbbbbbbb  0xnnnnnnnn  0xnnnnnnnn  0xnnnnnnnn  // n: Nonce (Key마다 다른 값, 블록 반복 방지 )
```

**(2) Quater Round**
그리고 두 번의 Round 연산이 진행된다.
- 열로 묶어서 각 요소에 대해 한 번 `Column Rounds`
- 대각선으로 묶어서 각 요소에 대해 한 번 진행된다 `Diagonal Rounds, 대각선으로 묶는다는 건  Determinant 계산할 때와 같이 행렬을 확장하여 묶는다는 것이다.`
Round 연산이란 비트 회전 및 XOR 연산을 이용한 것으로 코드로 나타내면 다음과 같다.
```c
// a, b, c, d 순서대로 Column, Diagonal 방법으로 묶은 각 요소에 해당한다.
a += b; d ^= a; d <<<= 16;
c += d; b ^= c; b <<<= 12;
a += b; d ^= a; d <<<= 8;
c += d; b ^= c; b <<<= 7;
```
실제 코드에선 행렬에 `Column Round + Diagonal Round` 계산을 적용하는 것을 총 10번 반복하고 있으므로 $(1+1)\times 10$해서 ChaCha"20"이라고 불리는 것 같다.

**(3) Serialize**
마지막으로 QR 계산 이전의 상태`workstate`를 이후의 상태`state`에 더해준 다음 이를 직렬화 하여 Byte 배열 형태로 반환한 것이 암호 생성 결과가 된다.
난수 생성기로 쓴다는 것은 이 Byte 배열을 활용한 것 뿐이다.

ChaCha20은 난수 생성기로도 쓰이나 이는 부차적인 용도일 뿐이고, 주로 TLS 프로토콜이나 크롬, 파이어폭스와 같은 웹 브라우저에서 안전한 연결을 위해 사용된다. 정확히는 ChaCha20-Poly1305로, 데이터의 무결성이 보장된 ChaCha20의 변형 알고리즘이 쓰인다.

#### 3. QRNG (Quantom Random Number Generator)
> 양자역학적 성질을 이용하여 난수를 생성하는 방법

강의자료에 포함된 방법과 위에서 소개한 방법들은 모두 의사난수(Pseudo Random)를 생성하는 방법들로, 어디까지나 컴퓨터 알고리즘을 통해 생성하는 방식이기 때문에 결국에는 패턴이 생길 수 밖에 없다.
따라서 고안된 것이 양자역학적 성질을 이용하여 인공이 아닌 자연의 무작위성을 측정해 난수를 생성하는 방법인 QRNG이다.

/ **QRNG의 종류**

(1) 빛의 랜덤성을 이용한 방식
![300](../../../../Z.%20Docs/img/Pasted%20image%2020241104150934.png)
- 단일 광자가 빔 스플리터를 통과할 때 물리 법칙상 어느 방향으로 갈지 예측할 수 없다는 점을 이용하여 난수를 생성한다.
- 위의 그림에선 방향이 꺾이면 `0`, 그대로 진행하면 `1`로 지정하여 비트값이 생성된다.

(2) 방사성 동위원소의 자연붕괴 현상을 이용한 방식
![300](../../../../Z.%20Docs/img/Pasted%20image%2020241104150948.png)
- 방사성 동위원소가 불규칙적으로 붕괴되는 현상을 이용하여 난수를 생성한다.
- 위의 그림에선 Mesuring Device(게이거-밀러 계수기, 섬광계 등)에서 감지된 이벤트를 바탕으로 감지된 횟수나 간격을 계산하여 비트 값 `0` 또는 `1`을 생성해낸다.

----------------------------------------------

# Delaunay Triangulation and Voronoi Diagram

## Delaunay Triangulation
> Delaunay Triangulation 알고리즘을 Sudo Code로 설명

```sudo
모든 점을 포함할 수 있는 "Super_Triangle"을 생성한다.
이 Super_Triangle을 self.triangles에 추가한다.

self.points의 각 점 p에 대해:
	점 p가 추가됨으로 인해 Delunay 조건을 충족하지 않는 "Bad_Triagle"을 찾는다.
	// 외접원 검사는 행렬식을 이용한다.
	self.triangles에서 모든 Bad_Triangle을 제거한다.
	
	Bad_Triangle을 제거하면 남는 경계의 각 변에 대해:
		해당 변과 점 p로 구성된 새 삼각형 "New_Triangle" 을 생성한다.
	
	New_Triangles를 Result_Triangles에 추가한다.

self.triangles에서 Super_Triangle의 각 점과 점을 공유하는 삼각형들을 제거한다.

return self.triangles
```
해당 Sudo Code는 점을 하나씩 추가하며 Delaunay Triangulation을 점진적으로 수행하는 Bowyer-Watson 알고리즘을 기반으로 작성되었다.

/ *Bowyer-Watson Algorithm*
Delaunay Triangulation에 포함되는 삼각형의 집합을 $D$라고 하고,
만약 Delaunay Triangulation이 이루어진 상태에서 어떤 점 $p$를 추가했다고 했을 때 새로 생성 될 삼각형의 집합을 $D'$라고 했을 때
$$dist(p, u) < r \text{ for all } u \in T,\ T \in D$$
`r은 삼각형 T의 외접원의 반지름`
이러한 $T$를 Bowter-Watson Algorithm에서는 Bad Triangle, 즉 없어져야 할 삼각형이라고 하며 새로운 점이 추가될 때마다 이를 제거한다.

Bad Triangle을 모두 제거하고 나면 $p$를 포함하는 새로운 삼각형을 추가해야 하는데, 이는 Bad Triangle을 제거할 때 각 변이 제거된 횟수를 세는 것으로 알 수 있다.
한 번만 제거된 변과 점 $p$로 이루어진 삼각형이 새로 추가할 New Triangle이 된다.

Bowyer-Watsom Algorithm에선
1. 처음에 모든 점을 포함하는 큰 삼각형 Super Triangle을 생성한 후
2. 위와 같은 방식으로 Delaunay를 만족하는 삼각형을 추가해나간 뒤
3. 마지막에 Super Triangle과 연결된 모든 삼각형을 제거해준다.

## Voronoi Diagram
> Delaunay triangulation을 이용하여 Voronoi diagram으로 변환하는 알고리즘을 Sudo Code로 설명

```sudo
Delaunay Triangle의 각 삼각형 T에 대해:
	T의 외심을 계산한다.

self.point의 각 점 p에 대해:
	p를 포함하는 모든 삼각형의 외심을 수집한다.
	이 외심들을 CCW 방향으로 정렬한다. (반대도 상관없음)
	이 외심들은 점 p와 연결된 Voronoi Cell의 꼭짓점들이다. (Voronoi Cell 하나 생성)

return Voronoi Cells
```

/ *Voronoi Cell*
![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/Euclidean_Voronoi_diagram.svg/200px-Euclidean_Voronoi_diagram.svg.png)
각 Delaunay Triangle의 외심은 Voronoi Cell의 꼭짓점이 된다.
각 Voronoi Cell은 해당 점에서 다른 모든 점보다 가까운 영역을 나타낸다.

Delaunay Triangle에서 Voronoi Cell을 생성할 수 있듯이, Voronoi Cell을 통해서 Delaunay Triangle을 생성하는 것또한 가능하다.

------------------------------------------------------------------------

# Fibonacci Number

## Fibonacci Calculation with Matrix Exponention
> 행렬 곱셈과 비트 연산을 이용하여 시간 복잡도 $O(\log_2{n})$으로 Fibonacci를 구하는 알고리즘을 Pseudo Code로 작성하고 설명한다.

먼저 $n$번째 Fibonacci 수 $F_n$을 다음과 같이 행렬 곱셈으로 정의할 수 있다.
$$\begin{pmatrix}F_{n+1} & F_n\\F_n & F_{n-1}\end{pmatrix} = \begin{pmatrix}1&1\\1&0\end{pmatrix}^n$$
즉, $F_n$을 구하기 위해 행렬 $\begin{pmatrix}1&1\\1&0\end{pmatrix}$을 $n$번 곱해주면 된다.
`문제해결_11주차_Fibonacci.pdf`의 `22p.`를 참고하면 알 수 있듯이,
비트 연산의 방법으로 거듭제곱 형태의 계산 과정을 간소화 될 수 있다.

Pseudo Code는 다음과 같다.
```pseudo
def fibonacci(n):
	if n == 0:
		return 0      # F_0 = 0
	
	# 거듭제곱 할 Base 행렬 정의
	Base = [[1, 1],
		    [1, 0]]
	
	# 결과를 저장할 Result 행렬 정의
	Result = [[1, 0],
			  [0, 1]]  # Identity Matrix
	
	while n > 0:
		if n이 홀수 일 때:
			Result = Result * Base  # Result에 Base를 곱해준다.
		Base = Base * Base  # 항상 Base 행렬은 제곱하여 업데이트 해준다.
		n >> 1              # n / 2, n을 2로 나눠준다.
	
	return Result
```

예를 들어서 제곱의 진행을 보면 다음과 같다.
- `fibonacci(7)`:
	- n = 7 : $R = B$, $B^2$
	- n = 3 : $R = B^3$, $B^4$
	- n = 1 : $R = B^7$, $B^8$
- `fibonacci(10)`:
	- n = 10 : $R = R$, $B^2$
	- n = 5 : $R = B^2$, $B^4$
	- n = 2 : $R = B^2$, $B^8$
	- n = 1 : $R = B^{10}$, $B^{16}$
거듭제곰이 $\log_2{n}$ 만큼만 수행되는 것을 알 수 있다.

이렇게 시간복잡도를 $O(\log_2{n})$으로 줄일 수 있다.

-----------------------------

# DFS, BFS

## 암호화 사전
> 방향 그래프 생성 후 DFS를 이용한 위상 정렬

**(1) 방향 그래프 생성**

방향 그래프는 알파벳 간의 순서를 나타낸다.
한 방향으로만 이동할 수 있으며, 자료구조는 `adj[parent] { child }` 형태의 인접 리스트를 이용한다. 그래프의 요소는 다음과 같다.
- Vertex: 알파벳 `a - z`
- Edge: 알파벳 간 Dictionary Order 관계 `a -> b`

그래프 생성은 다음과 같이 한다.
1. 두 단어를 인접한 순서대로 비교하며 가장 처음으로 다른 두 문자를 찾는다.
2. 그 두 단어를 한 방향 간선으로 연결한다. `people, person 비교 후 o -> r 생성`

**(2) DFS를 이용한 위상 정렬**

출력을 위해 위에서 생성한 인접 리스트 `adj[alphabet]`을 DFS로 탐색하며 출력 문자열 스택에 추가한다.
자세한 과정은 다음과 같다.
1. 각 Vertex(알파벳)을 방문하며 아직 방문하지 않은 Vertex에서 DFS를 시작한다.
2. 방문한 Vertex(알파벳)은 출력 문자열 스텍에 추가한다.
3. 모든 정점을 방문한 후 스택에 쌓인 문자열을 역순으로 출력한다.

## 영단어 끝말잇기
> 방향 그래프 생성 후 오일러 서킷의 존재 확인

**(1) 방향 그래프 생성**

먼저 각 단어를 기준으로 생성할 그래프의 요소는 다음과 같다.
- Vertex: 알파벳 `a - z`
- Edge: 각 단어의 첫 번째와 마지막 알파벳 연결 `cat: c -> t`

위와 같은 기준으로 모든 단어를 순회하며 `adj[first] {last}` 형태의 인접 리스트를 생성한다.

**(2)** 오일러 서킷의 존재 확인

오일러 서킷의 존재 조건은 다음과 같다.
- 그래프의 모든 간선을 정확히 한 번씩 지나서 시작점으로 돌아오는 경로이다.
- 따라서 모든 Vertex에서 들어오는 Edge 수와 나가는 Edge 수가 같아야 한다. `방향 그래프의 경우`

DFS를 이용하여 탐색을 진행한다.
자세한 과정은 다음과 같다.
- DFS로 방향 그래프를 탐색하며 방문한 Edge을 기록한다.
- 오일러 서킷의 경우 나가는 Edge가 하나 이상 존재하는 아무 Vertex를 시작점으로 정하고 DFS를 수행하면 된다.

이렇게 탐색을 완료한 뒤 오일러 서킷이 모든 Edge를 포함하지 않는다면 (모든 단어를 사용하지 않았다면) 해당 단어의 조합으로 끝말잇기가 성립하지 않는 것이다.

-------------------------------------

# Two Pointers, Sliding Window

## Two Pointers - Pair Sum Closest to Target
> 오름차순으로 정렬된 배열 `arr`가 주어졌을 때, 합이 Target 숫자와 가장 가까운 배열의 쌍을 찾는 문제

예시는 다음과 같다.
```
input: arr[] = {1, 10, 15, 45, 57, 80}, Target = 61
output: {15, 45}  // 15 + 45 = 60
```

/ Naive Approach, $O(n^2)$
가장 Naive하게 접근하는 방법은 배열에서 **가능한 모든 쌍을 Target과 일일이 비교**하는 것이다.
$n$개의 요소에서 쌍은 $n\times (n-1)$개 만들어지므로 시간복잡도는 $O(n^2)$이다.

/ Two Pointer Approach, $O(n)$
배열의 왼쪽부터 시작하는 포인터 `left`와 오른쪽부터 시작하는 포인터 `right`를 정의한다.
`left` 포인터는 오른쪽으로 움직이고 `left++`
`right` 포인터는 왼쪽으로 움직인다. `right--`
위 **두 포인터에서 합을 비교**하여 Target에 가장 가까운 합을 가지는 쌍을 찾는다.

알고리즘은 다음과 같다.
```
while(left < right)
	arr[left] + arr[right] = curr_sum
	
	현재 검사할 쌍 (curr_sum)이 마지막으로 검사한 쌍보다 Target에 더 가까운지 검사한다.
	더 가깝다면 이를 결과로 반환할 쌍에 저장한다.
	
	curr_sum < target:
		쌍의 합을 늘려야 하므로 left를 오른쪽으로 이동시킨다, left++
	curr_sum > target:
		쌍의 합을 줄여야 하므로 right를 왼쪽으로 이동시킨다, right--
	curr_sum == target:
		합계가 target인 쌍을 찾았으므로 이를 반환하면 된다.
```

이렇게 하면 크기 $n$의 배열을 양쪽 끝에서 시작하여 중간에서 만날 때 까지만 탐색하면 되므로 $O(n)$의 시간 복잡도로 단축할 수 있게 된다.

## Sliding Window - Max Substring without Repeating
> 문자열 `str`가 주어졌을 때, 반복되는 문자가 없는 가장 긴 부분 문자열의 길이를 구하는 문제

예시는 다음과 같다.
```
input: "ABCBADBD"
output: 5 // ""
```

/ Naive Approach, $O(n^2)$
가장 Naive하게 접근하는 방법은 일일히 모든 경우의 수를 따져가며 문자열을 기록해놓고 새로 찾은 문자열을 그와 비교하는 방법이다.
대략적인 알고리즘은 다음과 같다.
- 문자열의 처음부터 시작하여 모든 경우의 수를 따지기 위해 시작 위치 `i`를 기록한다.
- `i`부터 시작하여 해당 문자열의 방문 여부를 기록하며 현재 최대 부분 문자열의 길이 갱신한다.
- 문자열이 방문 되었으면 갱신을 중지하고 다음 시작 위치 `i + 1`로 넘어간다.
이렇게 모든 경우의 수를 따져가며 최대 부분 문자열의 길이를 찾는 경우 $n^2$ 번의 루프를 돌아야하기 때문에 시간 복잡도 $O(n^2)$이 걸린다.

/ Sliding Window Approach, $O(n)$
처음에 하나의 문자로 초기화 되어있는 Window를 조건이 충족되는 범위 내에서 오른쪽으로 확장한 뒤 반복되는 문자가 발견되면 왼쪽부터 Window를 줄이는 방식으로 최대 길이 문자열을 추적한다.
창의 왼쪽을 나타내는 포인터는 `left`이며
창의 오른쪽을 나타내는 포인터는 `right`이다.

자세한 알고리즘은 다음과 같다.
```
문자열 길이가 0인 경우:
	return 0

문자열 길이가 1인 경우:
	return 1

left = 0 right = 0
while (right < 문자열의 길이)
	while (string[right] = visited (반복된 문자))
		string[left] = not visited
		left--
	
	string[right] = visited
	
	max_lenght = max (max_lenght, curr_lenght)
	right++

return max_lenght
```

이렇게 하면 각 문자가 `left` 및 `right` 포인터에 의해 정확히 한 번만 처리되므로 $O(n)$의 시간 복잡도로 단축할 수 있게 된다.

-------------------------

Final Coding Test 출제 주제
DP, Greedy, Sliding Window

-------------------------------

# Dynamic Programming

## 계단 오르기
> 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가장 최대의 점수를 얻으며 계단을 오를 수 있는 방법을 구하는 문제

위 문제의 계단을 오르는 조건은 다음과 같다.
1. 계단은 한 번에 한 계단 또는 두 계단씩 오를 수 있다.
2. 연속된 세 개의 계단을 밟을 수 없다.
3. 마지막 계단은 반드시 밟아야 한다.

/ Naive Approach, $O(2^n)$
브루트포스로 접근하는 방법이 있다.
모든 가능한 계단을 오르는 경우를 탐색하여 조건을 만족하는 경우 중 최댓값을 찾는 방법이다.
구현 방법은 다음과 같다.
- 재귀적으로 모든 경로를 탐색한다.
- 각 계단에서 선택할 수 있는 두 가지 경우(한 칸 오르기, 두 칸 오르기)를 시도하며 연속으로 3 계단을 오르지 않는지 확인한다.
- 탐색한 경로 중 최댓값을 지니는 경로를 택한다.
각 계단에서 두 가지 선택이 가능하므로 계단 개수가 $n$개 일때 가능한 경로의 수는 $2^n$에 가까워진다. 따라서 시간복잡도도 $O(2^n)$에 가까워진다.

/ DP Approach, $O(n)$
DP로 구현하는 방법은 다음과 같다.
- `dp[i]`: i번째 계단에 도달했을 때 얻을 수 있는 점수의 최댓값
- $dp[i] = max(dp[i - 2], dp[i - 3] + score[i - 1]) + score[i]$
	- $dp[i - 2]$: 두 계단 전에서 두 칸을 건너 뛰고 오는 경우
	- $dp[i - 3]$: 세 계단 전에서 한 칸을 건너 뛰고 오는 경우
- 초기 조건:
	- $dp[1] = score[1]$
	- $dp[2] = score[1] + score[2]$
DP를 사용하여 문제를 해결하면 계단을 한 번씩만 순회하면 되므로 시간복잡도는 $O(n)$이 된다.
따라서 브루트포스로 접근하는 것 보다 훨씬 효율적으로 문제를 해결할 수 있게 된다.

## 가장 긴 공통 증가 부분 수열
> 두 배열 a와 b가 주어졌을 때 가장 긴 공통 증가 부분 수열의 길이를 구하는 문제

예를 들어 `a = [3, 4, 9, 1], b = [5, 3, 8, 9, 10, 2, 1]` 일 때
가장 긴 공통 증가 부분 수열은 `[3, 9]`로 길이는 2이다.

/ Naive Approach, $O(2^{a+b})$
브루트포스로 접근하는 방법이 있다.
모든 a와 b의 가능한 공통 부분 수열을 탑색하고 그 중에서 가장 긴 증가 수열을 찾는 방식으로, 구현 방법은 다음과 같다.
- a와 b의 모든 부분 수열을 생성한다. ($2^a, 2^b$)
- 두 배열의 공통 부분 수열을 찾는다.
- 공통 부분 수열에서 가장 긴 증가 수열의 길이를 반환한다.
a와 b의 모든 부분 수열을 생성하는 부분에서 이미 시간복잡도는 $O(2^{a+b})$를 초과한다.

/ DP Approach, $O(a\cdot b)$
DP로 구현하는 방법은 다음과 같다.
- `dp[i]`: 배열 $b[0\cdots j]$에 대하여 $b[j]$를 마지막으로 하는 가장 긴 공통 증가 부분 수열의 길이
- $dp[i] = max(dp[i], dp[j] + 1), j < i \ \ and\ \ b[j] < b[i], b[i] == a[k]$
- 모든 $dp[i]$ 값 중 최댓값이 가장 긴 공통 증가 부분 수열의 길이이다.
a의 각 원소에 대해 b를 순회하므로 시간복잡도는 $O(a\cdot b)$가 된다.

이처럼 DP를 활용하면 반복 계산을 방지하여 효율적으로 결과를 구할 수 있다.