데이터베이스시스템

# 1. Introduction

[(데이터베이스시스템) Chapter 1: Introduction — 좌충우돌 기록기](https://ccho.tistory.com/6?category=1168493)

DBMS:
1. Collection of Interrelated Data
2. Set of Programs to Access the Data

특히 특정 조직과 관련된 정보들
-> 사용하기 편리하고 효율적인 환경 제공

**Purpose of Databas Systems**

DBMS 이전: Database Application이 FS에 직접적으로 작성
- Data Redundangy and Inconsistency(데이터 중복과 비일관성)
- Difficalty in Accessing Data(데이터 엑게스 시의 난점)
- Data Isolation(데이터 고립)
- Integrity Problems(무결성 문제)
- Atomicity of Updates(업데이트에 대한 원자성 문제)
- Concurrent Access by Multiple Users(동시 엑세스 문제)
- Security Problems(보안 문제)

**Data Model**

다음과 같은 것을 묘사하기 위한 tool
- Data: 무엇을 저장할 것인가
- Data Relationships: 데이터끼리 어떻게 연결되어 있는가
- Data Semantics: 데이터가 어떤 의미를 가지는가
- Data Constraints: 데이터에 어떤 규칙이 적용되는가

대표적인 데이터 모델의 종류
1. ☆ Relational Model(관계형 모델) `Table(Relatinon)`
2. ☆ Entiry-Relationship(E-R) Model `Entity, Attribute, Relationship`
3. Object-based Data Models `Object-oriented, Object-relational`
4. Semi-Structured Data Model `XML`
5. Older Models (이전 세대 모델) `Network Model, Hierarchical Model`

**☆ Relational Model**
![300](../z.%20Docs/img/Pasted%20image%2020250328155819.png)
모든 Data는 다양한 Table에 저장되어있다.
- Columns(가로): Attribute
- Rows(세로): Tuple

**View of Data(Abstraction)**
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F57nJf%2Fbtr3uD08eXY%2FaerdeHPBl010BJp8lJsUgk%2Fimg.png)
- Physical Level: 실제로 Data가 어떻게 저장되는지
- Logical Level: 무엇이 저장되어 있는지, 그리고 속성 간의 관계 설명 `<- Programmer!`
- View Level: 사용자들은 Data의 일부분에만 관심이 있음

**Instances and Schemas**

PL의 Types and Variables과 비슷하다.
- Schema: DB의 전체적인 설계 `int`
	- Logical Schema: SQL 코드들
	- Physical Schema: 디스크에 물리적으로 어떻게 저장되는가에 대한 정보
- Instance: DB에 실제로 저장된 데이터 값 `10`

Schema
```sql
CREATE TABLE Customer (
    Customer_ID CHAR(5),
    Name VARCHAR(50),
    Address VARCHAR(100)
);

CREATE TABLE Account (
    Account_ID CHAR(5),
    Balance INT
);

CREATE TABLE Deposits (
    Customer_ID CHAR(5),
    Account_ID CHAR(5),
    FOREIGN KEY (Customer_ID) REFERENCES Customer(Customer_ID),
    FOREIGN KEY (Account_ID) REFERENCES Account(Account_ID)
);
```

Instance
``` plaintext
Customer 테이블
+-------------+--------+-------------------+
| Customer_ID | Name   | Address           |
+-------------+--------+-------------------+
| C001        | Alice  | Seoul             |
| C002        | Bob    | Busan             |
+-------------+--------+-------------------+
```

**Physical Data Independence**
Physical Schema는 바꿔도 Logical Schema는 바꿀 필요가 없다. 둘이 독립적이다.

**Database Language(DDL)**
- Database의 Schema를 정의하는 언어
- DDL의 결과는 `data dictionary`에 Meta data로써 저장된다. 다음과 같은 정보들을 포함한다.
	- Database Schema
	- Integrity Constraints `Primary Key, Foreign Key`
	- Authorization

**Database Manipulatoin Language (DML)**
- 사용자가 적절한 Data Model로 구성된 Data를 접근/조작할 수 있도록 하는 언어
- Query Language라고도 한다.
- DML의 종류는 기본적으로 두 가지 정도가 있다.
	- Procedural DML(절차식 DML): Data를 어떻게 구할지도 요구
	- Declarative DML(비절차식 DML) `이게 더 쉬움`

**SQL Query Language**
```sql
-- Comp. Sci에 있는 모든 Instructors 찾기
SELECT name
FROM instructor
WHERE dept_name = 'Comp. Sci.'
```
- Declarative DML, 즉 조건만 제시하고 세부적인 사항은 작성하지 않아도 된다.
- 한 개 이상의 Table --`SQL`-> 한 개의 Table
- Turing Machine equivalent Language(범용 튜링 머신)이 아니다. 즉 범용성이 떨어진다.
- 그래서 보통 복잡한 계산을 하기 위해 다른 PL `c, c++, java`에 내장된 형태로 작성된다.
- 보통의 Application들은 다음과 같이 DB에 접근한다.
	- SQL이 내장된 언어
	- ODBC/JDBC와 같은 응용 프로그램 Interface

**Database Design**

Logical Design: DB Schema 결정
- Business Decision: DB에 뭘 저장해야 하는가?
- CS Decision: 서로 연관된 Attribute가 Tabl에 들어가 있는가? 최대한 중복이 방지되어 있는가?
Physical Desing: DB의 Physical Layout

**Database Engine**

```plaintext
Database System {
	1. Storage Magager (저장 장치 관리자),
	2. Query Processor (질의 처리기),
	3. Transaction Management (트랜젝션 관리자)
}
```

**(1) Storage Manager (저장 장치 관리자)**

Low-level Data와 Application/Query 사이의 Interface 제공:
- OS 파일 관리자와 상호작용하며 Disk에 원시 Data 저장
- Data의 효율적인 저장, 검색, 갱신

구성요소:
- Authorization and integrity manager: 무결성 제약 조건 검사 `은행 잔고는 0 이상`
- Transaction manager: 고장시 일관성 유지 검사, 동시성 트렌젝션 시 문제 검사
- File manager: 자료구조 관리
- Buffer manager: Disk -> Main Memory -> Cache로 보낼 Data 결정

구조:
- Data Files: DB 자체를 저장
- Data Dictionary: Metadata, 특히 DB Schema 저장
- Indices: 특정 값을 가지고 있는 Data 항목에 빠르게 접근하기 위한 것, 주로 많이 검색하는 속성에 대해서 Indexing을 한다.

**(2) Query Processor (질의 처리기)**

구성요소:
- DDL Interpreter: DDL문 해독 후 `data dictionary` 내에 기록
- DML Compiler: DML문을 Engine이 이해할 수 있는 Low-level 명령어로 변환 `Query 최적화`
- Query Evaluation Engine: DML Compiler에 의해 생성된 Low-level 명령어 실행

Query Processing
![400](https://blog.kakaocdn.net/dn/WG7En/btr8hy3hsHy/5f1hvviiDCgY1PTbGOUo71/img.png)

**(3) Transaction Management (트랜젝션 관리자)**

Transaction: DB Applicaton에서 하나의 논리적 기능을 수행하는 연산들의 모임
- 원자성(Atomic)
- 일관성(Consistency):
	- 동시 접근시 일관성 유지 `Transaction-management Component`
	- system/transaction fail을 시키는 한이 있더라도 일관성 유지 `Concurrency-control Manager`

**Database Architecture**

Centralized DBs: 공유 메모리
Client-Server: Server가 실제 작업, Client는 원격으로 접속하여 작업
Parallel DBs: 모든 CPU가 메모리 공유 / Disk만 공유 / 공유 X
Distributed DBs: Geographical distribution, Schema/data heterogeneity

![300](https://blog.kakaocdn.net/dn/1AfHa/btqIasBcpS2/VMh2kxnsvUliPsSeqHugwK/img.png)

**Database Appilcations**

DB Application들은 보통 두 부분이나 세 부분으로 나뉜다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FvtkSQ%2Fbtr3ftZDGDv%2FK7BgQ7uJYpLDN4qgjJNqvK%2Fimg.png)
- 2계층 구조: Application이 Client 상에 존재하며, 그게 DB System과 통신한다.
- 3계층 구조: Client는 DB 호출을 직접적으로 하지 않고, Server간 통신은 Form Interface를 통해 이루어진다. 그리고 Application Server가 DB System과 통신한다.

다양한 User에 따른 전제 지도를 나타내면 다음과 같다.
![300](https://velog.velcdn.com/images/ashwon1218/post/dc5de678-2fec-4a1f-a05b-b3d7b55427aa/image.png)

**Database Administrator (DBA)**

Central Control을 하는 관리자를 의미한다. 다음과 같은 기능들을 수행한다.
- Schema 정의
- 저장 구조와 Access 방법 정의
- Schea 및 Physical 구조 수정
- Data 접근 권한 수락
- 루틴 유지
- DB의 주기적 백업
- 충분한 Disk 공간 보장 및 업그레이드
- DB 작업 모니터링

# 2. Intro to Relational Model

[(데이터베이스시스템) Chapter 2: Introduction to Relational Model — 좌충우돌 기록기](https://ccho.tistory.com/8)

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbGkfk0%2Fbtr5N4w9kXE%2FvgijhVWmypgxI6wdJMK7g0%2Fimg.png)

**Relation Schema and Instance**

Attribute(속성) $A_1, A_2, \cdots, A_n$

Relation Schema $R = (A_1, A_2, \cdots, A_n)$
- Table 모양 정의
- `e.g. instructor = (ID, name, dept_name, salary)`

Relation Instance $r(R)$
- Table 안에 있는 행(Row)들

Tuple $t$
- Relation Instance에서 각 행(Row)를 의미한다. 순서는 무의미하다.
- `e.g. (ID, name, dept_name, salary) = (101, 'Alice', 'CS', 90000)`

| 개념       | 비유           | 의미                |
| -------- | ------------ | ----------------- |
| Schema   | 시험지 양식       | 어떤 문제(속성)가 있는지 정의 |
| Instance | 학생이 푼 실제 답안지 | 현데 Data의 상태       |
| Tuple    | 시험지 한 장      | 한 명의 학생 데이터       |

Domain
- 각 Attribute가 가질 수 있는 값의 집합
- `e.g. Age는 int [0-150]`

Atomic
- 하나의 Attribute는 한 값만 가져야 한다. `e.g. CS O / CS, Math X`

Null
- Unknown, 모든 Attribute의 값으로 올 수 있으나 최대한 Null 값이 없도록 해야한다.

**Database Schema**

Database Schema: DB의 논리적 설계 `instructor(ID, name, dept_name, salary)`
Database Instance: 어떤 한 순간의 Data 스냅샷 `실제 Table Data 값`

*-> Instance의 Tuple는 시간에 따라 변할 수 있지만, Schema는 변하지 않는다.*

**★ Keys**

$K \subseteq R$
Key는 Attributes의 부분 집합이며, 어떠한 것을 식별한다는 의미가 있다.
$K$, Superkey는 Tuple을 Unique하게 식별할 수 있는 Key를 말한다.

(1) Candidate Key (후보 키):
Tuple을 유일하게 식별할 수 있는 최소한의 Attribute 집합

(2) Primary Key (기본 키):
Candidate Key 중 대표로 선택된 하나의 Key
- 각 Table에는 오직 하나의 Primary Key 존재
- Primary Key는 NULL이 될 수 없고, 중복도 안 된다.

(3) **Foreign Key (외래 키)**:
다른 Table의 Primary Key를 참조하는 속성으로 , 두 Table 사이의 Relationship을 표현하는 데 사용된다.
Constraints:
- 참조하는 Relation과 참조되는 Relation의 Domain이 동일해야 하며, 둘 다 동일한 값으로 존재해야 한다.
- Foreign Key에 저장되는 값은 반드시 참조하는 Table의 Primary Key 중 하나여야 한다.

*Referential Integrity Constraint(참조 무결성 제약)*
- 참조하는 Relation의 속성 값은 반드시 참조되는 Relation의 Primary Key에 존재해야 한다.
- 즉, 참조하는 Table의 특정 열 값이 반드시 참조 대상 Table의 Primary Key 값 중 하나여야 한다.

e.g.
Table1: `time_slot`
```plaintext
time_slot_id | start_time | end_time
-------------|------------|---------
TS1          | 09:00      | 10:30
TS2          | 10:45      | 12:15
```

Table2: `section`
```
course_id | sec_id | semester | year | time_slot_id (FK)
----------|--------|----------|------|------------------
CS101     | 1      | Fall     | 2024 | TS1
CS102     | 1      | Spring   | 2024 | TS3 ❌
```

- `section.time_slot_id`는 `time_slot.time_slot_id`를 참조하는 FK이다.
- `section.time_slot_id` 값은 반드시 time_slot 테이블에 존재해야 한다.
- 따라서 `TS1`은 OK, 하지만 `TS3`은 time_slot 테이블에 없으므로 참조 무결성 위반이다. ❌

e.g.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcUAVRi%2Fbtr9nmmIM8M%2FE9SkFxZkUbPdlUOTcRGCkK%2Fimg.png)

- `section.time_slot_id ->> time_slot.time_slot_id`: Referential Integrity Constraint을 나타내고 있다.
- Primary Key는 밑줄이 쳐져 있다.
- `s_id`는 PK이면서도 FK인 예시이다.
- `teaches` Table에서 4개의 Attribute가 모였을 때만 FK의 역할을 수행한다.

**Relational Query Languages**

`Chapter 1.의 Database Manipulatoin Language(DML) 참고`

3개의 Query Language가 있다.
Query Language란 사용자가 DB로부터 정보를 요청할 때 사용하는 언어이다.
1. *Relational Algebra*: SQL 쿼리어의 이론적인 기반을 제공한다.
2. Tuple Relational Calculus
3. Domain Relational Calculus

**Relational Algebra**

Procedural Language이며, 하나 혹은 두개의 Relation을 입력 받아 새 Relation을 반환한다.
- "무엇을 얻는가" 뿐만 아니라 "어떻게 얻는가"까지 명시한다.

| 연산                                | 기호                  | 설명                                             |
| --------------------------------- | ------------------- | ---------------------------------------------- |
| **Selection (σ, 시그마)**            | `σ condition (R)`   | 특정 조건을 만족하는 행(Tuple) 선택                        |
| **Projection (π, 파이)**            | `π column_list (R)` | 특정 열(Attribute)만 선택                            |
| **Union (∪, 유니온)**                | `R ∪ S`             | 두 Relation의 합집합 (중복 제거)                        |
| **Set Difference (-, 차집합)**       | `R - S`             | 첫 번째 Relation는 있지만 두 번째 Relation에는 없는 Tuple 반환 |
| **Cartesian Product (×, 데카르트 곱)** | `R × S`             | 두 Relation의 모든 조합 반환                           |
| **Rename (ρ, 로)**                 | `ρ new_name (R)`    | Relation 또는 Attribute의 이름 변경                   

**Select Operation $\sigma$**

e.g. `instructor` Relation에서 "Physics" 과목에 있는 `instructor`들의 Tuple들을 찾아라.

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3fmpO%2Fbtr9nJIRoYP%2F1cSWnfcIewDqGE4c4F2jW1%2Fimg.png)
- Selection Predicate: `dept_name = "Physics"`

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb0lA34%2Fbtr9nJ28REA%2FSKFo7n2KH3kQh9fy9wkK00%2Fimg.png)
- 여러 비교 연산자를 사용할 수 있으며, Attribute들 끼리도 비교할 수 있다. $=, \neq, >, \geq, <, \leq$
- Selection Predicate이 여러 개일 경우 and, or, not 기호를 사용할 수 있다. $\wedge, \vee ,\neq$

**Project Operation $\Pi$**

e.g. `intstuctor`속성에서 `dept_name`을 제거하여라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcC2m93%2Fbtr9dXBCQKK%2FIbuGqQxTxsXcaSup0vUg9K%2Fimg.png)

**Cartesian Product Operation $\bigtimes$**

e.g. `instructor` Relation과 `teaches` Relation의 모든 가능한 조합의 Relation을 만들어라.

$\text{instructor} \times \text{teaches}$
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkOGuk%2Fbtr9pcSaIAp%2FyFvDkX5YLIKiYLcrLBhvJ0%2Fimg.png)
- 두 Relation을 합하여 하나의 Relation을 만든다.
- 그냥 모든 경우의 수를 나타내는 Table 하나를 만드는 거라고 생각하면 된다.
- `instructor.ID, teaches.ID`: 같은 이름의 Attribute가 있는 경우 Relation 이름을 옆에 붙여 구분한다.

**Join Operation $\bowtie$**

e.g. 어떠한 instructor와 그 instructor가 가르친 course가 있는 Tuple을 추출하여라.

$\text{instructor} \bowtie_{\text{ instructor.id = teaches.id}}\text{teaches}\equiv \sigma_{\text{instructor.id = teaches.id}}(\text{instructor} \times \text{teaches})$
![450](../z.%20Docs/img/Pasted%20image%2020250330003742.png)
- $\text{instructor} \times \text{teaches}$에서 특정 과목을 가르치지 않는 강사의 정보 또한 포함하고 있는데, Join Operation을 통해 이를 없애준다.
- 위를 통해 알 수 있듯이, Join Operation은 Cartesian Product와 Select의 조합이다. 즉
$$r\bowtie_\theta s = \sigma_\theta(r\times s)$$
- Join Operation은 두 Relation의 Attribute가 동일한 Domain이어야 한다. `Cartesian Product는 꼭 동일할 필요는 없다.`

**Union Operation (합집합) $\cup$**

e.g. Fall 2017 또는 Spring 2018에 가르친 course들을 모두 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbaN2vv%2Fbtr9pckEvhD%2FLTlOzhDis1Vr2H1RPIATY1%2Fimg.png)
- 두 Relation이 서로 같은 Attribute 순서로 이루어져 있어야 한다.
- 해당 연산을 수행하면 중복되는 값을 제외하고 합친 결과를 얻을 수 있다.

**Set-Intersection Operation (교집합) $\cap$**

e.g. Fall 2017 과 Spring 2018에 가르친 course들을 모두 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzaAu7%2Fbtr9nHZCGB1%2F64kmD779FuQxXnvUQCe9J1%2Fimg.png)
- Attribute 개수 및 Domain이 동일해야 한다.

**Set Difference Operation (차집합) $-$**

e.g. Fall 2017 에는 가르쳤지만, Spring 2018에는 가르치지 않은 course들을 모두 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdpekyj%2Fbtr9nat8WkE%2FpF5kWHi0EZ1WYt6UOXvmS0%2Fimg.png)
- 동일하게 Attribute 개수 및 Domain이 동일해야 한다.

**Assignment Operation $\leftarrow$**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcotT2t%2Fbtr9As7iJe9%2FLbcjk9bEkI2GQf7sW9bQp0%2Fimg.png)
- Temporary Relation 변수를 임시 변수에 할당하는 것을 의미한다.
- 이를 통해 Sequential Program처럼 동작하도록 할 수 있다.

**Rename Operation $\rho$**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpghzL%2Fbtr9pcE7arf%2FKXpGlKXXh8TLZsDKBSYbnk%2Fimg.png)
- Relation이나 Attribute에 새로운 이름을 지정할 수 있도록 해준다.
- $\rho_{\text{새로운 이름}}(\text{Relation})$
- 복잡한 질의를 작성할 때 중간 결과에 별명을 붙이거나, Attribute 이름이 겹치는 문제를 피할 때 사용한다.

**Equivalent Queries**

e.g. 90,000달러 이상의 연봉을 받는 Physics instructor가 가르치는 courses에 대한 정보를 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGteyE%2Fbtr9m9WqyIJ%2Fj0dFp41zJA2B4XZWdckQRk%2Fimg.png)
- Query를 쓰는 방식은 하나 이상인 경우가 많다.
- Query가 동일하지 않아도 같은 결과를 주면 Equivalent하다고 한다.

---

### 📘 관계 대수 연산 요약표

|연산 기호|연산 이름|설명|예시|조건|
|---|---|---|---|---|
|`σ`|**Select (선택)**|조건을 만족하는 튜플(행)만 선택|`σ_{dept_name = 'Physics'}(instructor)`|없음|
|`π`|**Project (투영)**|특정 속성(열)만 추출|`π_{name, salary}(instructor)`|없음 (중복 제거 자동 포함)|
|`×`|**Cartesian Product (카티션 곱)**|두 릴레이션의 모든 가능한 조합|`instructor × teaches`|도메인 일치 필요 없음|
|`⋈`|**Join (조인)**|공통 속성 값이 같은 튜플끼리 결합|`instructor ⋈_{instructor.ID = teaches.ID} teaches`|조인 조건 속성의 도메인 동일|
|`∪`|**Union (합집합)**|두 릴레이션의 모든 튜플을 중복 없이 합침|`Fall2017 ∪ Spring2018`|속성 수와 도메인 동일|
|`∩`|**Intersection (교집합)**|두 릴레이션에 모두 존재하는 튜플만 반환|`Fall2017 ∩ Spring2018`|속성 수와 도메인 동일|
|`−`|**Set Difference (차집합)**|첫 릴레이션에만 존재하는 튜플 반환|`Fall2017 − Spring2018`|속성 수와 도메인 동일|
|`←`|**Assignment (할당)**|연산 결과를 임시 릴레이션에 저장|`temp ← σ_{...}(...)`|연산 결과를 재사용할 때 사용|
|`ρ`|**Rename (이름 변경)**|릴레이션/속성 이름 변경|`ρ_{prof}(instructor)``ρ_{prof(ID_num, full_name)}(instructor)`|복잡한 쿼리 정리, 중복 이름 회피 등|


💡 보충 요약
- `σ`와 `π`는 **단일 릴레이션을 입력으로 사용**
- `×`, `⋈`, `∪`, `∩`, `−`는 **두 릴레이션이 필요**
- `←`과 `ρ`는 **중간 결과를 재사용하거나 가독성을 위해 사용**

---

# 6. Database Design Using the E-R Model

[(데이터베이스시스템) Chapter 6: Database Design Using the E-RModel — 좌충우돌 기록기](https://ccho.tistory.com/9)

**Design Phase**
```
요구사항 분석 -> 개념적 모델링 -> 논리/물리적 설계
```
1. 사용자의 데이터 요구사항 분석
2. 데이터 모델 선택 `Relational Model, E-R Model`, Conceptual Schema 설계
3. Logical Design, Relation Schema 즉 어떤 Table과 Attribute를 가질지 설계 / Physical Design

**Design Alternatives**

DB Schema를 설계할 때, 다음과 같은 두 가지 오류를 피해야 한다.
1. Redundancy(중복성): Data를 업데이트 할 때 Data Inconsistenc를 초래할 수 있다.
2. Incompleteness(불완전성)

**Desing Approaches**

**(1) Entity-Relationship Medel(ER Model)
> 실세계의 정보를 *Entity*와 *Relationship*으로 추상화하여 모델링
- Entity: 현실 세계에서 구분 가능한 대상, Attribute를 통해 Entity 설명
	- e.g. 학생, 교수, 과목
- Relationship: Entity 간의 연관성
	- e.g. 학생이 수강한다, 교수가 강의한다.
- ER Diagram을 통해 시각적으로 표현 가능하다.

(2) Normalization Theory (정규화 이론) `Chapter 7에서 배울 예정`
> 나쁜 설계를 공식적으로 판별하고, 이상(Anomalies)를 제거학기 위한 형식적 절차

## 6-1. Outline of the ER Model

**ER model -- Database Modeling**

ER Model의 DB의 전체 논리 구조를 나타내는 Enterprise Schema를 지정할 수 있도록 하여 DB 설계를 용이하게 하기 위해 개발되었다.

ER Model 3 Basic Concepts
- Entity Sets
- Relationship Sets
- Attributes
그리고 이 모델을 Diagram으로 표현하면 DB의 전반적인 논리적 구조를 나타낼 수 있으며, 이를 ER Diagram이라고 한다.

**Entity Sets**

Entity
> 현실 세계에서 구분 가능한 대상, Attribute를 통해 Entity 설명
```
instructor = (ID, name, salary)
course = (course_id, title, credits)
```

Entity Set
> 같은 종류의 Entity들로 이루어진 집합이다.
- e.g. `Students: 모든 학생들의 집합`

**Representing Entity Sets in ER Diagram**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdsLK51%2Fbtsak9fyQTu%2FALpGUQzL7cg3X6PQMQXB71%2Fimg.png)
- PK: 밑줄 쳐진 Attributes

**Relationship Sets**

Relationship
> 여러 Entity 간의 관계를 나타낸다.
```
44553 (Peltier) -- advisor -- 22222 (Einstein)
```

Relationship Sets
> 같은 종류의 Relationship들을 모아놓은 집합
> $n \ge 2$개의 Entity들 간의 조합들로 구성된 수학적 집합 `수학적 정의`
```
(44553, 22222) ∈ advisor
```

**Relationship Sets with Attributes & ER Diagrams**

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcVUkIF%2FbtsaiqiilbU%2Fb6BgRB0r9mKlryx6tDPTbK%2Fimg.png) ![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcof9yT%2Fbtsak2VeZpp%2FLaztwRAnRkfTNhG8T4YQa1%2Fimg.png)
- Relationship에도 관련된 Attribute가 있을 수도 있다.
- 위 그림에서 Advisor의 `data`라는 Attribute를 통해 `student`가 `advisor`과 연관되기 시작한 시점을 알 수 있다.

**Roles**

Roles
> 동일한 Entity Set이 한 Relationhip에 두 번 이상 참여할 때,
> 각 참여가 어떤 Role을 하는지를 명확하게 하기 위해 붙이는 이름이다.
```
[Course] ───◇ prereq ◇─── [Course]
    ▲                          ▲
 course_id              prereq_id -- Roles
```
- 왜 Role이 필요할까? 그것은 하나의 Entity Set이 Relationship에 두 번 이상 등장하면 누가 누구를 참조하는지 모호해지기 때문이다.

**Degree of a Relatioship Set**

Degree는 해당 Relationship Set에 참여하는 Entity Set의 개수를 의미한다.

(1) Binary Relationship: 포함된 Entity set이 두 개 `Degree two`
- 거의 모든 Relationship Set들은 Binary이다.

(2) Non-Binary Relationship
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fu3Qni%2FbtsaqQmq07x%2FraxMxoNOzodc0pvLC4odm1%2Fimg.png)
- 위 그림은 Degree가 3인 Relationship의 ER Diagram 예시이다.
- e.g. `student`들이 `instructor`의 지도 아래 `project`에 참여한다.

**Complex Attributes**

Attribute Type에는 다양한 유형이 있다:
- Simple Attribute: 더 이항 분해가 안 되는 속성 `name`
- Composite Attribute: 또 다른 Component Attribute로 분해할 수 있는 속성 `Address -> City, Ave, ..`

또한 Attribute 값의 개수에 따라 다음과 같이 나뉜다:
- Single Value: 하나의 값만 가진다. `birth_date, student_id`
- Multi Value: 하나 이상의 값을 가질 수 있다. `phone_numbers`

그리고 Derived Attribute가 있는데 이는 다른 속성으로부터 유도된 속성이다.
- e.g. `age`: `date_of_birth`가 있다면 계산할 수 있다.

Domain은 각 속성이 가질 수 있는 허용 값들의 집합니다.
- e.g. `grade`: Domain = {A, B, C, D, F}
- e.g. `salary`: Domain = 양이 실수

**Representing Complex Attributes in ER Diagram**

![150](../../z.%20Docs/img/Pasted%20image%2020250402213637.png)
- `name`: Composite Attribute
- `address`: Composite Attribute with Nested Composites
- `{phone_number}`: Multivalued Attribute
- `date_of_birth`: `age`의 기반
- `age()`: Derived Attribute, `()`는 계산 시점에 생성되는 속성이라는 뜻으로, DB에 실제로 저장되지는 않는다.

**Mapping Cardinality Constraints**

Mapping Cardinality
- Relationship Set을 통해 Mapping되는 개별 Entity들의 개수를 의미한다.
- Binary Relationship set에서 가장 유용하다.

Mapping Cardinality는 다음 4가지의 유형으로 나뉜다.
1. One to one
2. One to many
3. Many to one
4. Many to many

Diagram으로 들어가기 전, A와 B에 몇몇 Element들은 다른 Set의 Element와 mapping이 없을 수도 있다는 걸 알아두자.

(1) One to one `Relation이 없는 경우도 One to one에 해당한다.`
![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAvKVc%2FbtsakhEXtKq%2FRqjbfcuIheoQEKxEFqHPg0%2Fimg.png)

(2) One to many
![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdUv2EQ%2Fbtsai4lBHv7%2F7lslDJ5PMUb6AVPobaiAKK%2Fimg.png)

(3) Many to one
![200](../../z.%20Docs/img/Pasted%20image%2020250402214436.png)

(4) Many to many
![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc7YbjR%2Fbtsak4evESb%2FFi0e6g5FGRTKg0amRxzl8K%2Fimg.png)

**Representing Candinality Construaints in ER Diagram**

$\rightarrow$: One, Relation의 한쪽 끝이 최대 1개의 Entity와만 연결된다.
$\textemdash$: Many, 관계의 한쪽 끝이 여러 개의 Entity들과 연결될 수 있다.

(1) One to one
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZTBAd%2Fbtsal5xtRaJ%2F2OMEG723onUcwnNHIMXS3k%2Fimg.png)
- 각 학생은 최대 하나의 교수를 지도교수로 가질 수 있다는 의미이다.

(2) One to many
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd23kxC%2Fbtsal5xtSDU%2FzRInEuXQhpbOpMpaJJgZpk%2Fimg.png)
- 각 교수는 여러 명의 학생을 지도할 수 있다는 의미이다. 그러나 학생은 한 명의 교수만 지도교수로 가질 수 있다.

(3) Many to one
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcIcIqQ%2Fbtsak4lg7Lr%2F1lRWH9QBW9pBFgb78q4mwk%2Fimg.png)
- One to many와 반대라 생각하면된다.

(4) Many to many
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdjx5Tx%2FbtsamXMJu0S%2FLTz3SyGkg45fzxR9baZG6K%2Fimg.png)
- 교수나 학생이나 여러명의 지도학생 혹은 지도교수를 가질 수 있다는 의미이다.

**Total and Partial Participation**

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBDYvi%2Fbtsal5EfJoU%2FkTCmzHQUyuGqub6BLmcptK%2Fimg.png)
- Total Participation `=`: 모든 학생이 지도교수를 가지고 있다.
- Partial Participation`-`: 모든 교수가 지도할 학생을 가지고 있는 건 아니다.

**Notation for Expressing More Complex Constraints**

더 많은 관계를 보이고 싶을 때, 다음과 같이 Cardimality(관계와 대응되는 Entity의 수)의 max와 min을 표시할 수 있다.
밑의 그림은 `instructor`는 0또는 그 이상의 지도할 학생을 가질 수 있고, `student`는 반드시 한 명의 지도교수를 가지고 있어야 한다는 의미이다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcA4gNO%2FbtsatWGIKKA%2FlLeGQwJ8NXK6uykEoDGNeK%2Fimg.png)
- `0..*`: 0개 이상 관계에 참여 (선택적 참여 + 여러 번 가능)
- `1..*`: 최소 1번 이상 참여 (완전 참여 + 여러 번 가능)
- `0..1`: 최대 한 번만 관계에 참여 (선택적 참여 + 단일)
- `1..1`: 반드시 하나의 관계에 참여 (완전 참여 + 단일)

**Cardinality Constraints on Ternary Relationship**

그렇다면 Ternary(3) Relationship에서의 Cardinality는 어떻게 표현할까?
*그럴 때는 최대 하나의 화살표만 표시할 수 있도록 하고 있다.*
그 이유는 다음과 같이 여러가지 해석이 가능할 수도 있기 때문이다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkQfIw%2FbtqQfLsTzSo%2FHHJ1cDcixTycyIeBBz5xJk%2Fimg.png)
- A와 B가 1:1 Mapping 되고, 그것과 C가 Many의 관계를 가지는 경우
- A혹은 B가 C와 1:N 관계로 Mapping 되고, 나머지 하나가 1:1로 다시 Mapping 되는 경우

**Primary Key**

PK는 주어진 Set 내에서 특정 Entity/Relationship을 구분할 수 있도록 해준다.
우리는 다음과 같은 집합 내의 PK에 대해 다룰 것이다:
- Entity Sets
- Relationship Sets
- Weak Entity Sets

**PK for Entity Sets**

`ch2.`에서 이미 자세히 다뤘다.

**PK for Relationship Sets**

Entity를 구분시켜주는 PK는 배웠는데, 그럼 Relationship은 어떻게 구분할까?
$E_1, \cdots E_n$의 Entity Set과 관계를 맺는 Relationship Set $R$ 이 있다고 가정해보자.
-> $R$ 을 식별하기 위해서는 *Entity의 PK의 합집합을* Superkey로 가져온다.

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZTBAd%2Fbtsal5xtRaJ%2F2OMEG723onUcwnNHIMXS3k%2Fimg.png)
- Relationship Set `advisor`의 PK는 `{instructor.ID, strudent.ID}`이다.

PK를 가지면서도 다음 그림과 같이 `advisor`의 추가 속성이 있을 수 있다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcof9yT%2Fbtsak2VeZpp%2FLaztwRAnRkfTNhG8T4YQa1%2Fimg.png)

**Choice of Primary Key for Binary Relationship**

Binary(2) Relation의 경우 집합이 결정된 다음 Relation의 PK를 구하기 위해서는 해당 관계의 *Cardinality*를 고려해야 한다.
핵심 원칙은 관계에 참여하는 *Entity들의 PK 중 어느 쪽, 또는 둘 다를 조합해 관계를 고유하게 식별할 수 있느냐*를 기준으로 결정한다.
- One to One: 두 쪽 다 최대 한 개의 관계만 가질 수 있으므로 -> *양쪽 중 아무 쪽의 PK*
- One to Many: Many 쪽 만으로도 각 Relation을 고유하게 식별 가능 -> *Many 쪽의 PK*
- Many to One: One to Many와 동일하다 -> *Many 쪽의 PK*
- Many to Many: 두 Entity의 PK를 모두 조합한 것이 최소 Superkey다. -> *두 쪽 PK 조합*

**PK for Weak Entity Sets**

Weak Entity Set이란 자체적으로는 PK가 없는 Entity Set으로, 다른 Identifying Entity의 존재에 의존해서만 식별될 수 있는 Entity이다.

강한 예가 바로 아래 그림의 `section`이다.
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcJRNsh%2FbtsaESjqQxN%2FCMNOY54WeAnKPlqTyPYDE1%2Fimg.png)
- `section`은 `course_id`가 있어야만 고유하게 식별이 가능한데, 이는 `course` Entity의 기본 키로, 즉 `section`은 `course`에 의존적이다.
- 따라서 둘의 관계를 나타내기 위해 Relationship Set `sec_course`를 만들었다고 치자. 하지만 그 정보는 이미 `section`의 `course_id`가 있기 때문에 중복이 된다.
- 그렇다고 `sec_course`를 제거해버리면 두 관계가 명확히 표현되지 않는다.

이를 위해 다음과 같은 해결책을 제시한다.
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbJXhIy%2FbtsaiqvZ1wP%2FKHVq2GVCtyvrzznDSnXqj0%2Fimg.png)
- `section`을 Weak Entity Set으로 보고,
- `course`를 Identifying Entity Set,
- `sec_course`를 Identifying Relationship으로 설정하는 것이다.
- 점선으로 표시한 `sec_id, semester, year`는 `Weak Entity` 식별을 위해 추가로 필요한 속성들로, Discriminator라고 한다.

`section`에서 `course_id`를 제거하는 대신 `sec_course`라는 관계를 두어 `course`에 의존적인 상황임을 보인다.
- 여기서 Weak Entity Set이 아닌 Set을 Strong Entity Set이라고 한다.
- Weak Entity와 Identifying Entity의 관계를 Identifying Relationship이라고 한다.
- 둘의 관계를 생각해보면 왜 `=`으로 `section`을 Total Participation이라 표시했는지 알 것이다.
-> 결과적으로 `section`의 PK는 여전히 `(course_id, sec_id, semester, year)`이다.

**Redundant Attributes**

하지만 실제로 Relation Schema로 변환할 때는 `course_id`를 `section`에 포함시킨다.
```sql
section(
	course_id,
	sec_id,
	semester,
	year, 
	PRIMARY KEY(course_id, sec_id, semester, year),
	FOREIGN KEY(course_id)
	REFERENCES course
)
```

**E-R Diagram for a University Enterprise**

![600](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcs0iFF%2FbtsalayT5J0%2FJdmLeACfBq9KGMcOnLksqk%2Fimg.png)
- □: 무조건 Table로 표현해야한다.
- ◇:
	- Table로 변환되는 ◇가 있고 `Many to Many`
	- Table로 변환되지 않고 빠지는 ◇가 있다.

| 기호  | 의미           | Table 변환 | 조건                            |
| --- | ------------ | -------- | ----------------------------- |
| `□` | Entity       | ○        | 항상                            |
| `◇` | Relationship | △        | M:N이면 O, 1:N/1:1이면 X (FK로 처리) |

## 6-2. Reduction to Relation Schemas

**Reduction to Relation Schemas**

```
ER Diagram -> Schemas Diagram
```

DB 설계를 완료하기 위해서는 ER Modeling을 관계형 DB로 변환할 수 있어야 한다.
- Entity와 Relatioship은 각각 하나의 Table로 표시하고,
- Attribute는 Table Column으로 표현될 수 잇다.

**Representing Entity Sets**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbJXhIy%2FbtsaiqvZ1wP%2FKHVq2GVCtyvrzznDSnXqj0%2Fimg.png)
- Strong Entity Set은 Table 그대로 만들면 된다.
- Weak Entity Set은 Strong Entity Set의 PK를 포함시켜야 한다.
- e.g. `section (course_id, sec_id, semester, year)`

**Representation of Entity Sets with Composite Attributes**

Schema로 변환하는 과정에서, `Representing Complex Attributes in ER Diagram 참고`
기존 Entity Attribute가 다음과 같은 Type인지 구분할 필요가 있다:
- Single/Multi
- Simple/Composite

![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fqdon2%2FbtsbPnjMgP4%2FVNmGTRUpKMKKuUePNF8ma0%2Fimg.png)

Schema로 변환 시 다음과 같은 절차를 따른다:
1. Composite Attribute의 경우: *Flatten*시킨다.
	- e.g. `name`의 경우 `name_first_name, name_last_name`등으로 다 분리한다.
	- 앞에 Prefix는 의미가 명확하면 생략해도 된다. `first_name, last_name`
2. Multivalue/Derived Attribute의 경우: *반영하지 않는다.*

모두 반영하여 위 Diagram의 Schema를 만들면 다음과 같다.
```plaintext
instructor(
	ID,
	first_name, middle_initial, last_name,
	street_number, street_name, apt_number,
	city, state, zip_code,
	date_of_birt
) -- Multivalue/Derived인 phone_number와 age가 빠졌다.
```

**Representation of Entity Sets with Multivalued Attributes**

그럼 Multivalue Attribute들은 어떻게 하느냐?
-> Additional Table을 만든다.

Multivalue Attribute를 `M`이라 하고, 해당 속성이 Entity `E`에 속해있는 경우, `E_M`이라는 이름의 속성을 만든다.
```plaintext
instructor(ID, name, ...)
inst_phone = (ID, phone_number)
```
- PK는 `E`의 PK인 `ID`를 따흔다.

```
Instructor:
  (22222, 'Einstein')

inst_phone:
  (22222, '456-7890')
  (22222, '123-4567')
```
- 하나의 `Instructor`에 여러개의 `phone_number`가 있을 경우 `inst_phone` Table에 여러 개의 Tuple로 나눠서 저장한다.

그럼 PK이자 Multivalue Attribute인 `time_slot_id`를 가지고 있는 `time_slot` Entity는 어떻게 할까?
![100](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3e1Kl%2FbtsbV6VbTYl%2FrGGLXGLwJcMtR4LmZX95Hk%2Fimg.png)
```plaintext
time_slot = (time_slot_id, day, start_time, end_time)
```
- 이 경우 Addtional Table을 규칙에 따라 만들어봤자 중복이 발생하기 때문에 그냥 둬도 되지만,
- `sec_time_slot`에서 `time_slot_id`를 FK로 참조할 때 문제가 된다. `그래서 교재를 보면 화살표가 없어져 있다.`
- 왜냐하면 `time_slot_id`에 해당하는 Tuple이 없거나 여러 Tuple이 있을 수도 있기 때문이다.
	![300](../../z.%20Docs/img/Pasted%20image%2020250403174443.png)
- 따라서 FK로 참조하고 싶다면 최적화를 포기하고 Relation을 따로 만들어야 한다.

자세한 내용은 Text book `225-226p.`를 자세히 읽어보도록 하자.

**Representing Relationship Sets**

위에서 Relation은 크게 Many to Many, .. One to One 4가지로 나뉜다고 했었다.
그 Relation 유형에 따라 Schema로 바꾸는 방식이 다른다.

(1) Many to Many

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc2dAS0%2FbtsbPI9BiyG%2FPiuuHG3Mykzsek6Cn87sh1%2Fimg.png)
- 반드시 별도의 Table을 만들어야 하고,
- 양쪽의 PK를 가져와야한다.

(2) Many to One, One to Many

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcyvrxx%2FbtsbQ1NS0zL%2Fmdl8EhM7ZqYf6W2u26Dkj0%2Fimg.png)
- 별도의 Table을 만들 필요가 없고,
- Many Side에 One Side에 해당하는 PK를 FK로써 추가한다.

즉 `instructor-department`, `student-department` 관계에서 다음과 같이 된다.
```plaintext
instructor(ID, name, salary, dept_name)
student(ID, anme, tot_cred, dept_name)
```

그렇다면 `instructor-student` 관계에서는 어떨까?
여기는 Total Participation이 아니기 때문에 우리는 지도교수가 없는 학생이 있을 경우 `NULL값`를 생각해야 한다. 즉, Best Choice를 행해야 된다는 뜻이다.
1. Relation에 대한 추가적인 Table을 만들던지, `e.g. advisor(i_id, s_id)`
2. NULL값이 생기더라도 추가적인 Table을 만들지 않고 Many Side에 One Side에 해당하는 PK를 FK로써 추가할지 선택해야한다.

일단 수업에서는 2.만을 허용하도록 하기로 한 것 같다.

(3) One to One

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fsh5M2%2FbtsbRAo5tdO%2Fm9TsSfrLP89BE822mC0mKk%2Fimg.png)
- 별도의 Table을 만들 필요가 없고,
- 두 Side 중 하나를 선택해서 그 Entity의 PK를 다른 Entity의 FK로 넣으면 된다.

즉 다음과 같은 두 가지 경우가 가능하다:
1. `instructor(instructor.ID, name, salary, student.ID)`, `student(student.ID, name, tot_cred)`
2. `instructor(instructor.ID, name, salary)`, `student(student.ID, name, tot_cred, instructor.ID)`

그런데 이 경우도 Total Participation이 아니기 때문에 NULL값을 허용하지 않겠다고 하면 위에서 설명한 것과 비슷하게 `advisor`라는 추가적인 Table을 만들어야 할 것이다.

(+) Weak Entity

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclDUdt%2FbtsbToIcj1n%2FlAolH915GKLeqG4yhuHPe1%2Fimg.png)
- 별도의 Table을 만들 필요가 없고,
- `section`에 `course_id`가 추가될 것이다. `위에 설명한 그대로다.`

## 6-3. Extended E-R Features

**Specialization**

객체지향 개념의 상속(Inheritance)과 비슷한 상위-하위 Entity 구조를 설계할 때 사용된다.

Specialization:
- 상위 Entity Set을 특성에 따라 더 구체적인 하위 Entity Set으로 나누는 과정이다. 즉, Top-down 설계 방식이다.
- `△ ISA`로 표기한다. e.g. instructor "is a" person.
```plaintext
         [Person]
           △ ISA
         /       \
  [Student]   [Instructor]
```

Attribute Inheritance:
- CPP의 클래스 개념을 생각하면 이해하기 편하다. Low-level의 Entity Set은 Higher Level Entity Set의 모든 속성과 관계를 상속받는다.

**Specialization Example**

예시를 살펴보자.
다음은 `person`을 서브그룹으로 `employee`와 `student`로 쪼갠 모습이다.
그리고 각각 추가 속성으로 `salary`와 `tot_credits`를 넣었다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbEaRgD%2FbtsbTohdVt1%2FZGSwg37gHXIm5ykbkrvo40%2Fimg.png)

위 Diagram을 토대로 다음과 같은 설계들이 가능하다.
1. Inheritance: `instructor`을 예로 들었을 때, 이 Entity의 속성은 `(rank, salary, ID, name, street, city)`일 것이다. 
2. Overlapping : 중복이 허용되는 경우, 즉 `employee`이면서 `student`인 경우가 허용되는 설계라면, 양 쪽 다 같은 사람이 있을 수 있을 것이다.
3. Disjoint : 2.과 반대로 중복이 허용되지 않는 설계도 가능하다. `employee`면서 `student`인 경우를 금지하는 것이다.
4. Total and Partial:
    - Total: 서브그룹에서 모든 학생은 해당 서브그룹안에 소속되는 것. e.g. 모든 `person`은 `employee` 또는 `student`이다
    - Partial: `person`을 `employee`와 `student`로 나누었을 때, 두 그룹 어디에도 속하지 않는 경우가 있는 것을 의미하다.

**Representing Specialization via Schemas**

그리고 위의 설계들을 Schema로 변환할 때 다음과 같은 두 가지 방법이 가능하다:
1. Method 1: `parent` Entity의 PK만 상속받는 경우
2. Method 2: 모든 속성을 상속받는 경우

(1) Method 1: `parent` Entity의 PK만 상속받는 경우

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcmUY7X%2FbtsbSNnZ8SY%2FMZkNA7wqVUbI0hlEPBSnck%2Fimg.png)
+) Attribute에 대한 중복은 발생하지 않는다.
-) 하지만 정보를 얻을 때 필수적으로 Join을 해야하므로 정보 조회가 번거롭다.

(2) Method 2: 모든 속성을 상속받는 경우

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCQbpc%2FbtsbRyLIklO%2Flkru0aWbo2XsSclOwvnKYk%2Fimg.png)
+) Attribute 중복이 빈번히 발생하므로 속성 변화 발생 시 관리해줘야 할 Table이 늘어난다.
-) 정보를 얻을 때 Join을 할 필요가 없으므로 정보 조회가 쉽다.

**Generalization**

Generalization:
- Specialization과 반대로 Bottom-up 설계에 해당한다. 즉, 하위 Entity로부터 상위 Entity를 추출하는 방식이다.
- 해석이 다를 뿐 나오는 Entity Set의 결과는 동일하다.

Specialization과 Generalization의 사용은 전환이 가능하다.

**Comlpeteness Constraint**



---

- total: Entity가 낮은 레벨 Entity Set에 속해야한다.
- partial: Default 상태. Entity가 낮은 레벨 Entity Set에 속할 필요가 없다.

**Aggregation ☆**

---

#### Designing Issues

[(데이터베이스) CH6. Database Design Using the E-R Model](https://0o0deng.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-CH6-Database-Design-Using-the-E-R-Model)

`67p.`
(a): 단순히 속성을 잘못 표기하는 경우 `dept_name`
(b): assignment가 한 번, 그에 따른 mark(평가)가 한 번 만 나가는구나를 알 수 있다. 즉, 과제가 여러 번 나갈 경우에는 해당 모델로써 정의를 할 수 없다. 이를 위해서 다음 두 가지 방식을 사용할 수 있다.
- (c): 이렇게 하면 과재를 여러 개 할당해도 문제가 없다.
- (d): 관계 속성 자체를 그냥 여러개의 set으로 표기

**Entities vs. Attributes**

Left
Instructor가 하나의 phone_number만 가질 수 있구나

Right
inst_phone: many-to-many relationship
phone_number를 여러개 가지고 있구나

왜 오른쪽 그림과 같이 모델링 해야될까?
-> Phone에 대한 추가 정보(속성)가 필요할 때 `location`
-> 단순히 `phone_number`를 여러 개 표시하고 싶다면 Multi-Value를 사용하면된다.

`69p.`
Relationship Set은 Entity들 간의 Action을 나타낼 때 사용하는 것이 좋다.

**Binary vs. Non-Binary Relationships**

# 3. Introduction to SQL

[(데이터베이스시스) Chapter 3: Introduction to SQL — 좌충우돌 기록기](https://ccho.tistory.com/10)
[(실습) sql.js demo: Online SQL interpreter](https://db-book.com/university-lab-dir/sqljs.html)

**SQL Parts**

DML: DB에서 Tuple을 수정/삽입/제거, 정보 검색
DDL: 
- Integrity`ch.2 참고 (PK != NULL, FK Constraints)`
- View Definition
Embedded SQL, Dynamic SQL: 일반 PL에 내재될 수 있다.
DCL: Data의 사용권한 관리

**DDL**

SQL의 Data-Definition Language이다.

**Domain Types in SQL**

Domain Type은 Attribute(column)이 가질 수 있는 값의 종류(Type)이다.

| 데이터 타입                             | 설명                                     | 예시                                                |
| ---------------------------------- | -------------------------------------- | ------------------------------------------------- |
| **`char(n)`**                      | 고정 길이 문자열 (n자리) 부족한 길이는 공백으로 채움        | `char(5)` → `'A '`                                |
| **`varchar(n)`**                   | 가변 길이 문자열 최대 n글자까지 저장 가능               | `varchar(5)` → `'A'`, `'Abcd'`                    |
| **`int`**                          | 정수형 (정수 중 일부, 크기는 시스템에 따라 다름)          | `1`, `0`, `-100`                                  |
| **`smallint`**                     | 작은 정수형 int보다 저장 공간 적음 (범위 작음)          | `1`, `2`, `-50`                                   |
| **`numeric(p, d)`**                | 고정 소수점 숫자 `p`는 전체 자릿수, `d`는 소수점 이하 자릿수 | `numeric(3,1)` → 가능: `44.5`, 불가능: `444.5`, `0.32` |
| **`real`**, **`double precision`** | 부동 소수점 실수형 정밀도는 시스템마다 다름               | `3.14159`, `1.23e+5`                              |
| **`float(n)`**                     | 최소 `n`자리 정밀도의 실수형 (정확한 저장은 보장되지 않음)    | `float(7)` → `1.234567` 정도 정확도                    |

**Create Table Construct**

```sql
CREATE TABLE Student (
  ID CHAR(5),              -- 학번: 고정 5글자
  Name VARCHAR(50),        -- 이름: 최대 50자
  Age SMALLINT,            -- 나이: 작은 정수
  GPA NUMERIC(3,2),        -- 평점: 소수점 2자리까지 정확하게 저장
  Height FLOAT(5)          -- 키: 부동소수점, 정밀도 약간 떨어짐
);
```

```sql
CREATE TABLE Instructor(
	ID char(5),
	name varchar(20),
	dept_name varchar(20),
	salary numeric(8,2)
);
```

**Integrity Constraints in Create Table**

```sql
CREATE TABLE instructor (
    ID CHAR(5),
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    salary NUMERIC(8,2),
    PRIMARY KEY (ID),
    FOREIGN KEY (dept_name) REFERENCES department
);
```

| 제약 조건         | 설명           | 특징         |
| ------------- | ------------ | ---------- |
| `PRIMARY KEY` | 행을 고유하게 식별   | NULL, 중복 ❌ |
| `FOREIGN KEY` | 다른 테이블의 키 참조 | 참조 무결성 유지  |
| `NOT NULL`    | 빈 값 불가       | 필수 입력 필드   |

**Updates to tables**

|명령어|용도|예시|
|---|---|---|
|`INSERT INTO ... VALUES (...)`|행 삽입|`INSERT INTO instructor VALUES (...)`|
|`DELETE FROM ...`|행 삭제|`DELETE FROM student WHERE ...`|
|`DROP TABLE ...`|테이블 삭제|`DROP TABLE instructor`|
|`ALTER TABLE ... ADD`|속성 추가|`ALTER TABLE instructor ADD email VARCHAR(50)`|
|`ALTER TABLE ... DROP`|속성 제거 (일부 DB만 지원)|`ALTER TABLE instructor DROP COLUMN email`|

Note
- `DELETE`는 행만 지우고 테이블 구조는 유지
- `DROP`은 테이블 구조와 데이터 모두 삭제
- `ALTER`는 테이블 구조를 수정 (열 추가/삭제)

**Basic Query Sturcture**

```sql
SELECT A1, A2, ..., An
FROM r1, r2, ..., rm
WHERE P;
```

|구성 요소|의미|
|---|---|
|`SELECT`|**어떤 속성(컬럼)을 출력할 것인지** 지정|
|`FROM`|**어떤 테이블(릴레이션)**에서 데이터를 가져올지 지정|
|`WHERE`|**조건(Predicate)**: 어떤 행(Row)을 선택할지 결정|

```sql
SELECT name, salary
FROM instructor
WHERE dept_name = 'Physics';
```
-> `instructor` 테이블에서 학과가 'Physics'인 교수의 이름과 급여를 조회
- SQL 쿼리 결과는 테이블 형식으로 반환된다.

| 키워드      | 의미                     |
| -------- | ---------------------- |
| `SELECT` | 어떤 열(column)을 가져올지 지정  |
| `FROM`   | 어떤 테이블에서 데이터를 가져올지 지정  |
| `WHERE`  | 어떤 조건의 행(row)만 가져올지 지정 |
| 결과       | 항상 "릴레이션(테이블)" 형식으로 반환 |

**The `SELECT` Clause**

- `SELECT`는 "무엇을 출력할지" 결정하는 핵심 절이다.
- `DISTINCT`, `AS`, 연산 등과 함께 쓰면 훨씬 유용하게 활용 가능하다.
- 결과는 항상 Table 형태로 반환된다.

**The `WHERE` Clause**

- `WHERE`은 `SELECT` 결과를 필터링하는 조건문이다.
- 숫자 비교, 문자열 비교, NULL 검사 등 다양한 연산을 지원한다.
- 복합 조건도 사용 가능 → `AND`, `OR`, `NOT`

**The `FROM` Claues**

- `FROM` 절은 데이터의 출처를 지정하는 핵심 절이다.
- 단일 테이블**, 다중 테이블, 서브쿼리, 별칭 등 다양한 방식으로 사용됩니다.
- 실제 데이터를 읽어오는 핵심 위치이기 때문에 성능에도 영향을 줄 수 있다.

**Renaming Operation**

SQL에서 `AS`는 Attribute나 Table에 임시 이름(별칭)을 붙이는 데 사용한다.  
결과를 더 읽기 쉽게 만들고, 복잡한 Query를 단순하게 표현할 수 있도록 도와준다.
`AS`를 쓸지말지는 물론 선택사항이다.

**Self Join Example**

Q) Find the supervisor of the supervisor of "Bob"
```sql
SELECT ES2.supervisor
FROM emp_super AS ES1 emp_super AS ES2
WHERE ES1.person='Bob' AND ES1.supervisor=ES2.person
```
-> 결과로 David가 출력된다.

Q) Can you find ALL the supervisors (direct and indirect) of "Bob"
-> 이는 Transitive Relationship(전이성 관계, Recursive)으로, SQL이 지원하지 않는다.

**String Operations**

| 함수                  | 기능           | 결과 예시                   |
| ------------------- | ------------ | ----------------------- |
| \|\|                | 문자열 연결       | `또는`CONCAT()`           |
| `SUBSTRING()`       | 부분 문자열 추출    | `'Database'` → `'base'` |
| `LENGTH()`          | 길이 반환        | `'Hello'` → `5`         |
| `UPPER() / LOWER()` | 대문자/소문자 변환   | `'sql'` → `'SQL'`       |
| `TRIM()`            | 양쪽 공백 제거     | `' Hello '` → `'Hello'` |
| `REPLACE()`         | 문자 대체        | `'abc' → 'xbc'`         |
| `POSITION()`        | 특정 문자열 위치 찾기 | `'a' in 'data'` → `2`   |

- 문자열 함수는 데이터를 출력 예쁘게, 조건 걸기 쉽게, 데이터 정리에 유용하다.
- DBMS마다 지원되는 함수 이름이나 문법에 약간 차이가 있을 수 있다. (MySQL, PostgreSQL 등)

**Ordering the Display of Tuples**

**Where Clause Predicates**

**Set Operations**

| Operation       | 의미                   |
| --------------- | -------------------- |
| `A UNION B`     | A 또는 B에 포함된 모든 Tuple |
| `A INTERSECT B` | A와 B에 모두 포함된 Tuple   |
| `A EXCEPT B`    | A에는 있지만 B에는 없는 Tuple |

보통 자동으로 중복을 제외해주는데 `all`을 붙이면 중복을 허용한다.

**NULL Values**

존재하지 않거나 Unkown값일 때 사용한다.
Atirhmetic 계산을 할 때 Null갑이 포함되어있으면 무조건 `NULL`값을 반환한다.
`WHERE` 조건문에서 `IS NULL`, `IS NOT NULL`을 통해 `NULL값을 확인할 수있다.
`AND`와 `OR` 연산자를 사용할 경우 `TRUE/FALSE`값이 결정될 수도 있다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmHDOq%2FbtsbQ19cEgH%2FoqHBsSlAVtWLsK6U1zPxKK%2Fimg.png)

**Aggregate Functions**

엑셀 생각하면된다.
입력으로 Set을 가지며 출력으로는 단일값을 갖는다. 보통 다음과 같은 내장 함수가 있다.

|함수|설명|예시|
|---|---|---|
|`AVG(col)`|평균값|`AVG(salary)`|
|`MIN(col)`|최소값|`MIN(score)`|
|`MAX(col)`|최대값|`MAX(salary)`|
|`SUM(col)`|총합|`SUM(credits)`|
|`COUNT(*)`|모든 행 개수|`COUNT(*)`|
|`COUNT(col)`|NULL 제외 값 개수|`COUNT(name)`|

**Aggregate Functions - Group By ☆**

`GROUP BY`는 행동을 그룹으로 묶고 각 그룹에 대해 Aggregate Functions을 적용할 수 있도록 해준다.
e.g. 부서별 평균, 학년별 학생 수, 카테고리별 합계
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbP9DKQ%2FbtsbSLqLnXi%2FhzfCFiHCT2sJyK9uLsZVg1%2Fimg.png)

기본 구조
```sql
SELECT 그룹속성, 집계함수
FROM 테이블
GROUP BY 그룹속성;
```

주의할 점은 `SELECT` 절에 일반 속성을 쓸 땐 반드시 `GROUP BY`에 포함되어야 한다.
다음은 잘못된 예시이다.
```sql
SELECT dept_name, ID, AVG(salary)
FROM instructor
GROUP BY dept_name;
```
- `ID`는 집계 함수로 묶이지도 않았고, `GROUP BY`에도 포함되지 않았다.
- SQL은 그룹마다 ID가 하나인지, 여러 개인지 알 수 없어서 모호하다.

**Aggreate Functions - Having Clause**

`HAVING`으로 그룹 조건 걸기
```sql
SELECT dept_name, AVG(salary) AS avg_salary
FROM instructor
GROUP BY dept_name
HAVING AVG(salary) > 70000;
```

**Nested Subqueries**

중첩 질의 처리(Nested Subqueries)란, 하나의 Query 한에 또 다른 Query `SELECT-FROM-WHERE`이 있는 것을 의미한다. 보통 괄호 `()` 안에 작성되며, 주 쿼리(main query)와 함께 실행된다.

Subquery 가 들어갈 수 있는 위치는 다음과 같다.

| 위치         | 예시 설명                       |
| ---------- | --------------------------- |
| `FROM` 절   | **서브쿼리를 테이블처럼** 사용 (가상 테이블) |
| `WHERE` 절  | **비교 조건이나 존재 여부 검사**        |
| `SELECT` 절 | **단일 값을 계산해서 출력**           |

(1) WHERE 절에 쓰는 서브쿼리 (가장 흔한 형태)

e.g. 급여가 전체 평균보다 높은 교수를 찾기
```sql
SELECT name, salary
FROM instructor
WHERE salary > (
  SELECT AVG(salary)
  FROM instructor
);
```
- `SELECT AVG(salary)` → 서브쿼리: 전체 평균 급여 계산 
- 바깥 쿼리에서 그보다 급여가 높은 사람을 찾음

(2) FROM 절에 쓰는 서브쿼리
- 서브쿼리를 임시 테이블처럼 사용해서 JOIN이나 GROUP BY와 함께 쓴다.

e.g. 학과별 평균 급여를 구하고 그것만 따로 출력
```sql
SELECT dept_name, avg_salary
FROM (
  SELECT dept_name, AVG(salary) AS avg_salary
  FROM instructor
  GROUP BY dept_name
) AS dept_avg
WHERE avg_salary > 70000;
```
-> 내부 서브쿼리가 부서별 평균 급여를 만든 테이블이 되고,  
그걸 바깥 쿼리에서 필터링

(3) SELECT 절에서 쓰는 서브쿼리
- 컬럼 하나의 값을 서브쿼리 결과로 채우기 (단일 값이어야 함)

e.g. 각 교수 이름과 전체 교수의 평균 급여 함께 출력
```sql
SELECT name,
       salary,
       (SELECT AVG(salary) FROM instructor) AS avg_salary
FROM instructor;
```
-> 각 행마다 `avg_salary` 컬럼에는 동일한 평균값이 표시된다.

요약하면 다음과 같다.

| 위치       | 예시                                  | 용도             |
| -------- | ----------------------------------- | -------------- |
| `WHERE`  | `salary > (SELECT AVG(salary) ...)` | 조건 비교          |
| `FROM`   | `FROM (SELECT ...) AS temp`         | 서브쿼리를 테이블처럼 사용 |
| `SELECT` | `SELECT name, (SELECT ...)`         | 결과에 단일 값 포함    |

주의사항
- 서브쿼리의 결과가 여러 행이면 오류 발생 (단일 값만 기대하는 곳에선)
- `IN`, `EXISTS`, `ANY`, `ALL` 등의 연산자와 함께 쓰면 다중 행 비교도 가능해요 (다음에 설명 가능!)


**Set Membership**

★ 꼭 이해해보자.
```sql
SELECT COUNT(DISTINCT ID)
FROM takes
WHERE (course_id, sec_id, semester, year) IN (
  SELECT course_id, sec_id, semester, year
  FROM teaches
  WHERE teaches.ID = 10101
);
```
->
```sql
SELECT COUNT(DISTINCT takes.ID)
FROM takes ta, teaches te
WHERE te.ID = '10101' AND (
	te.course_id,
	te.sec_id, 
	te.semester,
	te.year
)
```

**Set Comparison**

`SOME`, `ALL` 연산자를 통해 Subquery 결과의 Relation과 바깥 Query를 비교하는 것이다.
다음 두 Query는 같은 결과를 반환한다.

`SOME`절
```sql
SELECT DISTINCT T.name
FROM instructor AS T, instructor AS S
WHERE T.salary > S.salary
  AND S.dept_name = 'Biology';
```
->
```sql
SELECT name
FROM instructor
WHERE salary > SOME (
  SELECT salary
  FROM instructor
  WHERE dept_name = 'Biology'
);
```
- Subquery의 결과 중 하나라도 조건을 만족시키는게 있다면 해당 Tuple을 참으로 판단한다.
- `SOME`은 `IN` 연산과 동일하지만 `SOME` 부정이 `NOT IN`과 동일한 것은 아니다.

`ALL` 절
`SOME`과 `ALL`의 상식적인 차이를 생각하면된다. 두 개의 절을 그림으로 비교하면 다음과 같다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxGY6y%2FbtsbRJN0mVM%2FEoCMANyK2ADVgtN66hkuLk%2Fimg.png) ![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxTa1G%2FbtsbRKszQxF%2FQstFtyUQ6DSUv1Padn8wK0%2Fimg.png)

**Test for Empty Relations**

... `정리 필요`

**With Clause**