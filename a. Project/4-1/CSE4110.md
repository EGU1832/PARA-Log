데이터베이스시스템

# 1. Introduction

[(데이터베이스시스템) Chapter 1: Introduction — 좌충우돌 기록기](https://ccho.tistory.com/6?category=1168493)

DBMS:
1. Collection of Interrelated Data
2. Set of Programs to Access the Data

특히 특정 조직과 관련된 정보들
-> 사용하기 편리하고 효율적인 환경 제공

**Purpose of Databas Systems**

DBMS 이전: Database Application이 FS에 직접적으로 작성
- Data Redundangy and Inconsistency(데이터 중복과 비일관성)
- Difficalty in Accessing Data(데이터 엑게스 시의 난점)
- Data Isolation(데이터 고립)
- Integrity Problems(무결성 문제)
- Atomicity of Updates(업데이트에 대한 원자성 문제)
- Concurrent Access by Multiple Users(동시 엑세스 문제)
- Security Problems(보안 문제)

**Data Model**

다음과 같은 것을 묘사하기 위한 tool
- Data: 무엇을 저장할 것인가
- Data Relationships: 데이터끼리 어떻게 연결되어 있는가
- Data Semantics: 데이터가 어떤 의미를 가지는가
- Data Constraints: 데이터에 어떤 규칙이 적용되는가

대표적인 데이터 모델의 종류
1. ☆ Relational Model(관계형 모델) `Table(Relatinon)`
2. ☆ Entiry-Relationship(E-R) Model `Entity, Attribute, Relationship`
3. Object-based Data Models `Object-oriented, Object-relational`
4. Semi-Structured Data Model `XML`
5. Older Models (이전 세대 모델) `Network Model, Hierarchical Model`

**☆ Relational Model**
![300](../z.%20Docs/img/Pasted%20image%2020250328155819.png)
모든 Data는 다양한 Table에 저장되어있다.
- Columns(가로): Attribute
- Rows(세로): Tuple

**View of Data(Abstraction)**
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F57nJf%2Fbtr3uD08eXY%2FaerdeHPBl010BJp8lJsUgk%2Fimg.png)
- Physical Level: 실제로 Data가 어떻게 저장되는지
- Logical Level: 무엇이 저장되어 있는지, 그리고 속성 간의 관계 설명 `<- Programmer!`
- View Level: 사용자들은 Data의 일부분에만 관심이 있음

**Instances and Schemas**

PL의 Types and Variables과 비슷하다.
- Schema: DB의 전체적인 설계 `int`
	- Logical Schema: SQL 코드들
	- Physical Schema: 디스크에 물리적으로 어떻게 저장되는가에 대한 정보
- Instance: DB에 실제로 저장된 데이터 값 `10`

Schema
```sql
CREATE TABLE Customer (
    Customer_ID CHAR(5),
    Name VARCHAR(50),
    Address VARCHAR(100)
);

CREATE TABLE Account (
    Account_ID CHAR(5),
    Balance INT
);

CREATE TABLE Deposits (
    Customer_ID CHAR(5),
    Account_ID CHAR(5),
    FOREIGN KEY (Customer_ID) REFERENCES Customer(Customer_ID),
    FOREIGN KEY (Account_ID) REFERENCES Account(Account_ID)
);
```

Instance
``` plaintext
Customer 테이블
+-------------+--------+-------------------+
| Customer_ID | Name   | Address           |
+-------------+--------+-------------------+
| C001        | Alice  | Seoul             |
| C002        | Bob    | Busan             |
+-------------+--------+-------------------+
```

**Physical Data Independence**
Physical Schema는 바꿔도 Logical Schema는 바꿀 필요가 없다. 둘이 독립적이다.

**Database Language(DDL)**
- Database의 Schema를 정의하는 언어
- DDL의 결과는 `data dictionary`에 Meta data로써 저장된다. 다음과 같은 정보들을 포함한다.
	- Database Schema
	- Integrity Constraints `Primary Key, Foreign Key`
	- Authorization

**Database Manipulatoin Language (DML)**
- 사용자가 적절한 Data Model로 구성된 Data를 접근/조작할 수 있도록 하는 언어
- Query Language라고도 한다.
- DML의 종류는 기본적으로 두 가지 정도가 있다.
	- Procedural DML(절차식 DML): Data를 어떻게 구할지도 요구
	- Declarative DML(비절차식 DML) `이게 더 쉬움`

**SQL Query Language**
```sql
-- Comp. Sci에 있는 모든 Instructors 찾기
SELECT name
FROM instructor
WHERE dept_name = 'Comp. Sci.'
```
- Declarative DML, 즉 조건만 제시하고 세부적인 사항은 작성하지 않아도 된다.
- 한 개 이상의 Table --`SQL`-> 한 개의 Table
- Turing Machine equivalent Language(범용 튜링 머신)이 아니다. 즉 범용성이 떨어진다.
- 그래서 보통 복잡한 계산을 하기 위해 다른 PL `c, c++, java`에 내장된 형태로 작성된다.
- 보통의 Application들은 다음과 같이 DB에 접근한다.
	- SQL이 내장된 언어
	- ODBC/JDBC와 같은 응용 프로그램 Interface

**Database Design**

Logical Design: DB Schema 결정
- Business Decision: DB에 뭘 저장해야 하는가?
- CS Decision: 서로 연관된 Attribute가 Tabl에 들어가 있는가? 최대한 중복이 방지되어 있는가?
Physical Desing: DB의 Physical Layout

**Database Engine**

```plaintext
Database System {
	1. Storage Magager (저장 장치 관리자),
	2. Query Processor (질의 처리기),
	3. Transaction Management (트랜젝션 관리자)
}
```

**(1) Storage Manager (저장 장치 관리자)**

Low-level Data와 Application/Query 사이의 Interface 제공:
- OS 파일 관리자와 상호작용하며 Disk에 원시 Data 저장
- Data의 효율적인 저장, 검색, 갱신

구성요소:
- Authorization and integrity manager: 무결성 제약 조건 검사 `은행 잔고는 0 이상`
- Transaction manager: 고장시 일관성 유지 검사, 동시성 트렌젝션 시 문제 검사
- File manager: 자료구조 관리
- Buffer manager: Disk -> Main Memory -> Cache로 보낼 Data 결정

구조:
- Data Files: DB 자체를 저장
- Data Dictionary: Metadata, 특히 DB Schema 저장
- Indices: 특정 값을 가지고 있는 Data 항목에 빠르게 접근하기 위한 것, 주로 많이 검색하는 속성에 대해서 Indexing을 한다.

**(2) Query Processor (질의 처리기)**

구성요소:
- DDL Interpreter: DDL문 해독 후 `data dictionary` 내에 기록
- DML Compiler: DML문을 Engine이 이해할 수 있는 Low-level 명령어로 변환 `Query 최적화`
- Query Evaluation Engine: DML Compiler에 의해 생성된 Low-level 명령어 실행

Query Processing
![400](https://blog.kakaocdn.net/dn/WG7En/btr8hy3hsHy/5f1hvviiDCgY1PTbGOUo71/img.png)

**(3) Transaction Management (트랜젝션 관리자)**

Transaction: DB Applicaton에서 하나의 논리적 기능을 수행하는 연산들의 모임
- 원자성(Atomic)
- 일관성(Consistency):
	- 동시 접근시 일관성 유지 `Transaction-management Component`
	- system/transaction fail을 시키는 한이 있더라도 일관성 유지 `Concurrency-control Manager`

**Database Architecture**

Centralized DBs: 공유 메모리
Client-Server: Server가 실제 작업, Client는 원격으로 접속하여 작업
Parallel DBs: 모든 CPU가 메모리 공유 / Disk만 공유 / 공유 X
Distributed DBs: Geographical distribution, Schema/data heterogeneity

![300](https://blog.kakaocdn.net/dn/1AfHa/btqIasBcpS2/VMh2kxnsvUliPsSeqHugwK/img.png)

**Database Appilcations**

DB Application들은 보통 두 부분이나 세 부분으로 나뉜다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FvtkSQ%2Fbtr3ftZDGDv%2FK7BgQ7uJYpLDN4qgjJNqvK%2Fimg.png)
- 2계층 구조: Application이 Client 상에 존재하며, 그게 DB System과 통신한다.
- 3계층 구조: Client는 DB 호출을 직접적으로 하지 않고, Server간 통신은 Form Interface를 통해 이루어진다. 그리고 Application Server가 DB System과 통신한다.

다양한 User에 따른 전제 지도를 나타내면 다음과 같다.
![300](https://velog.velcdn.com/images/ashwon1218/post/dc5de678-2fec-4a1f-a05b-b3d7b55427aa/image.png)

**Database Administrator (DBA)**

Central Control을 하는 관리자를 의미한다. 다음과 같은 기능들을 수행한다.
- Schema 정의
- 저장 구조와 Access 방법 정의
- Schea 및 Physical 구조 수정
- Data 접근 권한 수락
- 루틴 유지
- DB의 주기적 백업
- 충분한 Disk 공간 보장 및 업그레이드
- DB 작업 모니터링

# 2. Intro to Relational Model

[(데이터베이스시스템) Chapter 2: Introduction to Relational Model — 좌충우돌 기록기](https://ccho.tistory.com/8)

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbGkfk0%2Fbtr5N4w9kXE%2FvgijhVWmypgxI6wdJMK7g0%2Fimg.png)

**Relation Schema and Instance**

Attribute(속성) $A_1, A_2, \cdots, A_n$

Relation Schema $R = (A_1, A_2, \cdots, A_n)$
- Table 모양 정의
- `e.g. instructor = (ID, name, dept_name, salary)`

Relation Instance $r(R)$
- Table 안에 있는 행(Row)들

Tuple $t$
- Relation Instance에서 각 행(Row)를 의미한다. 순서는 무의미하다.
- `e.g. (ID, name, dept_name, salary) = (101, 'Alice', 'CS', 90000)`

| 개념       | 비유           | 의미                |
| -------- | ------------ | ----------------- |
| Schema   | 시험지 양식       | 어떤 문제(속성)가 있는지 정의 |
| Instance | 학생이 푼 실제 답안지 | 현데 Data의 상태       |
| Tuple    | 시험지 한 장      | 한 명의 학생 데이터       |

Domain
- 각 Attribute가 가질 수 있는 값의 집합
- `e.g. Age는 int [0-150]`

Atomic
- 하나의 Attribute는 한 값만 가져야 한다. `e.g. CS O / CS, Math X`

Null
- Unknown, 모든 Attribute의 값으로 올 수 있으나 최대한 Null 값이 없도록 해야한다.

**Database Schema**

Database Schema: DB의 논리적 설계 `instructor(ID, name, dept_name, salary)`
Database Instance: 어떤 한 순간의 Data 스냅샷 `실제 Table Data 값`

*-> Instance의 Tuple는 시간에 따라 변할 수 있지만, Schema는 변하지 않는다.*

**★ Keys**

$K \subseteq R$
Key는 Attributes의 부분 집합이며, 어떠한 것을 식별한다는 의미가 있다.
$K$, Superkey는 Tuple을 Unique하게 식별할 수 있는 Key를 말한다.

(1) Candidate Key (후보 키):
Tuple을 유일하게 식별할 수 있는 최소한의 Attribute 집합

(2) Primary Key (기본 키):
Candidate Key 중 대표로 선택된 하나의 Key
- 각 Table에는 오직 하나의 Primary Key 존재
- Primary Key는 NULL이 될 수 없고, 중복도 안 된다.

(3) **Foreign Key (외래 키)**:
다른 Table의 Primary Key를 참조하는 속성으로 , 두 Table 사이의 Relationship을 표현하는 데 사용된다.
Constraints:
- 참조하는 Relation과 참조되는 Relation의 Domain이 동일해야 하며, 둘 다 동일한 값으로 존재해야 한다.
- Foreign Key에 저장되는 값은 반드시 참조하는 Table의 Primary Key 중 하나여야 한다.

*Referential Integrity Constraint(참조 무결성 제약)*
- 참조하는 Relation의 속성 값은 반드시 참조되는 Relation의 Primary Key에 존재해야 한다.
- 즉, 참조하는 Table의 특정 열 값이 반드시 참조 대상 Table의 Primary Key 값 중 하나여야 한다.

e.g.
Table1: `time_slot`
```plaintext
time_slot_id | start_time | end_time
-------------|------------|---------
TS1          | 09:00      | 10:30
TS2          | 10:45      | 12:15
```

Table2: `section`
```
course_id | sec_id | semester | year | time_slot_id (FK)
----------|--------|----------|------|------------------
CS101     | 1      | Fall     | 2024 | TS1
CS102     | 1      | Spring   | 2024 | TS3 ❌
```

- `section.time_slot_id`는 `time_slot.time_slot_id`를 참조하는 FK이다.
- `section.time_slot_id` 값은 반드시 time_slot 테이블에 존재해야 한다.
- 따라서 `TS1`은 OK, 하지만 `TS3`은 time_slot 테이블에 없으므로 참조 무결성 위반이다. ❌

e.g.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcUAVRi%2Fbtr9nmmIM8M%2FE9SkFxZkUbPdlUOTcRGCkK%2Fimg.png)

- `section.time_slot_id ->> time_slot.time_slot_id`: Referential Integrity Constraint을 나타내고 있다.
- Primary Key는 밑줄이 쳐져 있다.
- `s_id`는 PK이면서도 FK인 예시이다.
- `teaches` Table에서 4개의 Attribute가 모였을 때만 FK의 역할을 수행한다.

**Relational Query Languages**

`Chapter 1.의 Database Manipulatoin Language(DML) 참고`

3개의 Query Language가 있다.
Query Language란 사용자가 DB로부터 정보를 요청할 때 사용하는 언어이다.
1. *Relational Algebra*: SQL 쿼리어의 이론적인 기반을 제공한다.
2. Tuple Relational Calculus
3. Domain Relational Calculus

**Relational Algebra**

Procedural Language이며, 하나 혹은 두개의 Relation을 입력 받아 새 Relation을 반환한다.
- "무엇을 얻는가" 뿐만 아니라 "어떻게 얻는가"까지 명시한다.

| 연산                                | 기호                  | 설명                                             |
| --------------------------------- | ------------------- | ---------------------------------------------- |
| **Selection (σ, 시그마)**            | `σ condition (R)`   | 특정 조건을 만족하는 행(Tuple) 선택                        |
| **Projection (π, 파이)**            | `π column_list (R)` | 특정 열(Attribute)만 선택                            |
| **Union (∪, 유니온)**                | `R ∪ S`             | 두 Relation의 합집합 (중복 제거)                        |
| **Set Difference (-, 차집합)**       | `R - S`             | 첫 번째 Relation는 있지만 두 번째 Relation에는 없는 Tuple 반환 |
| **Cartesian Product (×, 데카르트 곱)** | `R × S`             | 두 Relation의 모든 조합 반환                           |
| **Rename (ρ, 로)**                 | `ρ new_name (R)`    | Relation 또는 Attribute의 이름 변경                   

**Select Operation $\sigma$**

e.g. `instructor` Relation에서 "Physics" 과목에 있는 `instructor`들의 Tuple들을 찾아라.

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3fmpO%2Fbtr9nJIRoYP%2F1cSWnfcIewDqGE4c4F2jW1%2Fimg.png)
- Selection Predicate: `dept_name = "Physics"`

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb0lA34%2Fbtr9nJ28REA%2FSKFo7n2KH3kQh9fy9wkK00%2Fimg.png)
- 여러 비교 연산자를 사용할 수 있으며, Attribute들 끼리도 비교할 수 있다. $=, \neq, >, \geq, <, \leq$
- Selection Predicate이 여러 개일 경우 and, or, not 기호를 사용할 수 있다. $\wedge, \vee ,\neq$

**Project Operation $\Pi$**

e.g. `intstuctor`속성에서 `dept_name`을 제거하여라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcC2m93%2Fbtr9dXBCQKK%2FIbuGqQxTxsXcaSup0vUg9K%2Fimg.png)

**Cartesian Product Operation $\bigtimes$**

e.g. `instructor` Relation과 `teaches` Relation의 모든 가능한 조합의 Relation을 만들어라.

$\text{instructor} \times \text{teaches}$
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkOGuk%2Fbtr9pcSaIAp%2FyFvDkX5YLIKiYLcrLBhvJ0%2Fimg.png)
- 두 Relation을 합하여 하나의 Relation을 만든다.
- 그냥 모든 경우의 수를 나타내는 Table 하나를 만드는 거라고 생각하면 된다.
- `instructor.ID, teaches.ID`: 같은 이름의 Attribute가 있는 경우 Relation 이름을 옆에 붙여 구분한다.

**Join Operation $\bowtie$**

e.g. 어떠한 instructor와 그 instructor가 가르친 course가 있는 Tuple을 추출하여라.

$\text{instructor} \bowtie_{\text{ instructor.id = teaches.id}}\text{teaches}\equiv \sigma_{\text{instructor.id = teaches.id}}(\text{instructor} \times \text{teaches})$
![450](../z.%20Docs/img/Pasted%20image%2020250330003742.png)
- $\text{instructor} \times \text{teaches}$에서 특정 과목을 가르치지 않는 강사의 정보 또한 포함하고 있는데, Join Operation을 통해 이를 없애준다.
- 위를 통해 알 수 있듯이, Join Operation은 Cartesian Product와 Select의 조합이다. 즉
$$r\bowtie_\theta s = \sigma_\theta(r\times s)$$
- Join Operation은 두 Relation의 Attribute가 동일한 Domain이어야 한다. `Cartesian Product는 꼭 동일할 필요는 없다.`

**Union Operation (합집합) $\cup$**

e.g. Fall 2017 또는 Spring 2018에 가르친 course들을 모두 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbaN2vv%2Fbtr9pckEvhD%2FLTlOzhDis1Vr2H1RPIATY1%2Fimg.png)
- 두 Relation이 서로 같은 Attribute 순서로 이루어져 있어야 한다.
- 해당 연산을 수행하면 중복되는 값을 제외하고 합친 결과를 얻을 수 있다.

**Set-Intersection Operation (교집합) $\cap$**

e.g. Fall 2017 과 Spring 2018에 가르친 course들을 모두 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzaAu7%2Fbtr9nHZCGB1%2F64kmD779FuQxXnvUQCe9J1%2Fimg.png)
- Attribute 개수 및 Domain이 동일해야 한다.

**Set Difference Operation (차집합) $-$**

e.g. Fall 2017 에는 가르쳤지만, Spring 2018에는 가르치지 않은 course들을 모두 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdpekyj%2Fbtr9nat8WkE%2FpF5kWHi0EZ1WYt6UOXvmS0%2Fimg.png)
- 동일하게 Attribute 개수 및 Domain이 동일해야 한다.

**Assignment Operation $\leftarrow$**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcotT2t%2Fbtr9As7iJe9%2FLbcjk9bEkI2GQf7sW9bQp0%2Fimg.png)
- Temporary Relation 변수를 임시 변수에 할당하는 것을 의미한다.
- 이를 통해 Sequential Program처럼 동작하도록 할 수 있다.

**Rename Operation $\rho$**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpghzL%2Fbtr9pcE7arf%2FKXpGlKXXh8TLZsDKBSYbnk%2Fimg.png)
- Relation이나 Attribute에 새로운 이름을 지정할 수 있도록 해준다.
- $\rho_{\text{새로운 이름}}(\text{Relation})$
- 복잡한 질의를 작성할 때 중간 결과에 별명을 붙이거나, Attribute 이름이 겹치는 문제를 피할 때 사용한다.

**Equivalent Queries**

e.g. 90,000달러 이상의 연봉을 받는 Physics instructor가 가르치는 courses에 대한 정보를 찾아라.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGteyE%2Fbtr9m9WqyIJ%2Fj0dFp41zJA2B4XZWdckQRk%2Fimg.png)
- Query를 쓰는 방식은 하나 이상인 경우가 많다.
- Query가 동일하지 않아도 같은 결과를 주면 Equivalent하다고 한다.

---

### 📘 관계 대수 연산 요약표

|연산 기호|연산 이름|설명|예시|조건|
|---|---|---|---|---|
|`σ`|**Select (선택)**|조건을 만족하는 튜플(행)만 선택|`σ_{dept_name = 'Physics'}(instructor)`|없음|
|`π`|**Project (투영)**|특정 속성(열)만 추출|`π_{name, salary}(instructor)`|없음 (중복 제거 자동 포함)|
|`×`|**Cartesian Product (카티션 곱)**|두 릴레이션의 모든 가능한 조합|`instructor × teaches`|도메인 일치 필요 없음|
|`⋈`|**Join (조인)**|공통 속성 값이 같은 튜플끼리 결합|`instructor ⋈_{instructor.ID = teaches.ID} teaches`|조인 조건 속성의 도메인 동일|
|`∪`|**Union (합집합)**|두 릴레이션의 모든 튜플을 중복 없이 합침|`Fall2017 ∪ Spring2018`|속성 수와 도메인 동일|
|`∩`|**Intersection (교집합)**|두 릴레이션에 모두 존재하는 튜플만 반환|`Fall2017 ∩ Spring2018`|속성 수와 도메인 동일|
|`−`|**Set Difference (차집합)**|첫 릴레이션에만 존재하는 튜플 반환|`Fall2017 − Spring2018`|속성 수와 도메인 동일|
|`←`|**Assignment (할당)**|연산 결과를 임시 릴레이션에 저장|`temp ← σ_{...}(...)`|연산 결과를 재사용할 때 사용|
|`ρ`|**Rename (이름 변경)**|릴레이션/속성 이름 변경|`ρ_{prof}(instructor)``ρ_{prof(ID_num, full_name)}(instructor)`|복잡한 쿼리 정리, 중복 이름 회피 등|


💡 보충 요약
- `σ`와 `π`는 **단일 릴레이션을 입력으로 사용**
- `×`, `⋈`, `∪`, `∩`, `−`는 **두 릴레이션이 필요**
- `←`과 `ρ`는 **중간 결과를 재사용하거나 가독성을 위해 사용**

---

# 6. Database Design Using the E-R Model

[(데이터베이스시스템) Chapter 6: Database Design Using the E-RModel — 좌충우돌 기록기](https://ccho.tistory.com/9)

**Design Phase**
```
요구사항 분석 -> 개념적 모델링 -> 논리/물리적 설계
```
1. 사용자의 데이터 요구사항 분석
2. 데이터 모델 선택 `Relational Model, E-R Model`, Conceptual Schema 설계
3. Logical Design, Relation Schema 즉 어떤 Table과 Attribute를 가질지 설계 / Physical Design

**Design Alternatives**

DB Schema를 설계할 때, 다음과 같은 두 가지 오류를 피해야 한다.
1. Redundancy(중복성): Data를 업데이트 할 때 Data Inconsistenc를 초래할 수 있다.
2. Incompleteness(불완전성)

**Desing Approaches**

**(1) Entity-Relationship Medel(ER Model)
> 실세계의 정보를 *Entity*와 *Relationship*으로 추상화하여 모델링
- Entity: 현실 세계에서 구분 가능한 대상, Attribute를 통해 Entity 설명
	- e.g. 학생, 교수, 과목
- Relationship: Entity 간의 연관성
	- e.g. 학생이 수강한다, 교수가 강의한다.
- ER Diagram을 통해 시각적으로 표현 가능하다.

(2) Normalization Theory (정규화 이론) `Chapter 7에서 배울 예정`
> 나쁜 설계를 공식적으로 판별하고, 이상(Anomalies)를 제거학기 위한 형식적 절차

## 6-1. Outline of the ER Model

**ER model -- Database Modeling**

ER Model의 DB의 전체 논리 구조를 나타내는 Enterprise Schema를 지정할 수 있도록 하여 DB 설계를 용이하게 하기 위해 개발되었다.

ER Model 3 Basic Concepts
- Entity Sets
- Relationship Sets
- Attributes
그리고 이 모델을 Diagram으로 표현하면 DB의 전반적인 논리적 구조를 나타낼 수 있으며, 이를 ER Diagram이라고 한다.

**Entity Sets**

Entity
> 현실 세계에서 구분 가능한 대상, Attribute를 통해 Entity 설명
```
instructor = (ID, name, salary)
course = (course_id, title, credits)
```

Entity Set
> 같은 종류의 Entity들로 이루어진 집합이다.
- e.g. `Students: 모든 학생들의 집합`

**Representing Entity Sets in ER Diagram**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdsLK51%2Fbtsak9fyQTu%2FALpGUQzL7cg3X6PQMQXB71%2Fimg.png)
- PK: 밑줄 쳐진 Attributes

**Relationship Sets**

Relationship
> 여러 Entity 간의 관계를 나타낸다.
```
44553 (Peltier) -- advisor -- 22222 (Einstein)
```

Relationship Sets
> 같은 종류의 Relationship들을 모아놓은 집합
> $n \ge 2$개의 Entity들 간의 조합들로 구성된 수학적 집합 `수학적 정의`
```
(44553, 22222) ∈ advisor
```

**Relationship Sets with Attributes & ER Diagrams**

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcVUkIF%2FbtsaiqiilbU%2Fb6BgRB0r9mKlryx6tDPTbK%2Fimg.png) ![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcof9yT%2Fbtsak2VeZpp%2FLaztwRAnRkfTNhG8T4YQa1%2Fimg.png)
- Relationship에도 관련된 Attribute가 있을 수도 있다.
- 위 그림에서 Advisor의 `date`라는 Attribute를 통해 `student`가 `advisor`과 연관되기 시작한 시점을 알 수 있다.

**Roles**

Roles
> 동일한 Entity Set이 한 Relationhip에 두 번 이상 참여할 때,
> 각 참여가 어떤 Role을 하는지를 명확하게 하기 위해 붙이는 이름이다.
```
[Course] ───◇ prereq ◇─── [Course]
    ▲                          ▲
 course_id              prereq_id -- Roles
```
- 왜 Role이 필요할까? 그것은 하나의 Entity Set이 Relationship에 두 번 이상 등장하면 누가 누구를 참조하는지 모호해지기 때문이다.

**Degree of a Relatioship Set**

Degree는 해당 Relationship Set에 참여하는 Entity Set의 개수를 의미한다.

(1) Binary Relationship: 포함된 Entity set이 두 개 `Degree two`
- 거의 모든 Relationship Set들은 Binary이다.

(2) Non-Binary Relationship
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fu3Qni%2FbtsaqQmq07x%2FraxMxoNOzodc0pvLC4odm1%2Fimg.png)
- 위 그림은 Degree가 3인 Relationship의 ER Diagram 예시이다.
- e.g. `student`들이 `instructor`의 지도 아래 `project`에 참여한다.

**Complex Attributes**

Attribute Type에는 다양한 유형이 있다:
- Simple Attribute: 더 이항 분해가 안 되는 속성 `name`
- Composite Attribute: 또 다른 Component Attribute로 분해할 수 있는 속성 `Address -> City, Ave, ..`

또한 Attribute 값의 개수에 따라 다음과 같이 나뉜다:
- Single Value: 하나의 값만 가진다. `birth_date, student_id`
- Multi Value: 하나 이상의 값을 가질 수 있다. `phone_numbers`

그리고 Derived Attribute가 있는데 이는 다른 속성으로부터 유도된 속성이다.
- e.g. `age`: `date_of_birth`가 있다면 계산할 수 있다.

Domain은 각 속성이 가질 수 있는 허용 값들의 집합니다.
- e.g. `grade`: Domain = {A, B, C, D, F}
- e.g. `salary`: Domain = 양이 실수

**Representing Complex Attributes in ER Diagram**

![150](../../Z.%20Docs/img/Pasted%20image%2020250402213637.png)
- `name`: Composite Attribute
- `address`: Composite Attribute with Nested Composites
- `{phone_number}`: Multivalued Attribute
- `date_of_birth`: `age`의 기반
- `age()`: Derived Attribute, `()`는 계산 시점에 생성되는 속성이라는 뜻으로, DB에 실제로 저장되지는 않는다.

**Mapping Cardinality Constraints**

Mapping Cardinality
- Relationship Set을 통해 Mapping되는 개별 Entity들의 개수를 의미한다.
- Binary Relationship set에서 가장 유용하다.

Mapping Cardinality는 다음 4가지의 유형으로 나뉜다.
1. One to one
2. One to many
3. Many to one
4. Many to many

Diagram으로 들어가기 전, A와 B에 몇몇 Element들은 다른 Set의 Element와 mapping이 없을 수도 있다는 걸 알아두자.

(1) One to one `Relation이 없는 경우도 One to one에 해당한다.`
![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAvKVc%2FbtsakhEXtKq%2FRqjbfcuIheoQEKxEFqHPg0%2Fimg.png)

(2) One to many
![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdUv2EQ%2Fbtsai4lBHv7%2F7lslDJ5PMUb6AVPobaiAKK%2Fimg.png)

(3) Many to one
![200](../../Z.%20Docs/img/Pasted%20image%2020250402214436.png)

(4) Many to many
![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc7YbjR%2Fbtsak4evESb%2FFi0e6g5FGRTKg0amRxzl8K%2Fimg.png)

**Representing Candinality Construaints in ER Diagram**

$\rightarrow$: One, Relation의 한쪽 끝이 최대 1개의 Entity와만 연결된다.
$\textemdash$: Many, 관계의 한쪽 끝이 여러 개의 Entity들과 연결될 수 있다.

(1) One to one
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZTBAd%2Fbtsal5xtRaJ%2F2OMEG723onUcwnNHIMXS3k%2Fimg.png)
- 각 학생은 최대 하나의 교수를 지도교수로 가질 수 있다는 의미이다.

(2) One to many
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd23kxC%2Fbtsal5xtSDU%2FzRInEuXQhpbOpMpaJJgZpk%2Fimg.png)
- 각 교수는 여러 명의 학생을 지도할 수 있다는 의미이다. 그러나 학생은 한 명의 교수만 지도교수로 가질 수 있다.

(3) Many to one
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcIcIqQ%2Fbtsak4lg7Lr%2F1lRWH9QBW9pBFgb78q4mwk%2Fimg.png)
- One to many와 반대라 생각하면된다.

(4) Many to many
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdjx5Tx%2FbtsamXMJu0S%2FLTz3SyGkg45fzxR9baZG6K%2Fimg.png)
- 교수나 학생이나 여러명의 지도학생 혹은 지도교수를 가질 수 있다는 의미이다.

**Total and Partial Participation**

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBDYvi%2Fbtsal5EfJoU%2FkTCmzHQUyuGqub6BLmcptK%2Fimg.png)
- Total Participation `=`: 모든 학생이 지도교수를 가지고 있다.
- Partial Participation`-`: 모든 교수가 지도할 학생을 가지고 있는 건 아니다.

**Notation for Expressing More Complex Constraints**

더 많은 관계를 보이고 싶을 때, 다음과 같이 Cardimality(관계와 대응되는 Entity의 수)의 max와 min을 표시할 수 있다.
밑의 그림은 `instructor`는 0또는 그 이상의 지도할 학생을 가질 수 있고, `student`는 반드시 한 명의 지도교수를 가지고 있어야 한다는 의미이다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcA4gNO%2FbtsatWGIKKA%2FlLeGQwJ8NXK6uykEoDGNeK%2Fimg.png)
- `0..*`: 0개 이상 관계에 참여 (선택적 참여 + 여러 번 가능)
- `1..*`: 최소 1번 이상 참여 (완전 참여 + 여러 번 가능)
- `0..1`: 최대 한 번만 관계에 참여 (선택적 참여 + 단일)
- `1..1`: 반드시 하나의 관계에 참여 (완전 참여 + 단일)

**Cardinality Constraints on Ternary Relationship**

그렇다면 Ternary(3) Relationship에서의 Cardinality는 어떻게 표현할까?
*그럴 때는 최대 하나의 화살표만 표시할 수 있도록 하고 있다.*
그 이유는 다음과 같이 여러가지 해석이 가능할 수도 있기 때문이다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkQfIw%2FbtqQfLsTzSo%2FHHJ1cDcixTycyIeBBz5xJk%2Fimg.png)
- A와 B가 1:1 Mapping 되고, 그것과 C가 Many의 관계를 가지는 경우
- A혹은 B가 C와 1:N 관계로 Mapping 되고, 나머지 하나가 1:1로 다시 Mapping 되는 경우

**Primary Key**

PK는 주어진 Set 내에서 특정 Entity/Relationship을 구분할 수 있도록 해준다.
우리는 다음과 같은 집합 내의 PK에 대해 다룰 것이다:
- Entity Sets
- Relationship Sets
- Weak Entity Sets

**PK for Entity Sets**

`ch2.`에서 이미 자세히 다뤘다.

**PK for Relationship Sets**

Entity를 구분시켜주는 PK는 배웠는데, 그럼 Relationship은 어떻게 구분할까?
$E_1, \cdots E_n$의 Entity Set과 관계를 맺는 Relationship Set $R$ 이 있다고 가정해보자.
-> $R$ 을 식별하기 위해서는 *Entity의 PK의 합집합을* Superkey로 가져온다.

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FZTBAd%2Fbtsal5xtRaJ%2F2OMEG723onUcwnNHIMXS3k%2Fimg.png)
- Relationship Set `advisor`의 PK는 `{instructor.ID, strudent.ID}`이다.

PK를 가지면서도 다음 그림과 같이 `advisor`의 추가 속성이 있을 수 있다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcof9yT%2Fbtsak2VeZpp%2FLaztwRAnRkfTNhG8T4YQa1%2Fimg.png)

**Choice of Primary Key for Binary Relationship**

Binary(2) Relation의 경우 집합이 결정된 다음 Relation의 PK를 구하기 위해서는 해당 관계의 *Cardinality*를 고려해야 한다.
핵심 원칙은 관계에 참여하는 *Entity들의 PK 중 어느 쪽, 또는 둘 다를 조합해 관계를 고유하게 식별할 수 있느냐*를 기준으로 결정한다.
- One to One: 두 쪽 다 최대 한 개의 관계만 가질 수 있으므로 -> *양쪽 중 아무 쪽의 PK*
- One to Many: Many 쪽 만으로도 각 Relation을 고유하게 식별 가능 -> *Many 쪽의 PK*
- Many to One: One to Many와 동일하다 -> *Many 쪽의 PK*
- Many to Many: 두 Entity의 PK를 모두 조합한 것이 최소 Superkey다. -> *두 쪽 PK 조합*

**PK for Weak Entity Sets**

Weak Entity Set이란 자체적으로는 PK가 없는 Entity Set으로, 다른 Identifying Entity의 존재에 의존해서만 식별될 수 있는 Entity이다.

강한 예가 바로 아래 그림의 `section`이다.
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcJRNsh%2FbtsaESjqQxN%2FCMNOY54WeAnKPlqTyPYDE1%2Fimg.png)
- `section`은 `course_id`가 있어야만 고유하게 식별이 가능한데, 이는 `course` Entity의 기본 키로, 즉 `section`은 `course`에 의존적이다.
- 따라서 둘의 관계를 나타내기 위해 Relationship Set `sec_course`를 만들었다고 치자. 하지만 그 정보는 이미 `section`의 `course_id`가 있기 때문에 중복이 된다.
- 그렇다고 `sec_course`를 제거해버리면 두 관계가 명확히 표현되지 않는다.

이를 위해 다음과 같은 해결책을 제시한다.
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbJXhIy%2FbtsaiqvZ1wP%2FKHVq2GVCtyvrzznDSnXqj0%2Fimg.png)
- `section`을 Weak Entity Set으로 보고,
- `course`를 Identifying Entity Set,
- `sec_course`를 Identifying Relationship으로 설정하는 것이다.
- 점선으로 표시한 `sec_id, semester, year`는 `Weak Entity` 식별을 위해 추가로 필요한 속성들로, Discriminator라고 한다.

`section`에서 `course_id`를 제거하는 대신 `sec_course`라는 관계를 두어 `course`에 의존적인 상황임을 보인다.
- 여기서 Weak Entity Set이 아닌 Set을 Strong Entity Set이라고 한다.
- Weak Entity와 Identifying Entity의 관계를 Identifying Relationship이라고 한다.
- 둘의 관계를 생각해보면 왜 `=`으로 `section`을 Total Participation이라 표시했는지 알 것이다.
-> 결과적으로 `section`의 PK는 여전히 `(course_id, sec_id, semester, year)`이다.

**Redundant Attributes**

하지만 실제로 Relation Schema로 변환할 때는 `course_id`를 `section`에 포함시킨다.
```sql
section(
	course_id,
	sec_id,
	semester,
	year, 
	PRIMARY KEY(course_id, sec_id, semester, year),
	FOREIGN KEY(course_id)
	REFERENCES course
)
```

**E-R Diagram for a University Enterprise**

![600](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcs0iFF%2FbtsalayT5J0%2FJdmLeACfBq9KGMcOnLksqk%2Fimg.png)
- □: 무조건 Table로 표현해야한다.
- ◇:
	- Table로 변환되는 ◇가 있고 `Many to Many`
	- Table로 변환되지 않고 빠지는 ◇가 있다.

| 기호  | 의미           | Table 변환 | 조건                            |
| --- | ------------ | -------- | ----------------------------- |
| `□` | Entity       | ○        | 항상                            |
| `◇` | Relationship | △        | M:N이면 O, 1:N/1:1이면 X (FK로 처리) |

## 6-2. Reduction to Relation Schemas

**Reduction to Relation Schemas**

```
ER Diagram -> Schemas Diagram
```

DB 설계를 완료하기 위해서는 ER Modeling을 관계형 DB로 변환할 수 있어야 한다.
- Entity와 Relatioship은 각각 하나의 Table로 표시하고,
- Attribute는 Table Column으로 표현될 수 잇다.

**Representing Entity Sets**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbJXhIy%2FbtsaiqvZ1wP%2FKHVq2GVCtyvrzznDSnXqj0%2Fimg.png)
- Strong Entity Set은 Table 그대로 만들면 된다.
- Weak Entity Set은 Strong Entity Set의 PK를 포함시켜야 한다.
- e.g. `section (course_id, sec_id, semester, year)`

**Representation of Entity Sets with Composite Attributes**

Schema로 변환하는 과정에서, `Representing Complex Attributes in ER Diagram 참고`
기존 Entity Attribute가 다음과 같은 Type인지 구분할 필요가 있다:
- Single/Multi
- Simple/Composite

![200](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fqdon2%2FbtsbPnjMgP4%2FVNmGTRUpKMKKuUePNF8ma0%2Fimg.png)

Schema로 변환 시 다음과 같은 절차를 따른다:
1. Composite Attribute의 경우: *Flatten*시킨다.
	- e.g. `name`의 경우 `name_first_name, name_last_name`등으로 다 분리한다.
	- 앞에 Prefix는 의미가 명확하면 생략해도 된다. `first_name, last_name`
2. Multivalue/Derived Attribute의 경우: *반영하지 않는다.*

모두 반영하여 위 Diagram의 Schema를 만들면 다음과 같다.
```plaintext
instructor(
	ID,
	first_name, middle_initial, last_name,
	street_number, street_name, apt_number,
	city, state, zip_code,
	date_of_birt
) -- Multivalue/Derived인 phone_number와 age가 빠졌다.
```

**Representation of Entity Sets with Multivalued Attributes**

그럼 Multivalue Attribute들은 어떻게 하느냐?
-> Additional Table을 만든다.

Multivalue Attribute를 `M`이라 하고, 해당 속성이 Entity `E`에 속해있는 경우, `E_M`이라는 이름의 속성을 만든다.
```plaintext
instructor(ID, name, ...)
inst_phone = (ID, phone_number)
```
- PK는 `E`의 PK인 `ID`를 따흔다.

```
Instructor:
  (22222, 'Einstein')

inst_phone:
  (22222, '456-7890')
  (22222, '123-4567')
```
- 하나의 `Instructor`에 여러개의 `phone_number`가 있을 경우 `inst_phone` Table에 여러 개의 Tuple로 나눠서 저장한다.

그럼 PK이자 Multivalue Attribute인 `time_slot_id`를 가지고 있는 `time_slot` Entity는 어떻게 할까?
![100](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F3e1Kl%2FbtsbV6VbTYl%2FrGGLXGLwJcMtR4LmZX95Hk%2Fimg.png)
```plaintext
time_slot = (time_slot_id, day, start_time, end_time)
```
- 이 경우 Addtional Table을 규칙에 따라 만들어봤자 중복이 발생하기 때문에 그냥 둬도 되지만,
- `sec_time_slot`에서 `time_slot_id`를 FK로 참조할 때 문제가 된다. `그래서 교재를 보면 화살표가 없어져 있다.`
- 왜냐하면 `time_slot_id`에 해당하는 Tuple이 없거나 여러 Tuple이 있을 수도 있기 때문이다.
	![300](../../Z.%20Docs/img/Pasted%20image%2020250403174443.png)
- 따라서 FK로 참조하고 싶다면 최적화를 포기하고 Relation을 따로 만들어야 한다.

자세한 내용은 Text book `225-226p.`를 자세히 읽어보도록 하자.

**Representing Relationship Sets**

위에서 Relation은 크게 Many to Many, .. One to One 4가지로 나뉜다고 했었다.
그 Relation 유형에 따라 Schema로 바꾸는 방식이 다른다.

(1) Many to Many

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc2dAS0%2FbtsbPI9BiyG%2FPiuuHG3Mykzsek6Cn87sh1%2Fimg.png)
- 반드시 별도의 Table을 만들어야 하고,
- 양쪽의 PK를 가져와야한다.

(2) Many to One, One to Many

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcyvrxx%2FbtsbQ1NS0zL%2Fmdl8EhM7ZqYf6W2u26Dkj0%2Fimg.png)
- 별도의 Table을 만들 필요가 없고,
- Many Side에 One Side에 해당하는 PK를 FK로써 추가한다.

즉 `instructor-department`, `student-department` 관계에서 다음과 같이 된다.
```plaintext
instructor(ID, name, salary, dept_name)
student(ID, anme, tot_cred, dept_name)
```

그렇다면 `instructor-student` 관계에서는 어떨까?
여기는 Total Participation이 아니기 때문에 우리는 지도교수가 없는 학생이 있을 경우 `NULL값`를 생각해야 한다. 즉, Best Choice를 행해야 된다는 뜻이다.
1. Relation에 대한 추가적인 Table을 만들던지, `e.g. advisor(i_id, s_id)`
2. NULL값이 생기더라도 추가적인 Table을 만들지 않고 Many Side에 One Side에 해당하는 PK를 FK로써 추가할지 선택해야한다.

일단 수업에서는 2.만을 허용하도록 하기로 한 것 같다.

(3) One to One

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fsh5M2%2FbtsbRAo5tdO%2Fm9TsSfrLP89BE822mC0mKk%2Fimg.png)
- 별도의 Table을 만들 필요가 없고,
- 두 Side 중 하나를 선택해서 그 Entity의 PK를 다른 Entity의 FK로 넣으면 된다.

즉 다음과 같은 두 가지 경우가 가능하다:
1. `instructor(instructor.ID, name, salary, student.ID)`, `student(student.ID, name, tot_cred)`
2. `instructor(instructor.ID, name, salary)`, `student(student.ID, name, tot_cred, instructor.ID)`

그런데 이 경우도 Total Participation이 아니기 때문에 NULL값을 허용하지 않겠다고 하면 위에서 설명한 것과 비슷하게 `advisor`라는 추가적인 Table을 만들어야 할 것이다.

(+) Weak Entity

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclDUdt%2FbtsbToIcj1n%2FlAolH915GKLeqG4yhuHPe1%2Fimg.png)
- 별도의 Table을 만들 필요가 없고,
- `section`에 `course_id`가 추가될 것이다. `위에 설명한 그대로다.`

## 6-3. Extended E-R Features

**Specialization**

객체지향 개념의 상속(Inheritance)과 비슷한 상위-하위 Entity 구조를 설계할 때 사용된다.

Specialization:
- 상위 Entity Set을 특성에 따라 더 구체적인 하위 Entity Set으로 나누는 과정이다. 즉, Top-down 설계 방식이다.
- `△ ISA`로 표기한다. e.g. instructor "is a" person.
```plaintext
         [Person]
           △ ISA
         /       \
  [Student]   [Instructor]
```

Attribute Inheritance:
- CPP의 클래스 개념을 생각하면 이해하기 편하다. Low-level의 Entity Set은 Higher Level Entity Set의 모든 속성과 관계를 상속받는다.

**Specialization Example**

예시를 살펴보자.
다음은 `person`을 서브그룹으로 `employee`와 `student`로 쪼갠 모습이다.
그리고 각각 추가 속성으로 `salary`와 `tot_credits`를 넣었다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbEaRgD%2FbtsbTohdVt1%2FZGSwg37gHXIm5ykbkrvo40%2Fimg.png)

위 Diagram을 토대로 다음과 같은 설계들이 가능하다.
1. Inheritance: `instructor`을 예로 들었을 때, 이 Entity의 속성은 `(rank, salary, ID, name, street, city)`일 것이다. 
2. Overlapping : 중복이 허용되는 경우, 즉 `employee`이면서 `student`인 경우가 허용되는 설계라면, 양 쪽 다 같은 사람이 있을 수 있을 것이다.
3. Disjoint : 2.과 반대로 중복이 허용되지 않는 설계도 가능하다. `employee`면서 `student`인 경우를 금지하는 것이다.
4. Total and Partial:
    - Total: 서브그룹에서 모든 학생은 해당 서브그룹안에 소속되는 것. e.g. 모든 `person`은 `employee` 또는 `student`이다
    - Partial: `person`을 `employee`와 `student`로 나누었을 때, 두 그룹 어디에도 속하지 않는 경우가 있는 것을 의미하다.

**Representing Specialization via Schemas**

그리고 위의 설계들을 Schema로 변환할 때 다음과 같은 두 가지 방법이 가능하다:
1. Method 1: `parent` Entity의 PK만 상속받는 경우
2. Method 2: 모든 속성을 상속받는 경우

(1) Method 1: `parent` Entity의 PK만 상속받는 경우

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcmUY7X%2FbtsbSNnZ8SY%2FMZkNA7wqVUbI0hlEPBSnck%2Fimg.png)
+) Attribute에 대한 중복은 발생하지 않는다.
-) 하지만 정보를 얻을 때 필수적으로 Join을 해야하므로 정보 조회가 번거롭다.

(2) Method 2: 모든 속성을 상속받는 경우

![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FCQbpc%2FbtsbRyLIklO%2Flkru0aWbo2XsSclOwvnKYk%2Fimg.png)
+) Attribute 중복이 빈번히 발생하므로 속성 변화 발생 시 관리해줘야 할 Table이 늘어난다.
-) 정보를 얻을 때 Join을 할 필요가 없으므로 정보 조회가 쉽다.

**Generalization**

Generalization:
- Specialization과 반대로 Bottom-up 설계에 해당한다. 즉, 하위 Entity로부터 상위 Entity를 추출하는 방식이다.
- 해석이 다를 뿐 나오는 Entity Set의 결과는 동일하다.

Specialization과 Generalization의 사용은 전환이 가능하다.

**Comlpeteness Constraint**

상위 집합의 Entity가 무조건 하위 집합의 Entity에 속해야하는지 여부를 지정하는 제약이다.
- Total: Entity가 낮은 레벨 Entity Set에 무조건 속해야 한다.
- Partial: Default 상태. Entity가 낮은 레벨 Entity Set에 무조건 속할 필요가 없다.

Total Generalization을 하면 ER Diagram에선 다음과 같이 표기한다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcTOLBr%2FbtsbQ1AYkHj%2FriHFAoq96roaX3mkxlJyI0%2Fimg.png)

**Aggregation**

Relation 자체를 하나의 Entity로 묶어서 다른 Relation에 참여시키는 방법이다.
e.g. `project`, `instructor`, `student`에 대한 Relation이 필요한 경우
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fz0Xce%2FbtsbToBS0Py%2FdVKjjeBFpWzTVinws5Ek61%2Fimg.png) ![282](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbtElkF%2FbtsbTo2Xoo7%2Fw5JOKlIeQYnkfQygnt1tkK%2Fimg.png)
- L: 하나하나 연결해줄 수도 있지만, 불필요한 정보 중복이 발행한다. 심지어 `proj_guide`가 항상 `eval_for`와 같지 않으므로 둘 중 하나를 제거하기도 어려운 상황이다.
- R: 세 Entity의 Relation 자체를 하나의 Entity로 묶어서 `eval_for`와 연결시키고 있다. 이러헥 하면 정보의 중복 없이 원하던 의도대로 표현이 가능하다.

다음과 같은 효과를 볼 수 있다.
- Relationship을 추상적 Entity로 다룰 수 있다.
- Relationship 사이의 Relationship을 허용할 수 있다.
- Relationship을 새로운 Entity로 추상화할 수 있다.

**Reduction to Relational Schemas**

그렇다면 Aggregation을 어떻게 Schema로 표현할까?
```
eval_for (i_ID, project_id, s_ID, evaluation_id)
```
- 새로운 Schema에 집합으로 이루어진 `(proj_guide)`의 PK와 `evalutation`의 PK를 포함하면 된다.
- 이 경우 별도의 `proj_guide` Schema는 불필요하다. 즉, Aggregation을 표현하기 위해 추가적인 Entity Table을 생성할 필요는 없다는 것이다. 관계를 FK 조합으로 표현하면 충분하다.

## 6-4. Designing Issues

**Common Mistakes in E-R Diagrams**

E-R Diagram을 설계할 때 실수할 수 있는 것 들에 대해서 알아보자.

(1) 내부 속성으로 정의된 것을 추가 속성으로 넣는 경우
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdMr7hq%2FbtsbSgdulMU%2Fn7WNlzgVnjDb7KmzUlTVKK%2Fimg.png)
- 이미 Relationship `(stud_dept)`가 정의되어 있으므로 `student` 내부에 있는 `dept_name`을 제거해야 한다.

(2) Relationship Attribute의 오용
![450](https://blog.kakaocdn.net/dn/AUEe3/btsbQHC0cEZ/KcndAkrJcubs8SYv4AiJL1/img.png)
- Assignment가 2개 이상인 경우 다음과 같이 정의하는 것은 적절하지 않다.
- `assignment`가 한 번, 그에 따른 `mark`(평가)가 한 번 만 나가는구나를 알 수 있다. 즉, 과제가 여러 번 나갈 경우에는 해당 모델로써 정의를 할 수 없다.

(2)의 해결방법은 다음과 같다.
![600](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FG6qDS%2FbtsbSElkJga%2FAuJ6fKgxWP2S9Y83aOg1M1%2Fimg.png)
- (c): `assignment`를 Entity로 분리한다.
- (d): `assignment_marks`라는 Multi Value Attribute를 부여한다.

**Entities vs. Attributes**

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBamiv%2FbtsbRz5iKxl%2FrOMOeVO1KykxKvzcpQB72K%2Fimg.png)
- L: `instructor`가 하나의 `phone_number`만 가질 수 있다.
- R: `inst_phone`은 Many to Many Relationship으로, `phone_number`를 여러개 가질 수 있다.

왜 R과 같이 모델링 해야될까?
- `phone`에 대한 추가 정보(속성)가 필요할 때 `location`
- 단순히 `phone_number`를 여러 개 표시하고 싶다면 L 그대로 Multi Value를 사용하면된다.

**Entities vs. Relationship sets**

Relationship Set은 Entity들 간의 Action을 나타낼 때 사용하는 것이 좋다.
![450](../../Z.%20Docs/img/Pasted%20image%2020250406021402.png)

**Binary vs. Non-Binary Relationships**

물론 모든 Non-Binary Relationship들은 Binary Relationship으로 나타내는 것이 가능하지만, 상황에 따라 어느 것이 더 좋느냐는 또 별개의 이야기다.
- Binary가 더 나은 경우: `father(child, father), mother(child, mother)`
- Non-Binary가 더 나은 경우: `proj_guide(student, project, instructor)`

**Converting Non-Binary Relationships to Binary Form**

그럼 Non-Binary Relationship을 어떻게 Binary Relationship으로 변환할까?
-> Entity Set을 추가하면 된다.

![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdz6oWn%2FbtsbQHptRoS%2FNpPkbdtj73YUMipjQIaTd0%2Fimg.png)
- 그런데 이 경우 $R_A, R_B, R_C$로 분리시켜서 Relation을 맺는 것과 $R$을 사용하여 Relation을 맺는 것이 다른 경우도 있다.
- 따라서 분리시킬 때 추가적인 Constraints를 두는 것이 좋다. 혹윽 $E$를 Weak Entity Set으로 두어 $R_A, R_B, R_C$에 의해 식별되도록 할 수도 있다.

**E-R Design Decisions**

다음은 E-R Design에서 고려해야 할 주요 결정들이다:
- Attribute? Entity Set?
	- 단순한 값이면 Attribute
	- 고유한 정보와 관계를 가질 필요가 있다면 Entity
- Real-World 개념을 Entity? Relationship Set?
	- 명사적인 개념이면 Entity
	- 행동적, 연결적인 개념이면 Relationship
- Ternary? N-Binary?
	- 세 개 이상의 엔터티가 동시에 하나의 의미 있는 관계를 가질 때는 Ternary
	- 각각 독립적으로 연결될 수 있다면 Binary
- Strong Entity? Weak Entity?
	- 고유 식별자가 있으면 Strong Entity
	- 다른 Entity의 도움을 받아야 하면 Weak Entity
- Specialization? Generalization?
	- 상속 구조가 필요하다면 사용
	- 상위 -> 하위로 나누는 것은 Specialization
	- 하위 -> 상위로 일반화하는 것은 Generalization
- Aggregation
	- Relation 자체를 다른 Relation과 연결해야 한다면 사용
	- 복잡한 구조를 하나의 단위로 묶어 추상화 가능

**Sumary of Symbols Used in E-R Notation**

거의 Cheating Sheet니까 잘 익혀두자.

![600](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHSa6j%2FbtsbVfqSjaz%2FgG3KLNG8o3SO5miqfXKoQK%2Fimg.png)
![600](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdycfqN%2FbtsbSD7o0vo%2FIqaCA0ISr0F5hixEQPKKy1%2Fimg.png)

**Alternative ER Notations**

위에서 소개한 Notation 말고도 다른 여러가지 대체 표기법이 있는 것 같다.
자세한 건 `ch6.pdf` 참고

**UML(Undefined Modeling Language)**

UML이란 소프트웨어 시스템의 구조, 동작, 상호작용등을 시각적으로 모델링하기 위한 표준 언어이다.
UML의 Class Diagram은 DB의 ER Diagram과 흡사하나, 몇몇 다른 부분이 있다.

**ER vs. UML Class Diagrams**

![600](../../Z.%20Docs/img/Pasted%20image%2020250407172614.png)
- UML Class Diagram에서 binary 관계는 선 하나로 표현되며,  
- 역할(role)과 속성(attributes)이 필요한 경우에는  
	- 선 끝에 역할 이름을 붙이거나,
	- 관계 이름을 박스에 담고 점선으로 연결하여 확장할 수 있다.

# 3. Introduction to SQL

[(데이터베이스시스) Chapter 3: Introduction to SQL — 좌충우돌 기록기](https://ccho.tistory.com/10)
[(실습) sql.js demo: Online SQL interpreter](https://db-book.com/university-lab-dir/sqljs.html)

**SQL Parts**

DML: DB에서 Tuple을 수정/삽입/제거, 정보 검색
DDL: 
- Integrity`ch.2 참고 (PK != NULL, FK Constraints)`
- View Definition
Embedded SQL, Dynamic SQL: 일반 PL에 내재될 수 있다.
DCL: Data의 사용권한 관리

**DDL**

SQL의 Data-Definition Language이다.

**Domain Types in SQL**

Domain Type은 Attribute(column)이 가질 수 있는 값의 종류(Type)이다.

| 데이터 타입                             | 설명                                     | 예시                                                |
| ---------------------------------- | -------------------------------------- | ------------------------------------------------- |
| **`char(n)`**                      | 고정 길이 문자열 (n자리) 부족한 길이는 공백으로 채움        | `char(5)` → `'A '`                                |
| **`varchar(n)`**                   | 가변 길이 문자열 최대 n글자까지 저장 가능               | `varchar(5)` → `'A'`, `'Abcd'`                    |
| **`int`**                          | 정수형 (정수 중 일부, 크기는 시스템에 따라 다름)          | `1`, `0`, `-100`                                  |
| **`smallint`**                     | 작은 정수형 int보다 저장 공간 적음 (범위 작음)          | `1`, `2`, `-50`                                   |
| **`numeric(p, d)`**                | 고정 소수점 숫자 `p`는 전체 자릿수, `d`는 소수점 이하 자릿수 | `numeric(3,1)` → 가능: `44.5`, 불가능: `444.5`, `0.32` |
| **`real`**, **`double precision`** | 부동 소수점 실수형 정밀도는 시스템마다 다름               | `3.14159`, `1.23e+5`                              |
| **`float(n)`**                     | 최소 `n`자리 정밀도의 실수형 (정확한 저장은 보장되지 않음)    | `float(7)` → `1.234567` 정도 정확도                    |

**Create Table Construct**

```sql
CREATE TABLE Student (
  ID CHAR(5),              -- 학번: 고정 5글자
  Name VARCHAR(50),        -- 이름: 최대 50자
  Age SMALLINT,            -- 나이: 작은 정수
  GPA NUMERIC(3,2),        -- 평점: 소수점 2자리까지 정확하게 저장
  Height FLOAT(5)          -- 키: 부동소수점, 정밀도 약간 떨어짐
);
```

```sql
CREATE TABLE Instructor(
	ID char(5),
	name varchar(20),
	dept_name varchar(20),
	salary numeric(8,2)
);
```

**Integrity Constraints in Create Table**

```sql
CREATE TABLE instructor (
    ID CHAR(5),
    name VARCHAR(20) NOT NULL,
    dept_name VARCHAR(20),
    salary NUMERIC(8,2),
    PRIMARY KEY (ID),
    FOREIGN KEY (dept_name) REFERENCES department
);
```

| 제약 조건         | 설명           | 특징         |
| ------------- | ------------ | ---------- |
| `PRIMARY KEY` | 행을 고유하게 식별   | NULL, 중복 ❌ |
| `FOREIGN KEY` | 다른 테이블의 키 참조 | 참조 무결성 유지  |
| `NOT NULL`    | 빈 값 불가       | 필수 입력 필드   |

**Updates to tables**

|명령어|용도|예시|
|---|---|---|
|`INSERT INTO ... VALUES (...)`|행 삽입|`INSERT INTO instructor VALUES (...)`|
|`DELETE FROM ...`|행 삭제|`DELETE FROM student WHERE ...`|
|`DROP TABLE ...`|테이블 삭제|`DROP TABLE instructor`|
|`ALTER TABLE ... ADD`|속성 추가|`ALTER TABLE instructor ADD email VARCHAR(50)`|
|`ALTER TABLE ... DROP`|속성 제거 (일부 DB만 지원)|`ALTER TABLE instructor DROP COLUMN email`|

Note
- `DELETE`는 행만 지우고 테이블 구조는 유지
- `DROP`은 테이블 구조와 데이터 모두 삭제
- `ALTER`는 테이블 구조를 수정 (열 추가/삭제)

**Basic Query Sturcture**

```sql
SELECT A1, A2, ..., An
FROM r1, r2, ..., rm
WHERE P;
```

|구성 요소|의미|
|---|---|
|`SELECT`|**어떤 속성(컬럼)을 출력할 것인지** 지정|
|`FROM`|**어떤 테이블(릴레이션)**에서 데이터를 가져올지 지정|
|`WHERE`|**조건(Predicate)**: 어떤 행(Row)을 선택할지 결정|

```sql
SELECT name, salary
FROM instructor
WHERE dept_name = 'Physics';
```
-> `instructor` 테이블에서 학과가 'Physics'인 교수의 이름과 급여를 조회
- SQL 쿼리 결과는 테이블 형식으로 반환된다.

| 키워드      | 의미                     |
| -------- | ---------------------- |
| `SELECT` | 어떤 열(column)을 가져올지 지정  |
| `FROM`   | 어떤 테이블에서 데이터를 가져올지 지정  |
| `WHERE`  | 어떤 조건의 행(row)만 가져올지 지정 |
| 결과       | 항상 "릴레이션(테이블)" 형식으로 반환 |

**The `SELECT` Clause**

- `SELECT`는 "무엇을 출력할지" 결정하는 핵심 절이다.
- `DISTINCT`, `AS`, 연산 등과 함께 쓰면 훨씬 유용하게 활용 가능하다.
- 결과는 항상 Table 형태로 반환된다.

**The `WHERE` Clause**

- `WHERE`은 `SELECT` 결과를 필터링하는 조건문이다.
- 숫자 비교, 문자열 비교, NULL 검사 등 다양한 연산을 지원한다.
- 복합 조건도 사용 가능 → `AND`, `OR`, `NOT`

**The `FROM` Claues**

- `FROM` 절은 데이터의 출처를 지정하는 핵심 절이다.
- 단일 테이블**, 다중 테이블, 서브쿼리, 별칭 등 다양한 방식으로 사용됩니다.
- 실제 데이터를 읽어오는 핵심 위치이기 때문에 성능에도 영향을 줄 수 있다.

**Renaming Operation**

SQL에서 `AS`는 Attribute나 Table에 임시 이름(별칭)을 붙이는 데 사용한다.  
결과를 더 읽기 쉽게 만들고, 복잡한 Query를 단순하게 표현할 수 있도록 도와준다.
`AS`를 쓸지말지는 물론 선택사항이다.

**Self Join Example**

Q) Find the supervisor of the supervisor of "Bob"
```sql
SELECT ES2.supervisor
FROM emp_super AS ES1 emp_super AS ES2
WHERE ES1.person='Bob' AND ES1.supervisor=ES2.person
```
-> 결과로 David가 출력된다.

Q) Can you find ALL the supervisors (direct and indirect) of "Bob"
-> 이는 Transitive Relationship(전이성 관계, Recursive)으로, SQL이 지원하지 않는다.

**String Operations**

| 함수                  | 기능           | 결과 예시                   |
| ------------------- | ------------ | ----------------------- |
| \|\|                | 문자열 연결       | `또는`CONCAT()`           |
| `SUBSTRING()`       | 부분 문자열 추출    | `'Database'` → `'base'` |
| `LENGTH()`          | 길이 반환        | `'Hello'` → `5`         |
| `UPPER() / LOWER()` | 대문자/소문자 변환   | `'sql'` → `'SQL'`       |
| `TRIM()`            | 양쪽 공백 제거     | `' Hello '` → `'Hello'` |
| `REPLACE()`         | 문자 대체        | `'abc' → 'xbc'`         |
| `POSITION()`        | 특정 문자열 위치 찾기 | `'a' in 'data'` → `2`   |

- 문자열 함수는 데이터를 출력 예쁘게, 조건 걸기 쉽게, 데이터 정리에 유용하다.
- DBMS마다 지원되는 함수 이름이나 문법에 약간 차이가 있을 수 있다. (MySQL, PostgreSQL 등)

**Ordering the Display of Tuples**

**Where Clause Predicates**

**Set Operations**

| Operation       | 의미                   |
| --------------- | -------------------- |
| `A UNION B`     | A 또는 B에 포함된 모든 Tuple |
| `A INTERSECT B` | A와 B에 모두 포함된 Tuple   |
| `A EXCEPT B`    | A에는 있지만 B에는 없는 Tuple |

보통 자동으로 중복을 제외해주는데 `all`을 붙이면 중복을 허용한다.

**NULL Values**

존재하지 않거나 Unkown값일 때 사용한다.
Atirhmetic 계산을 할 때 Null갑이 포함되어있으면 무조건 `NULL`값을 반환한다.
`WHERE` 조건문에서 `IS NULL`, `IS NOT NULL`을 통해 `NULL값을 확인할 수있다.
`AND`와 `OR` 연산자를 사용할 경우 `TRUE/FALSE`값이 결정될 수도 있다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmHDOq%2FbtsbQ19cEgH%2FoqHBsSlAVtWLsK6U1zPxKK%2Fimg.png)

**Aggregate Functions**

엑셀 생각하면된다.
입력으로 Set을 가지며 출력으로는 단일값을 갖는다. 보통 다음과 같은 내장 함수가 있다.

|함수|설명|예시|
|---|---|---|
|`AVG(col)`|평균값|`AVG(salary)`|
|`MIN(col)`|최소값|`MIN(score)`|
|`MAX(col)`|최대값|`MAX(salary)`|
|`SUM(col)`|총합|`SUM(credits)`|
|`COUNT(*)`|모든 행 개수|`COUNT(*)`|
|`COUNT(col)`|NULL 제외 값 개수|`COUNT(name)`|

**Aggregate Functions - Group By ☆**

`GROUP BY`는 행동을 그룹으로 묶고 각 그룹에 대해 Aggregate Functions을 적용할 수 있도록 해준다.
e.g. 부서별 평균, 학년별 학생 수, 카테고리별 합계
![450](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbP9DKQ%2FbtsbSLqLnXi%2FhzfCFiHCT2sJyK9uLsZVg1%2Fimg.png)

기본 구조
```sql
SELECT 그룹속성, 집계함수
FROM 테이블
GROUP BY 그룹속성;
```

주의할 점은 `SELECT` 절에 일반 속성을 쓸 땐 반드시 `GROUP BY`에 포함되어야 한다.
다음은 잘못된 예시이다.
```sql
SELECT dept_name, ID, AVG(salary)
FROM instructor
GROUP BY dept_name;
```
- `ID`는 집계 함수로 묶이지도 않았고, `GROUP BY`에도 포함되지 않았다.
- SQL은 그룹마다 ID가 하나인지, 여러 개인지 알 수 없어서 모호하다.

**Aggreate Functions - Having Clause**

`HAVING`으로 그룹 조건 걸기
```sql
SELECT dept_name, AVG(salary) AS avg_salary
FROM instructor
GROUP BY dept_name
HAVING AVG(salary) > 70000;
```

**Nested Subqueries**

중첩 질의 처리(Nested Subqueries)란, 하나의 Query 한에 또 다른 Query `SELECT-FROM-WHERE`이 있는 것을 의미한다. 보통 괄호 `()` 안에 작성되며, 주 쿼리(main query)와 함께 실행된다.

Subquery 가 들어갈 수 있는 위치는 다음과 같다.

| 위치         | 예시 설명                       |
| ---------- | --------------------------- |
| `FROM` 절   | **서브쿼리를 테이블처럼** 사용 (가상 테이블) |
| `WHERE` 절  | **비교 조건이나 존재 여부 검사**        |
| `SELECT` 절 | **단일 값을 계산해서 출력**           |

(1) WHERE 절에 쓰는 서브쿼리 (가장 흔한 형태)

e.g. 급여가 전체 평균보다 높은 교수를 찾기
```sql
SELECT name, salary
FROM instructor
WHERE salary > (
  SELECT AVG(salary)
  FROM instructor
);
```
- `SELECT AVG(salary)` → 서브쿼리: 전체 평균 급여 계산 
- 바깥 쿼리에서 그보다 급여가 높은 사람을 찾음

(2) FROM 절에 쓰는 서브쿼리
- 서브쿼리를 임시 테이블처럼 사용해서 JOIN이나 GROUP BY와 함께 쓴다.

e.g. 학과별 평균 급여를 구하고 그것만 따로 출력
```sql
SELECT dept_name, avg_salary
FROM (
  SELECT dept_name, AVG(salary) AS avg_salary
  FROM instructor
  GROUP BY dept_name
) AS dept_avg
WHERE avg_salary > 70000;
```
-> 내부 서브쿼리가 부서별 평균 급여를 만든 테이블이 되고,  
그걸 바깥 쿼리에서 필터링

(3) SELECT 절에서 쓰는 서브쿼리
- 컬럼 하나의 값을 서브쿼리 결과로 채우기 (단일 값이어야 함)

e.g. 각 교수 이름과 전체 교수의 평균 급여 함께 출력
```sql
SELECT name,
       salary,
       (SELECT AVG(salary) FROM instructor) AS avg_salary
FROM instructor;
```
-> 각 행마다 `avg_salary` 컬럼에는 동일한 평균값이 표시된다.

요약하면 다음과 같다.

| 위치       | 예시                                  | 용도             |
| -------- | ----------------------------------- | -------------- |
| `WHERE`  | `salary > (SELECT AVG(salary) ...)` | 조건 비교          |
| `FROM`   | `FROM (SELECT ...) AS temp`         | 서브쿼리를 테이블처럼 사용 |
| `SELECT` | `SELECT name, (SELECT ...)`         | 결과에 단일 값 포함    |

주의사항
- 서브쿼리의 결과가 여러 행이면 오류 발생 (단일 값만 기대하는 곳에선)
- `IN`, `EXISTS`, `ANY`, `ALL` 등의 연산자와 함께 쓰면 다중 행 비교도 가능해요 (다음에 설명 가능!)


**Set Membership**

★ 꼭 이해해보자.
```sql
SELECT COUNT(DISTINCT ID)
FROM takes
WHERE (course_id, sec_id, semester, year) IN (
  SELECT course_id, sec_id, semester, year
  FROM teaches
  WHERE teaches.ID = 10101
);
```
->
```sql
SELECT COUNT(DISTINCT takes.ID)
FROM takes ta, teaches te
WHERE te.ID = '10101' AND (
	te.course_id,
	te.sec_id, 
	te.semester,
	te.year
)
```

**Set Comparison**

`SOME`, `ALL` 연산자를 통해 Subquery 결과의 Relation과 바깥 Query를 비교하는 것이다.
다음 두 Query는 같은 결과를 반환한다.

`SOME`절
```sql
SELECT DISTINCT T.name
FROM instructor AS T, instructor AS S
WHERE T.salary > S.salary
  AND S.dept_name = 'Biology';
```
->
```sql
SELECT name
FROM instructor
WHERE salary > SOME (
  SELECT salary
  FROM instructor
  WHERE dept_name = 'Biology'
);
```
- Subquery의 결과 중 하나라도 조건을 만족시키는게 있다면 해당 Tuple을 참으로 판단한다.
- `SOME`은 `IN` 연산과 동일하지만 `SOME` 부정이 `NOT IN`과 동일한 것은 아니다.

`ALL` 절
`SOME`과 `ALL`의 상식적인 차이를 생각하면된다. 두 개의 절을 그림으로 비교하면 다음과 같다.
![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxGY6y%2FbtsbRJN0mVM%2FEoCMANyK2ADVgtN66hkuLk%2Fimg.png) ![300](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxTa1G%2FbtsbRKszQxF%2FQstFtyUQ6DSUv1Padn8wK0%2Fimg.png)

**Test for Empty Relations**

... `정리 필요`

**With Clause**

`WITH` 절은 `WITH`를 사용한 Query 내에서만 유효한 임시 Relation을 제공한다.
그 당시에만 동적으로 생성되었다가 지워진다.
```sql
WITH max_budget(value) AS (
  SELECT MAX(budget)
  FROM department
)
SELECT department.name
FROM department, max_budget
WHERE department.budget = max_budget.value;
```

**Complex Queries using With Clause**

e.g. 학과의 총합 salary가 학과별 총합 salary의 평균값보다 큰 경우의 학과 이름을 알고자 할 때
```sql
WITH
-- ① 각 학과의 총급여 계산
dept_total (dept_name, value) AS (
  SELECT dept_name, SUM(salary)
  FROM instructor
  GROUP BY dept_name
),

-- ② 모든 학과 총급여의 평균 계산
dept_total_avg(value) AS (
  SELECT AVG(value)
  FROM dept_total
)

-- ③ 평균보다 총급여가 많은 학과만 출력
SELECT dept_name
FROM dept_total, dept_total_avg
WHERE dept_total.value > dept_total_avg.value;
```
- `WITH`를 사용하여 `dept_total`과 `dept_total_avg`를 일시적으로 생성하여 값을 저장하고 `SELECT` 연산을 통해 비교한다. 연산 후 두 개의 Table은 사라진다.
- `WITH`는 복잡한 Query를 적을 때 중간 결과값을 저장하는 용도로 사용할 수 있다.

**Scalar Subquery**

Scalar Subquery란 Subquery의 결과가 하나의 Tuple, 즉 Single Value인 경우이다.
Scalar Subquery인 경우 어디에서나 쓸 수 있다.
- `SELECT` 내부
- Subquery의 결과는 하나여도 Relation이지만 암묵적으로 값을 추출하여 사용할 수 있다.
- 한 개 이상의 Tuple이 나오면 Rutime Error가 발생한다.

```sql
SELECT dept_name, 
  (
    SELECT COUNT(*)
    FROM instructor
    WHERE department.dept_name = instructor.dept_name
  ) AS num_instructors
FROM department;
```

**Motification of the Database**

**(1) Deletion**

```sql
DELETE FROM instructor;
```
- `instructor` Table에 있는 모든 Tuple 삭제

```sql
DELETE FROM instructor
WHERE dept_name = 'Finance';
```
- `instructor` 테이블에서 `dept_name`이 `'Finance'`인 강사만 삭제

```sql
DELETE FROM instructor
WHERE dept_name IN (
  SELECT dept_name
  FROM department
  WHERE building = 'Watson'
);
```
- 먼저 `department` 테이블에서 `building = 'Watson'`인 학과 이름들을 찾고
- 그 학과 이름을 기준으로 `instructor` 테이블에서 해당 학과에 속한 강사를 삭제한다.

아래 Query는 문제가 될 수 있다.
```sql
DELETE FROM instructor
WHERE salary < (SELECT AVG(salary) FROM instructor);
```
- 위 Query는 `instructor` Table에서 `salary`가 평균보다 낮은 사람들을 삭제한다.
- 하지만 `DELETE`가 진행되면서 Table이 변경되고 그에 따라 `AVG`도 계속 변할 수 있다.

하지만 SQL의 특수한 Query 처리 동작에 따라 위 코드는 문제없이 돌아간다.
- 면저 평균을 계산하고
- 그 값을 기준으로 조건에 맞는 행을 삭제한다.
-> SQL은 이를 자동으로 한 번만 평가하도록 처리해주므로 위 `Query`는 의도한 대로 작동한다.

**(2) Insertion**

기본적인 Insertion은 다음과 같다.
```sql
INSERT INTO course
VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);
```
- `course` Table에 새 과목 정보를 삽입한다.
- Column 순서를 명시하지 않으면 Table 정의 순서를 따른다.

```sql
INSERT INTO course (course_id, title, dept_name, credits)
VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);
```
- 같은 삽입이지만 Column을 명시함으로써 더 명확한 방식이다.

```sql
INSERT INTO student
VALUES ('3003', 'Green', 'Finance', NULL);
```
- `NULL` 값 삽입의 예시이다.

다음은 다른 Table의 Data를 가져와서 일괄 삽입할 때의 예시 코드이다.
```sql
INSERT INTO instructor
SELECT ID, name, dept_name, 18000
FROM student
WHERE dept_name = 'Music' AND total_cred > 144;
```
- `student` 테이블에서 음악학과(Music) 학생 중 학점이 144 초과인 사람들을 찾아서,
- 그들을 `instructor`로 추가 (급여는 고정값 18000)

중요 포인트는, `SELECT`는 먼저 완전히 평가되다는 것이다.
- SQL은 `INSERT ... SELECT`에서 `SELECT`를 먼저 완전히 평가하고, 그 결과를 나중에 `INSERT`한다.
```sql
-- 위험한 Query 예시
INSERT INTO table1
SELECT * FROM table1;
```
- 만약 `SELECT`가 먼저 완전히 평가되지 않고, 삽입과 동시에 수행된다면?
- 데이터가 무한 루프처럼 계속 복사될 수 있다.
-> 하지만 SQL은 `SELECT` 결과를 메모리에 복사해두고, 그 다음에 `INSERT`하기 때문에 안전하다.

**(3) Updates**

`정리 필요`

# 4. Intermediate SQL

[(데이터베이스시스템) Chapter 4 : Intermediate SQL — 좌충우돌 기록기](https://ccho.tistory.com/12?category=1168493)

**Joined Relations**

Join operation은 두 개의 릴레이션을 하나의 릴레이션으로 만드는 것이다. 
from 안에서 subquery로 사용이 가능하다.

Join operation은 다음 3가지 타입이 있다: 
1. Natural join
2. Inner join
3. Outer join

**(1) Natural Join**

Join을 하는 Relation 중에서 공통 속성의 값이 같은 Tuple만을 고려한다.
즉 다음 두 SQL 코드가 같은 의미라는 것이다.

```sql
SELECT name, course_id
FROM student, takes
WHERE student.ID = takes.ID;
```

```sql
SELECT name, course_id
FROM student NATURAL JOIN takes;
```
- SQL이 `student`와 `takes`에서 공통 속성 `ID`**를 자동으로 찾아서 JOIN
- 결과에는 `ID`는 한 번만 포함되며, `name`, `course_id` 출력

당연한 얘기지만, 여러 Relation도 결합할 수 있다.

**Dangerous in Natual Join**

하지만 Natural Join도 그냥 막 남발하면 안되고 주의해야될 점이 있다.
만약 수강한 과목의 리스트를 보고싶다고 가정해보자.

Correct Version
```sql
SELECT name, title
FROM student
NATURAL JOIN takes,
     course
WHERE takes.course_id = course.course_id;
```
- `student`와 `takes`에 대한 Natural Join이 이루어질 것이고, `WHERE`문에 의해 Join 결과에서 `takes.course_id = course의 course_id`인 경우만 나올 것이다.

Incorrect Version
```sql
SELECT name, title
FROM student
NATURAL JOIN takes
NATURAL JOIN course;
```
- 처음 Natural Join의 결과로 `(ID, name, dept_name, salary, course_id, sec_id)` 속성을 가지게 되었고, `course`의 속성이 `(course_id, title, dept_name, credits)`라면
- 이 두 결과로 `course_id = dept_name`인 경우에만 Join이 될 것이다. 그러면 소속 학과가 아닌 다른 학과 수업을 들은 조합은 모두 빠지게 되어, 원하는 값을 갖지 못한다.

-> 따라서 Join하기 전에 공통 속성을 살펴보고, Natural Join을 할지말지 결정해야 한다.
- 즉 Natural Join은 지가 다 알아서 해주니까 쓰기 전에 알아보고 쓰라는 소리다.

**Join Condition**

`ON`: Join 될 Relation에 대한 일반적인 조건을 정할 수 있다.
문자의 차이이지 `WHERE`문과 거의 유사하다고 보면 된다.
```sql
SELECT *
FROM student
JOIN takes ON student.ID = takes.ID;
```

```sql
SELECT *
FROM student, takes
WHERE student.ID = takes.ID;
```

**(2) Inner Join**

`? 왜 없음`

**(3) Outer Join**

정보의 손실을 피하기 위한 Join의 Extension 형태이다.
정보의 손실이 일어날 수 있는 상황은 다음과 같은 경우가 있다:

**Joined Types and Conditions**

**Joined Relations**

**Views**

항상 모든 사용자가 전체 논리적 모델을 보는 것은 적잘하지 않다. 이는 보안상으로도 적절하지 않고, 개개인에게도 불편할 것이다.
- View의 목적: 유저별로 접근 권한에 대한 제한을 두기 위해서이다. 따라서, 특정 사용자에게 일정 속성을 숨기기 위해 사용한다.
- View: 실제의 Relation이 아니다. 질의의 결과 Table로 만들어진, 가상의 Relation을 의미한다. 따라서 하나의 Relation에 대해 사용자마다 다른 모습으로 보일 수가 있다.

**View Definition**

```sql
CREATE VIEW view_name AS
<query expression>;
```
- `<query expression>`의 결과 Table을 `v`로 정의한다.
- 가상의 Relation이므로 Query의 결과 생성되는 새로운 Relation과는 다르다.

e.g. 강사 정보에서 Salary를 제외한 View
```sql
CREATE VIEW faculty AS
SELECT ID, name, dept_name
FROM instructor;
```

e.g. 사용 예: 생물학과 교수 이름 조회
```sql
SELECT name
FROM faculty
WHERE dept_name = 'Biology';
```

e.g. 학과별 Salary 총합 View 생성
```sql
CREATE VIEW departments_total_salary(dept_name, total_salary) AS
SELECT dept_name, SUM(salary)
FROM instructor
GROUP BY dept_name;
```

**Views Defined Using Other Views**

하나의 View는 또 다른 View를 정의하는 데 사용될 수 있다:
- Depend Directly: v1, v2가 있을 때 v1을 정의하는 데 있어 v2를 사용하였다면 v1은 v2에 Depend Directly를 한다.
- Depend On: v1이 직접적으로 의존하거나 v1에서 v2로 가는 데에 의존성경로가 있다면 이를 합쳐서 Depend On한다고 한다.
- Recursive: 자기 자신을 스스로 의존하면 Recursive한다고 한다. 샤용하진 않는다.

e.g. `physics_fall_2017` View 정의
```sql
CREATE VIEW physics_fall_2017 AS
SELECT course.course_id, sec_id, building, room_number
FROM course, section
WHERE course.course_id = section.course_id
  AND course.dept_name = 'Physics'
  AND section.semester = 'Fall'
  AND section.year = '2017';
```
- `course`와 `section` Table을 Join해서 Fall 2017에 개설된 Physics 과목의 강의 정보들을 모든 View이다.
- Return Column: `course_id`, `sec_id`, `building`, `room_number`

e.g. 위 View를 활용한 또 다른 View
```sql
CREATE VIEW physics_fall_2017_watson AS
SELECT course_id, room_number
FROM physics_fall_2017
WHERE building = 'Watson';
```
- 위에서 만든 `physics_fall_2017` View를 재사용하여 강의가 Watson 건물에서 열리는 경우만 필터링하고있다.
- Return Column: `course_id`, `room_number`

**View Expansion**

```sql
-- View 사용 쿼리:
SELECT course_id, room_number
FROM physics_fall_2017
WHERE building = 'Watson';

-- 👇 View Expansion 결과 (실제 수행되는 형태):
SELECT course_id, room_number
FROM (
  SELECT course.course_id, building, room_number
  FROM course, section
  WHERE course.course_id = section.course_id
    AND course.dept_name = 'Physics'
    AND section.semester = 'Fall'
    AND section.year = '2017'
) AS physics_fall_2017
WHERE building = 'Watson';
```
1. View 안에 또 다른 View가 있으면 중첩적으로 치환된다.
2. 재귀적 정의가 아니라면 확장은 반드시 종료된다.
3. 실제 실행 계획은 모든 View 정의가 해체된 완전한 SELECT문 기준으로 실행된다.

알고리즘으로 나타내보면 sudo code는 다음과 같다.
```
repeat
	Find any view relation vi in e1
	Replace the view relation viby the expression defining vi
until no more view relations are present in e1
```

**Materialized Views**

view를 사용하면, 
```
v1 -> (참조) v2 -> (참조) v3 -> ..
```
과 같이 계속해서 이전 view로 가야하므로 시간이 오래 걸린다는 단점이 있다.

Materialized View:
- 원래 view의 특성은 저장하는 것이 아니지만, 위와 같은 단점을 피하기 위해 특정 데이터베이스시스템에서는 view relation을 물리적으로 저장하는 것을 허락한다. 그렇게 실제로 저장된 view를 Materialized view라고 한다.
- 이렇게 저장을 하게 되면, Query가 업데이트될 때, Materialized View는 반영이 안된 View가 되어버린다. 따라서 Materialized View를 관리하여 계속적으로 갱신이 되어야 한다.

**Update of a View**

e.g. 문제 상황
```sql
INSERT INTO faculty VALUES ('30765', 'Green', 'Music');
```
- `faculty` View에 데이터를 삽입하려는 시도이다.
- View에는 `salary`가 없지만 기본 Table `instructor`에는 `salary`가 필수이다.

문제의 원인은 다음과 같다:
- `salary`는 `instructor` Table에서 `NOT NULL`일 수 있다.
- `faculty` View에는 그 Column이 없으므로 `INSERT` 시에 그 값을 제공할 수 없다.

다음과 같은 두 가지 처리 방법이 가능하다:
1. Reject the Insert
2. Insert the Tuple with NULL: `('30765', 'Green', 'Music', NULL)`
	- `salary = NULL`이므로 후속 처리가 필요할 수 있다.

**Some Updates Cannot be Translated Uniquely**

하지만 위와 같은 예시가 아닌 다른 상황의 Update는 해결이 안될 수도 있다.

e.g. 문제 상황
```sql
CREATE VIEW instructor_info AS
SELECT ID, name, building
FROM instructor, department
WHERE instructor.dept_name = department.dept_name;

INSERT INTO instructor_info
VALUES ('69987', 'White', 'Taylor');
```
- View를 통해 새로운 교수를 건물 Taylor에 있는 학과로 삽입하려는 시도이다.

문제의 원인은 다음과 같다:
- 어떤 학과에 넣을지 알 수 없다.
- `building = 'Taylor'`인 학과가 없을 수도 있다.
- 삽입 후 View에서 해당 Tuple이 보이지 않을 수 있다.

결론적으로 이 View는 삽입 불가능하다.
-> View가 `JOIN`, `GROUP BY`, 집계 함수 등을 포함할 경우,
-> DBMS는 `INSERT/UPDATE/DELETE`를 허융하지 않을 수 있다.

**View Updates in SQL**

대부분의 SQL은 Simple View에 대해서만 Update를 허용한다.

Simple View의 조건은 다음과 같다:
- `FROM`은 하나의 Relation만 있어야 한다.
- `SELECT`에서는 어떠한 Expression, Aggregation, Distinct 등을 허용하지 않는다.
- `SELECT`에 없는 속성은 `NULL`로 한다.
- `GROUP BY`, `HAVING`은 허용하지 않는다.

**And Some Not at All**

하지만 Simple View여도 다음과 같은 문제가 발생할 수 있다.
```sql
CREATE VIEW history_instructors AS
SELECT *
FROM instructor
WHERE dept_name = 'History';

INSERT INTO history_instructors
VALUES ('25566', 'Brown', 'Biology', 100000);
```
- 이 데이터는 `dept_name = 'Biology'` 이므로 View의 조건에 맞지 않는다.
- 하지만 SQL 기본 동작에서는 그냥 `instructor` Table에 삽입은 되어버리고, `history_instructors` View에는 보이지 않는 상황이 발생할 수 있다.

해결 방법: `WITH CHECK OPTION`
```sql
CREATE VIEW history_instructors AS
SELECT *
FROM instructor
WHERE dept_name = 'History'
WITH CHECK OPTION;
```
- View를 통해 삽입(INSERT) 또는 수정(UPDATE)되는 데이터가 View 정의의 WHERE 조건을 만족하지 않으면 거부된다.
- Update도 마찬가지로 제한된다.

**Transactions**

데이터베이스의 상태를 변화(검색, 업데이트 등)시키고자 하는 일련의 시퀀스이다. 
SQL문이 시작할 때 암묵적으로 transaction이 시작된다. 
transaction은 반드시 이 두 개 중 하나로 끝나는 것을 보장한다. 

1. Commit work : transaction에 의해 수행된 갱신을 데이터베이스에 영구적으로 반영한다. 
2. Rollback work : 현재 수행중인 transaction을 roll back시킨다. 즉, 이루어진 모든 갱신을 취소시킨다. 

돈 인출을 예로 들면 아예 10만원을 인출하거나(완전히 수행되어 commit) , 인출하기 전에 갑작스러운 통신 중지가 일어나면 그 전으로 돌아가거나 (roll back) 둘 중에 하나를 항상 guarantee한다. 이 중간은 존재하지 않는다. 따라서 Transaction은 항상 atomic해야 한다.

동시에 여러 transaction이 발생했을 때, 순서를 정해서 sequential하게 isolate시켜야 한다.

**Integrity Constraints**

Integrity Constraints(무결성 제약조건) :accidental damage to the database를 방지하기 위해 둔 여러 제약 조건들이다. 
데이터베이스의 변경이 data consistency의 손실을 초래하지 않도록 한다. 
예를 들면 다음과 같은 조건들이다: salary는 한시간에 최소 4달러야 한다. customer은 null이 아닌 전화번호가 있어야 한다. 등..

이론적으로 무결설제약조건은 DB와 관계된 임의의 술어가 될 수 있다. 그런데, 이러한 술어는 검증하는 데에 시간이 많이 든다. 따라서 대부분 실제 DB에서는 최소한의 overhead로 검증할 수 있는 무결성 제약조건만을 허용한다.

**Constraints on a Single Relation**

- **Not NULL** : 테이블 속성을 정의할 때 NULL 가능여부를 제약조건으로 둘 수 있다. Not NULL이면 NULL인 Tuple은 삽입이 안된다. 
- **PK**
- **Unique** : `unique(A1, A2, ..)`이면 `A1, A2..`가 Unique하여 후보키를 구성한다는 것을 의미한다.
- **Check(P)** : 모든 Tuple에 대해 P를 만족해야한다. 예를 들어 `check(budget > 0)`하면 `budget`가 0보다 큰 것을 보장한다. 또 예를 들어 다음과 같은 명령어를 보자.

```sql
CREATE TABLE section (
  course_id      VARCHAR(8),
  sec_id         VARCHAR(8),
  semester       VARCHAR(6),
  year           NUMERIC(4, 0),
  building       VARCHAR(15),
  room_number    VARCHAR(7),
  time_slot_id   VARCHAR(4),
  PRIMARY KEY (course_id, sec_id, semester, year),
  CHECK (semester IN ('Fall', 'Winter', 'Spring', 'Summer'))
);
```
- 여기서 `CHECK`절은 `semester`이 다음 4가지 중에서는 하나여야 함을 정의하고 있다.

**Referential Integrity**

`아 힘들어`

**Cascading Actions in Referential Integrity**

**Integrity Constraint Violation During Transactions**

**Complex Check Conditions**

Check 조건은 `section` Relation에 Tuple이 삽입되거나 삭제되었을 뿐만 아니라 `time slot` Relation이 삭제, 삽입 등으로 변경이 생겼을 때에도 체크한다.

**Assertions**

Assertion은 DB가 항상 만족시키길 원하는 조건을 표현한 술어이다.
```sql
CREATE ASSERTION assertion_name
CHECK (<predicate>);
```

e.g.
```sql
CREATE ASSERTION credits_earned_constraint
CHECK (
  NOT EXISTS (
    SELECT ID
    FROM student
    WHERE tot_cred <>
      (SELECT COALESCE(SUM(credits), 0)
       FROM takes NATURAL JOIN course
       WHERE student.ID = takes.ID
         AND grade IS NOT NULL
         AND grade <> 'F')
  )
);
```
- `student` Relation의 각 Tuple에 대해서 `tot_cred` 값은 성공적으로 수강을 마칮 수업 학점의 합과 같아야 한다. 즉, 다른 경우가 항상 존재하지 않음을 체크한다.
- 만약 같지 않으면 `Assertion`에 의해 어떠한 Error 값이 나올 것이다.

**Built-in Data Types in SQL**

SQL에서 기본적으로 제공하는 Type들이 있다.

| 데이터 타입      | 설명                          | 예시                                                   |
| ----------- | --------------------------- | ---------------------------------------------------- |
| `DATE`      | 연-월-일만 포함 (시각 없음)           | `DATE '2005-07-27'`                                  |
| `TIME`      | 시:분:초만 포함 (날짜 없음)           | `TIME '09:00:30'` 또는 `TIME '09:00:30.75'`            |
| `TIMESTAMP` | 날짜 + 시간 (둘 다 포함)            | `TIMESTAMP '2005-07-27 09:00:30.75'`                 |
| `INTERVAL`  | **기간**(예: 3일, 2시간 5분 등)을 표현 | `INTERVAL '1' DAY`, `INTERVAL '2:30' HOUR TO MINUTE` |

**Large-Object Types**

Large Object Type은 보통 동영상 Data와 같이 용량이 큰 것들을 저장해야할 때 사용한다.
다음 두 가지로 이루어져 있다:
- blob(binary large object)
- clob(character large object)
보통 고용량 데이터 자체를 가리킨다기보다는 데이터가 저장되어있는 주소를 저장한다.
이를 해석하는 것은 Application이 할 일이다.

**User-Defined Types**

User가 `CREATE TYPE`을 통해 직접 Type를 지정할 수 있다.
```sql
CREATE TYPE <type_name> AS <base_type> [FINAL];
```

e.g.
```sql
CREATE TABLE department (
  dept_name VARCHAR(20),
  building  VARCHAR(15),
  budget    Dollars
);
```

**Domains**

Type과 굉장히 유사한 개념으로, User가 Domain을 직접 정의할 수 있다.
Type과의 차이점이 있다면 아래와 같은 제약 조건(Not NULL)을 붙일 수 있다.
```sql
CREATE DOMAIN domain_name data_type [CONSTRAINT constraint_name CHECK (...)]

CREATE DOMAIN person_name CHAR(20) NOT NULL;
CREATE TABLE student (
  ID INT,
  name person_name
);
```

e.g. `CHECK` 제약을 포함한 Domain
```sql
CREATE DOMAIN degree_level VARCHAR(10)
  CONSTRAINT degree_level_test
  CHECK (VALUE IN ('Bachelors', 'Masters', 'Doctorate'));
```

**Index Creation**

Index 개념에 대해서는 학기 말 쯤 자세히 배우게 될 것이다.
Index란 DB에 대한 검색 성능의 속도를 높여주는 일종의 자료구조라고 할 수 있다.
대용량의 Table에서 특정 Record를 찾기 위해 모든 Record를 하나씩 확인하는 것은 너무나 비효율적이다. 따라서 자료구조에서 Tree와 같이 같은 검색도 조금 더 효육적으로 찾을 수 있도록 하는 것이다.

사용자가 특정한 Index를 생성할 수 있다. `사실 Index를 생성하는 것은 Overhead라고 한다.
보통 우리는 PK에 Index를 거는 경우가 많다.
다음과 같은 형식을 따른다.
```sql
CREATE INDEX index_name
ON table_name (attribute_name);
```

e.g.
```sql
CREATE TABLE student (
  ID         VARCHAR(5),
  name       VARCHAR(20) NOT NULL,
  dept_name  VARCHAR(20),
  tot_cred   NUMERIC(3, 0) DEFAULT 0,
  PRIMARY KEY (ID)
);

-- Tree 구조의 Index 생성
CREATE INDEX studentID_index
ON student(ID);

-- Query 예시, 끄집어낼 때 자동적으로 최적화가 된다.
-- ID가 아니면 
SELECT *
FROM student
WHERE ID = '12345';
```
- `ID`와 다르게 Index가 걸져있지 않은 Attribute로 검색할 경우 DBMS는 전체 Table을 다 뒤진다.
- 빠르게 검색되는 만큼 그만큼의 비용도 있다.

**Authorization**

User에게 다음과 같은 다양한 권한을 줄 수 있다:
- Read: 읽기만 가능, 수정 금지
- Insert: 추가 가능, 수정 금지
- Update: 수정 가능, 삭제 금지
- Delete: 삭제 가능
선택적으로 줄 수 있다.

DB Schema에 대한 권한도 있다:
- Index: Index들의 생성과 삭제 가능
- Resource: 새로운 Relation 생성 가능
- Alteration: Relation의 Attribute 추가 또는 삭제 가능
- Drop: Relation의 삭제 가능

**Authorization Specification in SQL**

`GRANT`: 권한 수여 명령어
```sql
GRANT <privilege list>
ON <relation or view>
TO <user list>;
```
- `<privilege list>`: 어떤 작업 권한을 줄 것인지 (예: `SELECT`, `INSERT`, `ALL PRIVILEGES`)
- `<relation or view>`: 권한을 적용할 테이블이나 뷰 이름
- `<user list>`: 사용자 이름, 또는 `PUBLIC` (= 모든 사용자)

Priveledge는 다음과 같은 것들이 있다:
- Select : 릴레이션/뷰를 읽을 수 있는 권한
- Insert : 튜플을 삽입할 수 있는 권한
- Update : 튜플을 수정할 수 있는 권한
- Delete: 튜플을 삭제할 수 있는 권한
- All Privileges: 모든 권한 허용

**Revoking Authorization in SQL**

`REVOKE`: 권한 회수 명령어
```sql
REVOKE <privilege list>
ON <relation or view>
FROM <user list>;

REVOKE SELECT ON student FROM U1, U2, U3;
```
- `<privilege list>`에 `ALL`을 쓰면, 모든 권한을 회수하는 것을 의미한다. 
- `<user list>`에 `PUBLIC`을 쓰면, 명시적으로 grant를 한 유저 외에 모든 유저는 권한을 잃는다. 
- 만약 p1이라는 권한이 p2에서 나왔고, p2가 p3에서 나온 권한이라고 가정해보자. 여기서 p3을 Revoke시키면 p1까지 모두 Revoke된다.

**Roles**

일종의 User Group라고 보면된다.
각 개인에 대해 권한을 부여하는 것보다는 하나의 그룹에 한 Type의 구너한을 주는 것이 더 효율적일 것이다.
이렇게 User Group을 식별할 수 있는 개념을 Roles라고 한다.

Role의 생성
```sql
-- Role 생성
CREATE ROLE instructor;

-- User에게 Role 부여
GRANT instructor TO Amit;

-- Role에 Priviledge 부여
GRANT SELECT ON takes TO instructor;
```

Role Chaning: Role 간 계층 구조 만들기
```sql
-- Role -> Role 부여
CREATE ROLE teaching_assistant;
GRANT teaching_assistant TO instructor;

-- User에게 최종 Role 부여
CREATE ROLE dean;
GRANT instructor TO dean;
GRANT dean TO Satoshi;
```
- `Satoshi`는 `dean`의 권한도 받고, `instructor`의 권한도 받게 된다.

**Authorization on Views**

e.g.
```sql
-- View 생성
CREATE VIEW geo_instructor AS
SELECT *
FROM instructor
WHERE dept_name = 'Geology';

-- Role에 SELECT 권한 부여
GRANT SELECT ON geo_instructor TO geo_staff;

-- geo_staff가 이 Query를 실행함
SELECT * FROM geo_instructor;
```
- `instructor`에서 `Geology` 학과만으로 View를 만들고, `geo_staff`에게 해당 View를 볼 수 있는 권한을 부여하였다.
- 그리고 해당 스태프가 `geo_instructor`로부터 Select한다고 했을 때, View의 관점에서 결국 스태프는 `instructor`에 접근하게 되는 것이다.

`geo_staff가` 기반 테이블 instructor에는 접근 권한이 없고, 단지 View `geo_instructor`에만 SELECT 권한을 가진 경우가 되는 것이다.
- View 실행 권한을 누구의 권한으로 해석할 것인가?
	-> Query를 실행하는 사용자 `geo_staff`의 권한을 기준으로 판단 하거나,
	-> View를 만든 사람 `instructor`의 권한을 기준으로 판단한다.
- View 생성자가 `instructor` 권한이 없었다면?
	-> View 생성 자체가 실패한다.

**Other Quthorization Features**

`GRANT`는 `REFERENCE`를 통해 FK를 생성하는 권한을 부여할 수도 있다.
```sql
GRANT REFERENCES (dept_name) ON department TO Mariano;
```
- `Mariano`에게 `department` Relation에 `dept_name` Attibute에 FK를 선언할 수 있는 권한을 부여하였다.

이게 왜 필요할까?:
- FK Constraint에 의해, FK가 생성이되면 참조되는 Relation에서 Tuple을 삭제/삽입/갱신할 때 제약이 생길 수 있다. 따라서 생성에 있어서도 제한을 두는 것이다.

다른 사람에게 권한을 줄 수도 있다:
```sql
-- 권한의 위임
GRANT SELECT ON department TO Amit WITH GRANT OPTION;

-- 권한 회수, CASCADE: 연쇄적으로 회수
REVOKE SELECT ON department FROM Amit, Satoshi CASCADE;

-- 권한 회수, RESTRICT: 연결된 권한 있으면 거부
REVOKE SELECT ON department FROM Amit RESTRICT;
```

# 7. Normalization

[(데이터베이스) CH7. Relational Database Design(Normalization)](https://0o0deng.tistory.com/entry/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-CH7-Relational-Database-DesignNormalization)

**Features of Good Relational Desings**

**Funtional Dependencies**

 Real-world Data에는 여러가지 Constraints, Rule이 존재한다.
- Legal Instance: 모든 Real-world Constraints를 만족하는 Relation의 Instance이다.

Functional Dependency:
- 어떤 속성 집합 $\alpha$의 값이 결정되면, 속성 집합 $\beta$의 값도 항상 유일하게 결정되는 관계

표현은 다음과 같다.
$$\alpha \rightarrow \beta$$
- $\alpha$: 결정자(Determinant)
- $\beta$: 종속자(Dependent)

Relation Schema $R$에서 $\alpha \subseteq R$, $\beta \subseteq R$ 일 때 $\alpha \rightarrow \beta$가 $R$에서 성립하려면
임의의 Tuple $t_1, t_2$가 $\alpha$ 값이 같으면 반드시 $\beta$ 값도 같아야 한다.
$$t_1[\alpha] = t_2[\alpha] \Rightarrow t_1[\beta] = t_2[\beta]$$
- 즉, 앞의 것이 Unique 할 때 뒤의 것이 하나로 결정되는 경우를 Funtional Dependency가 Hold 된다고 말한다. `hold on R`

e.g.
```
A   B
1   4
1   5
3   7
```
- $B \rightarrow A$는 성립하지만,
- $A \rightarrow B$는 성립하지 않는다. $A=1$ 인 두 행의 $B$ 값은 각각 $4, 5$이기 때문이다.
- $AB$는 A와 B가 동시에 주어지면, 이라는 뜻이다.

**Closure of a Set of Functional Dependencies**

만약 $A \rightarrow B, B \rightarrow C$ 라는 Dependency가 있다면 우린 $A \rightarrow C$ 도 성립합을 알 수 있다.

Closure of F
- 이런 식으로 Functional Dependencies의 집합 $F$가 주어졌을 때, $F$로부터 추론해서 얻어낼 수 있는 모든 Funtional Dependency를 Closure of F라고 부른다.
- $F^+$

**Keys and Functional Dependency**

**Use of Functional Dependencies**

**Trivial Funcional Dependencies**

다음과 같은 경우는 항상 Trivial 하게 True이다.
$$
\begin{align}
A \rightarrow A \\
AB \rightarrow A
\end{align}
$$
- 보통 $\alpha \rightarrow \beta$에서 $\beta \subseteq \alpha$이면 항상 참이다.

**Lossless Decomposition**

Lossless Decomposition은 정보 손실 없이 분해하는 것이 목적이다.
$R = (R_1, R_2)$로 분리 해서 모든 가능한 Relation $r$을 생성했다고 했을 때, $r = R$이여야 한다.
$$r = \Pi_{R1}(r) \bowtie \Pi_{R2}(r)$$
- $R_1 \cap R_2 \rightarrow R_1$ 또는 $R_1 \cap R_2 \rightarrow R_2$ 중 하나라도 Funcional Dependency를 만족하면 Lossless Decomposition이다.
- 하지만 Lossless Decomposition이라고 해도 $R_1 \cap R_2 \rightarrow R_1$ 또는 $R_1 \cap R_2 \rightarrow R_2$이 성립하는지는 알 수 없다.

e.g.
$$R = (A, B, C),\ F = \{A \rightarrow B, B \rightarrow C\}$$
Lossless Decomposition?
- O, $R_1 = (A, B),\ R_2 = (B, C)$: $R_1 \cap R_2 = \{B\} \text{ and } B \rightarrow BC$
- O, $R_1 = (A, B),\ R_2 = (A, C)$: $R_1 \cap R_2 = \{A\} \text{ and } A \rightarrow AB$
둘 다 성립한다.

**Dependency Preservation**

Dependency Constraints가 지켜졌는지 아닌지를 매번 Join을 해봐야 아는지, 아니면 바로 알 수 있는지 여부:
- DB가 업데이트 될 때 마다 FD(Fundtional Dependency) Constraints를 테스트 하려면 비용이 많이 들 수 있다.
- 따라서 COnstraints를 효율적으로 데스트할 수 있게 DB를 설계하는 것이 좋다.
- 하나의 Relation만 고려해 FD Constraint를 테스트할 수 있다면 비용이 적게 든다.
- 그러나 Decomposing 과정에서 Cartesian 곱을 사용하지 않으면 테스트를 할 수 없게 되기도 한다.

**Dependency Preservation Example**

Functional Dependency를 확인하기 위해 Join을 해야하는 등, 어렵게 만드는 Decomposition의 경우 NOT Dependency Preserving이라고 부른다.

## 7.1 Normal Forms

**Boyce-Codd Normal Form (BCNF)**

Relation Schema R과 Functional Dependency $\alpha \rightarrow \beta$ 가 있을 때, 다음 중 하나를 만족해야 BCNF라 한다:
1. $\alpha \rightarrow \beta$ 가 Trivial 하다. (즉, $\beta \subseteq \alpha$)
2. $\alpha$가 R의 Superkey이다.
즉 *결정자 $\alpha$가 Relation 전체를 유일하게 결정할 수 있어야 한다.*

e.g. NOT BCNF

Relation Schema:
```
in_dep(ID, name, salary, dept_name, building, budget)
```

Functional Dependency:
```
dept_name → building, budget
```
- `dept_name`은 Superkey가 아니다. 여러 사람이 같은 부서에 속할 수 있기 때문이다.
- 그런데 `dept_name`이 `building`과 `budget`을 결정하고 있으므로 이는 BCNF 위반이다.

이를 해결하기 위해 다음과 같은 방법이 제시된다.

e.g. 분해
BCNF를 만족하게 만들기 위해 Relation을 분해한다.

분해된 두 Table
1. `instructor`:
```
(ID, name, salary, dept_name)
```
- FD:`ID -> name, salary, dept_name`
- `ID`는 Superkey이므로 BCNF 만족

2. `department`:
```
(dept_name, building, budget)
```
- FD: `dept_name -> building, budget`
- `dept_name`은 이 Table의 Superkey이므로 BCNF 만족

**Decomposing a Schema into BCNF**

Relation R을 다음과 같이 Decompose하면 된다:
- $R1 = \alpha \cup \beta$: $\alpha$와 $\beta$를 포함하는 Table
- $R2 = R - (\beta - \alpha)$: 나머지 속성들을 $\alpha$와 함께 묶은 Table

위의 `dept_name`예시로 이를 이해해보면 된다.

**BCNF and Dependency Preservation**

BCNF와 Dependency Preserving Decomposition을 언제나 동시에 만족시킬 수는 없다.

e.g.
```
dept_advisor(s_ID, i_ID, department_name)
i_ID -> dept_name
s_ID, dept_name -> i_ID
```
- `i_ID`가 Superkey가 아니므로 Decomposition을 해야한다.
- 그러나 세 개의 속성 모두 두 개의 FD에서 사용됐으므로 BCNF를 만족시키기 위해 어떻게 나눠도 `s_ID, dept_name -> i_ID`를 어떤 하나의 Relation에서 확인할 수가 없다. 즉, Dependency Preservation이 불가능하다.

**Third Normal Form (3NF)**

Relation Schema R과 Functional Dependency $\alpha \rightarrow \beta$ 가 있을 때, 다음 중 하나를 만족해야 3NF라 한다:
- $\alpha \rightarrow \beta$가 Trivial하다.
- $\alpha$가 R의 Superkey이다.
- $\beta - \alpha$의 각 속성이 Candidate Key에 속해야 한다.

3NF와 BCNF의 관계는 다음과 같다:
- BCNF $\subseteq$ 3NF: BCNF이면 무조건 3NF이다.
- 그러나 3NF라고 해도 BCNF는 아닐 수 있다.
즉, 3NF는 BCNF보다 덜 엄격한 Normal Form이다.

e.g.
```
dept_advisor(s_ID, i_ID, department_name)
i_ID -> dept_name
s_ID, dept_name -> i_ID
```
- FD1 `i_ID -> dept_name`: `dept_name`은 Candidate Key `{s_ID, dept_name}`에 포함되므로 3NF 조건을 만족한다.
- FD2 `s_ID, dept_name -> i_ID`: `{s_ID, dept_name}`은 Superkey이므로 3NF 조건을 만족한다.
즉 해당 Table은 BCNF는 만족하지 않지만, 3NF는 만족한다.

**Redundancy in 3NF**

`정리 필요`

## 7.2 Functional Dependency Theory

**Functional Dependency Theory Roadmap**

**Closure of a set of Functional Dependency**

Closure $F^+$: F로부터 추론될 수 있는 모든 Functional Dependencies

Armstrong's Axioms
- Reflexive Rule: $b \subseteq a$ 이면 $a \rightarrow b$
- Augmentation Rule: $a \rightarrow b$ 이면 $\gamma a \rightarrow \gamma b$
- Transitivity Rule: $a \rightarrow b$ 이고 $b \rightarrow c$ 이면 $a \rightarrow c$

**Example of $F^+$**

$F$에서 시작해서 Relexivity, Augmentation Rules, Combined Using Transitivity 과정을 거쳐 $F^+$에 추가해나간다.

**Closure of Attribute Sets**

## 7.3 Canonical Cover

**Canonical Cover**

- Relation Schema에 Functional Dependency F가 있다고 하자. 사용자가 Relation 을 업데이트 할 때마다 DB 시스템은 이 사항이 F의 모든 Dependency를 충족하는지 확인해야 한다.
- 만약 Violate한다면 Update는 Roll Back되어야 한다.
- 우리는 주어진 Set와 같은 Closure를 가진, 더 단순화 된 Runctional Dependency를 검사함으로서 드는 비용을 줄일 수 있다.
- 이 단순화 된 Functional Dependency 를 **Canonical Cover**라고 부른다.

**Extraneous Attributes**

- 없어도 무방한 Functional Dependency의 Attribute로, 이를 다 없애야 Canonical Cover를 찾을 수 있다.

(1) Remove Left Side -> Stronger Constraint
- $A\in \alpha$ 이고 $(F - \{\alpha - \beta\})\ \cup \ \{(\alpha - A) \rightarrow \beta \}$가 논리적으로 F를 추론할 수 있는 경우 Attribute A is Extraneous in $\alpha$ 하다고 한다.
- AB -> C에서 A -> C로 줄이면 A만 있어도 C를 알 수 있기에 더욱 강력해진다고 한다.

(2) Remove Right Size -> Weaker Constraint
- $A\in \beta$ 이고 F가 논리적으로 $(F - \{\alpha - \beta\})\ \cup \ \{\alpha \rightarrow (\beta - A)\}$를 추론할 수 있는 경우 Attribute A is Extraneous in $\beta$ 하다고 한다.
- AB -> CD에서 AB -> C로 줄이면 AB가 있어도 D를 알 수 없다.

