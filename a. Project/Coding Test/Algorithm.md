# 📌 Introduction

본 문서는 kukudas의 알고리즘 스터디를 기반으로 코테 준비를 위해 다양한 Algorithm을 공부하고 그것을 정리하는 문서이다.

#### Reference
[오리엔테이션(초급)](https://www.acmicpc.net/group/board/view/6719/15105)

#### 백준 문제 난이도
🟤 BRONZE
⚪ SILVER
🟡 GOLD
🟢 PLATINUM
🔵 DIAMOND
🔴 RUBY

여러 알고리즘 중에서 특정 알고리즘은 어떻게 고르냐?
- 시간 제한 고려 (미표기시 1s, `O(10^8)정도를 1s라고 생각할 수 있다.`)
- 가장 쉽게 짤 수 있으면서 Error가 날 여지가 적은 알고리즘

이를 위해 하나의 언어를 마스터 하는 것도 중요하지만, C++, Python, Scala등 문제에 따라 언어를 자유롭게 돌아가며 쓸 수 있는 것도 중요하다.
- String을 다루는 문제는 Python이 효과적이다.

# 📌 Brute-force

# 📌 DFS

# 📌 BFS

# 📌 DP

> `DP[n] = min(DP[n - 1], DP[n - 2])`, DP의 대표적인 예시 코드이다.

DP는 Dynamic Programming의 약자로, 특정 범위까지의 값을 구하기 위해서 그것과 다른 범위 까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘이다.
즉, **어떤 값을 구하기 위해서 어떤 값들이 필요하다는 뜻이다.**
대표적인 문제로는 ⚪2579 계단 오르기가 있다.

다음과 같은 유형의 문제들을 DP로 풀 수 있는 경우가 있다.
- 점화식 `점화식은 모두 DP로 풀 수 있다. 필수는 아니다.`
- 경우의 수
- 조합
- LIS

DP에서 흔히 할 수 있는 실수는 Bounding Error이다.
Start와 End를 잘 체크하도록 하자.
그리고 상태를 나눠서 점화식을 구하는 연습도 평소에 해두면 DP를 쉽게 풀 수 있을 것이다.

#### ⚪1463 1로 만들기

기본적인 DP를 사용하는 문제이다.
DP는 항상 그렇다. 답에서 출발하면 안되고 답에 도달할 생각을 해야한다.

문제에선 1을 만들기 위해 숫자를 3 또는 2로 나눌수 있고,
두 수로 나누어지지 않을 경우 1을 뺄 수 있다.

만약 3으로 나누어지는 숫자 n이 있다고 하면
- min_cal(n/3) + 1이 최선일수도 있고
- min_cal(n - 1) + 1이 최선일 수도 있다.
2로 나누어지는 숫자에서도 마찬가지이다.
이를 이용하여 DP를 설계하면 된다.

주의할 점은 n이 3과 2동시에 나누어 떨어질 때, 즉 6으로 나누어 떨어질 때이다.
- min_cal(n/3)
- min_cal(n/2)
- min_cal(n - 1)
을 모두 고려해야된단 소리이므로 조건문으로 먼저 6으로 나누어 떨어지는지를 검사하고 넘어가야한다.
이것 때문에 한 번 틀렸다.

#### ⚪
